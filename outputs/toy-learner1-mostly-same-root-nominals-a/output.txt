
---------------------

input line #0
input roots: [<__main__.Root object at 0x10fbeb3c8>]
input values: [{'+definite'}, {'+atomic'}]

create_vi: made nominalizer: null_1, triggers = set(), weight = 10.0
made our very first nominalizer: NominalizerTerminal:
    label: nominalizer
    values: set()
    selectional: {'FROG'}
    selection_strength: True
    weight: 10.0
    linear: (<__main__.NominalizerTerminal object at 0x10fbeb390>,)
we selected the nominalizer with values: set()
we broke out

now working with the word 'la', mapping to 1 terminals:

create_vi: made definite: la_1, triggers = set(), weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'la_1'} has root Root: FROG in its selectional

now working with the word 'FROG-a', mapping to 3 terminals:

create_vi: made atomic: a_1, triggers = set(), weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}

create_vi: made nominalizer: null_2, triggers = set(), weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_2', 'a_1'}

create_vi: made nominalizer: null_3, triggers = {('a', frozenset({'+atomic'}))}, weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_2', 'null_3', 'a_1'}

create_vi: made FROG: FROG_1, triggers = set(), weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_1', 'null_2', 'null_3', 'a_1'}

create_vi: made FROG: FROG_2, triggers = {('null', frozenset()), ('a', frozenset({'+atomic'}))}, weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_2', 'null_3', 'null_2', 'a_1', 'FROG_1'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fbff7f0>, '#', <__main__.Root object at 0x10fbffb70>, '-', <__main__.NominalizerTerminal object at 0x10fbffa90>, '-', <__main__.SemanticTerminal object at 0x10fbff940>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '+atomic'}
we picked la_1: no super match (neither decl nor L1-gender)
now spelling out FROG terminal with values set()
we picked FROG_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values set()
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: la#FROG-a
full_pronunciation: la#FROGa
vis_used:
Successful derivation!
VocabularyItem:
    pronunciation: la
    label: definite
    values: {'+definite', '+atomic'}
    diacritic: la_1
    triggers: set()
    weight: 10.0
VocabularyItem:
    pronunciation: FROG
    label: FROG
    values: set()
    diacritic: FROG_1
    triggers: set()
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 10.0
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 10.0
line done
line done

---------------------

input line #1
input roots: [<__main__.Root object at 0x10fbffcf8>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: set()
we broke out

now working with the word 'lo', mapping to 1 terminals:

create_vi: made definite: lo_1, triggers = set(), weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'lo_1'} has root Root: CASTLE in its selectional

now working with the word 'CASTLE-o', mapping to 3 terminals:

create_vi: made atomic: o_1, triggers = set(), weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}

create_vi: made nominalizer: null_4, triggers = set(), weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_4'}

create_vi: made nominalizer: null_5, triggers = {('o', frozenset({'+atomic'}))}, weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_4', 'null_5'}

create_vi: made CASTLE: CASTLE_1, triggers = set(), weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CASTLE_1', 'o_1', 'null_4', 'null_5'}

create_vi: made CASTLE: CASTLE_2, triggers = {('o', frozenset({'+atomic'})), ('null', frozenset())}, weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_4', 'null_5', 'CASTLE_2', 'o_1', 'CASTLE_1'}
done processing input, time to test
we selected the nominalizer with values: {'la_1'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc05e48>, '#', <__main__.Root object at 0x10fc08208>, '-', <__main__.NominalizerTerminal object at 0x10fc08128>, '-', <__main__.SemanticTerminal object at 0x10fc05f98>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'la_1', '+definite', '+atomic'}
we picked la_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CASTLE terminal with values set()
we picked CASTLE_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'la_1'}
we picked null_2: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: lo#CASTLE-o
full_pronunciation: la#CASTLEo
vis_used:
Failure
VocabularyItem:
    pronunciation: la
    label: definite
    values: {'+definite', '+atomic'}
    diacritic: la_1
    triggers: set()
    weight: 10.5
VocabularyItem:
    pronunciation: CASTLE
    label: CASTLE
    values: set()
    diacritic: CASTLE_1
    triggers: set()
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'la_1'}
    diacritic: null_2
    triggers: set()
    weight: 10.0
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 10.0
line done
line done

---------------------

input line #2
input roots: [<__main__.Root object at 0x10fc080b8>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: set()
we broke out

now working with the word 'le', mapping to 1 terminals:

create_vi: made definite: le_1, triggers = set(), weight = 10.0
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>]

create_vi: made definite: l_1, triggers = set(), weight = 10.0

create_vi: made Agr: a_2, triggers = set(), weight = 10.0

create_vi: made Agr: e_1, triggers = set(), weight = 10.0

create_vi: tried definite: l_1, triggers = set(), weight = 10.1..already existed

create_vi: made Agr: o_2, triggers = set(), weight = 10.0

create_vi: tried Agr: e_1, triggers = set(), weight = 10.1..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: KEY in its selectional

now working with the word 'KEY-i', mapping to 3 terminals:

create_vi: made atomic: i_1, triggers = set(), weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}

create_vi: made nominalizer: null_6, triggers = set(), weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_6', 'i_1'}

create_vi: made nominalizer: null_7, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_6', 'null_7', 'i_1'}

create_vi: made KEY: KEY_1, triggers = set(), weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'KEY_1', 'null_6', 'null_7', 'i_1'}

create_vi: made KEY: KEY_2, triggers = {('null', frozenset()), ('i', frozenset({'-atomic'}))}, weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'KEY_1', 'null_7', 'i_1', 'KEY_2', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'e_1'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc0a518>, '-', <__main__.AgrTerminal object at 0x10fc08cf8>, '#', <__main__.Root object at 0x10fc0a898>, '-', <__main__.NominalizerTerminal object at 0x10fc0a7b8>, '-', <__main__.SemanticTerminal object at 0x10fc0a668>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out KEY terminal with values set()
we picked KEY_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1'}
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: le#KEY-i
full_pronunciation: le#KEYi
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: KEY to the selectional of the nominalizer whose values are {'e_1'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1'}
    selectional: {'KEY'}
    selection_strength: True
    weight: 10.0
    linear: (<__main__.NominalizerTerminal object at 0x10fbeb2e8>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 10.1
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 10.1
VocabularyItem:
    pronunciation: KEY
    label: KEY
    values: set()
    diacritic: KEY_1
    triggers: set()
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 10.5
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 10.0
line done
line done

---------------------

input line #3
input roots: [<__main__.Root object at 0x10fc0a5f8>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: set()
we broke out

now working with the word 'uno', mapping to 1 terminals:

create_vi: made definite: uno_1, triggers = set(), weight = 10.0
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>]

create_vi: tried Agr: o_2, triggers = set(), weight = 10.1..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 10.7..already existed

create_vi: made definite: un_1, triggers = set(), weight = 10.0
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}

create_vi: made nominalizer: null_8, triggers = set(), weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}

create_vi: made nominalizer: null_9, triggers = {('o', frozenset({'+atomic'}))}, weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}

create_vi: made GRANDPARENT: GRANDPARENT_1, triggers = set(), weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'GRANDPARENT_1', 'null_9'}

create_vi: made GRANDPARENT: GRANDPARENT_2, triggers = {('o', frozenset({'+atomic'})), ('null', frozenset())}, weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'GRANDPARENT_1', 'GRANDPARENT_2'}
done processing input, time to test
we selected the nominalizer with values: {'e_1'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc0ebe0>, '#', <__main__.Root object at 0x10fc0ef60>, '-', <__main__.NominalizerTerminal object at 0x10fc0ee80>, '-', <__main__.SemanticTerminal object at 0x10fc0ed30>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'e_1', '-definite', '+atomic'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1'}
we picked null_7: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: uno#GRANDPARENT-o
full_pronunciation: un#GRANDPARENTa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 10.0
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_1
    triggers: set()
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_7
    triggers: {('i', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 10.5
line done
line done

---------------------

input line #4
input roots: [<__main__.Root object at 0x10fc0ecc0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 10.799999999999999..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 10.7..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 10.1..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 10.899999999999999..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}

create_vi: made nominalizer: null_10, triggers = set(), weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}

create_vi: made nominalizer: null_11, triggers = {('a', frozenset({'+atomic'}))}, weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'GRANDPARENT_1'}

create_vi: made GRANDPARENT: GRANDPARENT_3, triggers = {('null', frozenset()), ('a', frozenset({'+atomic'}))}, weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'GRANDPARENT_1', 'null_11', 'null_10', 'GRANDPARENT_3'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc10550>, '-', <__main__.AgrTerminal object at 0x10fc14d30>, '#', <__main__.Root object at 0x10fc108d0>, '-', <__main__.NominalizerTerminal object at 0x10fc107f0>, '-', <__main__.SemanticTerminal object at 0x10fc106a0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: la#GRANDPARENT-a
full_pronunciation: lo#GRANDPARENTo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 10.899999999999999
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 10.1
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_2
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 11.0
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 10.0
line done
line done

---------------------

input line #5
input roots: [<__main__.Root object at 0x10fc10780>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: set()
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 10.899999999999999..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 10.799999999999999..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 10.2..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 10.999999999999998..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}

create_vi: made CHILD: CHILD_1, triggers = set(), weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'CHILD_1', 'a_1'}

create_vi: made CHILD: CHILD_2, triggers = {('null', frozenset()), ('a', frozenset({'+atomic'}))}, weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CHILD_1', 'a_1', 'CHILD_2', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc0ed30>, '-', <__main__.AgrTerminal object at 0x10fc0ecc0>, '#', <__main__.Root object at 0x10fc0a898>, '-', <__main__.NominalizerTerminal object at 0x10fc0ac18>, '-', <__main__.SemanticTerminal object at 0x10fc0e390>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#CHILD-a
full_pronunciation: la#CHILDa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CHILD to the selectional of the nominalizer whose values are {'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'a_2'}
    selectional: {'GRANDPARENT', 'FROG', 'CHILD'}
    selection_strength: True
    weight: 10.2
    linear: (<__main__.NominalizerTerminal object at 0x10fc05f28>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 10.999999999999998
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 10.2
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_2
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 10.9
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 10.6
line done
line done

---------------------

input line #6
input roots: [<__main__.Root object at 0x10fc14e80>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 11.599999999999998..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 10.899999999999999..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 10.799999999999999..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 11.699999999999998..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'CHILD_1', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CHILD_1', 'a_1', 'CHILD_2', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc1a358>, '#', <__main__.Root object at 0x10fc1a6d8>, '-', <__main__.NominalizerTerminal object at 0x10fc1a5f8>, '-', <__main__.SemanticTerminal object at 0x10fc1a4a8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '+atomic'}
we picked lo_1: no super match (neither decl nor L1-gender)
now spelling out CHILD terminal with values set()
we picked CHILD_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values set()
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: la#CHILD-a
full_pronunciation: lo#CHILDa
vis_used:
Failure
VocabularyItem:
    pronunciation: lo
    label: definite
    values: {'+definite', '+atomic'}
    diacritic: lo_1
    triggers: set()
    weight: 10.0
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_1
    triggers: set()
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 11.4
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 11.2
line done
line done

---------------------

input line #7
input roots: [<__main__.Root object at 0x10fc1a0f0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: set()
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 10.1..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 11.799999999999997..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 10.0..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 10.1..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: MOUSE in its selectional

now working with the word 'MOUSE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}

create_vi: made MOUSE: MOUSE_1, triggers = set(), weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'MOUSE_1', 'null_8', 'o_1', 'null_9'}

create_vi: made MOUSE: MOUSE_2, triggers = {('o', frozenset({'+atomic'})), ('null', frozenset())}, weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'MOUSE_2', 'MOUSE_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc1c710>, '#', <__main__.Root object at 0x10fc1cac8>, '-', <__main__.NominalizerTerminal object at 0x10fc1c9b0>, '-', <__main__.SemanticTerminal object at 0x10fc1c860>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite', '+atomic', 'a_2'}
we picked uno_1: no super match (neither decl nor L1-gender)
now spelling out MOUSE terminal with values set()
we picked MOUSE_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'a_2'}
we picked null_11: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: uno#MOUSE-o
full_pronunciation: uno#MOUSEa
vis_used:
Failure
VocabularyItem:
    pronunciation: uno
    label: definite
    values: {'-definite', '+atomic'}
    diacritic: uno_1
    triggers: set()
    weight: 10.0
VocabularyItem:
    pronunciation: MOUSE
    label: MOUSE
    values: set()
    diacritic: MOUSE_1
    triggers: set()
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_11
    triggers: {('a', frozenset({'+atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 11.1
line done
line done

---------------------

input line #8
input roots: [<__main__.Root object at 0x10fc1ca20>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:

create_vi: made definite: una_1, triggers = set(), weight = 10.0
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 10.899999999999999..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 11.899999999999997..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 10.2..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 10.299999999999999..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'CHILD_1', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CHILD_1', 'a_1', 'CHILD_2', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc1eb38>, '#', <__main__.Root object at 0x10fc1eeb8>, '-', <__main__.NominalizerTerminal object at 0x10fc1edd8>, '-', <__main__.SemanticTerminal object at 0x10fc1ec88>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite', '+atomic'}
we picked uno_1: no super match (neither decl nor L1-gender)
now spelling out CHILD terminal with values set()
we picked CHILD_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values set()
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: una#CHILD-a
full_pronunciation: uno#CHILDa
vis_used:
Failure
VocabularyItem:
    pronunciation: uno
    label: definite
    values: {'-definite', '+atomic'}
    diacritic: uno_1
    triggers: set()
    weight: 9.9
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_1
    triggers: set()
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 11.3
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 11.1
line done
line done

---------------------

input line #9
input roots: [<__main__.Root object at 0x10fc1e630>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: set()
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 10.999999999999998..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 11.999999999999996..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 10.399999999999999..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 10.499999999999998..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: MILKCOW in its selectional

now working with the word 'MILKCOW-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}

create_vi: made MILKCOW: MILKCOW_1, triggers = set(), weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'MILKCOW_1'}

create_vi: made MILKCOW: MILKCOW_2, triggers = {('null', frozenset()), ('a', frozenset({'+atomic'}))}, weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'MILKCOW_1', 'MILKCOW_2', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'e_1'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc20eb8>, '#', <__main__.Root object at 0x10fc22278>, '-', <__main__.NominalizerTerminal object at 0x10fc22198>, '-', <__main__.SemanticTerminal object at 0x10fc22048>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'e_1', '-definite', '+atomic'}
we picked uno_1: no super match (neither decl nor L1-gender)
now spelling out MILKCOW terminal with values set()
we picked MILKCOW_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1'}
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: una#MILKCOW-a
full_pronunciation: uno#MILKCOWa
vis_used:
Failure
VocabularyItem:
    pronunciation: uno
    label: definite
    values: {'-definite', '+atomic'}
    diacritic: uno_1
    triggers: set()
    weight: 9.8
VocabularyItem:
    pronunciation: MILKCOW
    label: MILKCOW
    values: set()
    diacritic: MILKCOW_1
    triggers: set()
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 11.200000000000001
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 11.1
line done
line done

---------------------

input line #10
input roots: [<__main__.Root object at 0x10fc20b38>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:

create_vi: made definite: li_1, triggers = set(), weight = 10.0
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 12.099999999999996..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 11.099999999999998..already existed

create_vi: made Agr: i_2, triggers = set(), weight = 10.0

create_vi: tried definite: l_1, triggers = set(), weight = 12.199999999999996..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 10.2..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 10.1..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 12.299999999999995..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}

create_vi: made nominalizer: null_12, triggers = set(), weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}

create_vi: made nominalizer: null_13, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1', 'GRANDPARENT_1'}

create_vi: made GRANDPARENT: GRANDPARENT_4, triggers = {('null', frozenset()), ('i', frozenset({'-atomic'}))}, weight = 10.0
     what if we combine triggers with the otherwise identical vi GRANDPARENT_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?

create_vi: made GRANDPARENT: GRANDPARENT_5, triggers = {('null', frozenset()), ('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}, weight = 10.0
     -> created a new vi GRANDPARENT_5 	spelling out GRANDPARENT: set() 		 triggering {('null', frozenset()), ('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_3 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?

create_vi: made GRANDPARENT: GRANDPARENT_6, triggers = {('null', frozenset()), ('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}, weight = 10.0
     -> created a new vi GRANDPARENT_6 	spelling out GRANDPARENT: set() 		 triggering {('null', frozenset()), ('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1', 'GRANDPARENT_4', 'GRANDPARENT_1'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc206d8>, '#', <__main__.Root object at 0x10fc1e4e0>, '-', <__main__.NominalizerTerminal object at 0x10fc1ea20>, '-', <__main__.SemanticTerminal object at 0x10fc20048>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic'}
we picked li_1: no super match (neither decl nor L1-gender)
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_6: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#GRANDPARENT-i
full_pronunciation: li#GRANDPARENTi
vis_used:
Successful derivation!
VocabularyItem:
    pronunciation: li
    label: definite
    values: {'+definite', '-atomic'}
    diacritic: li_1
    triggers: set()
    weight: 10.0
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_6
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 11.100000000000001
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 10.6
line done
line done

---------------------

input line #11
input roots: [<__main__.Root object at 0x10fc1c940>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: set()
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 12.399999999999995..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 11.199999999999998..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 10.2..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 12.499999999999995..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 10.299999999999999..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 10.299999999999999..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 12.599999999999994..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}

create_vi: made nominalizer: null_14, triggers = set(), weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}

create_vi: made nominalizer: null_15, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}

create_vi: made OFFSPRING: OFFSPRING_1, triggers = set(), weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'OFFSPRING_1', 'i_1', 'null_15'}

create_vi: made OFFSPRING: OFFSPRING_2, triggers = {('null', frozenset()), ('i', frozenset({'-atomic'}))}, weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_15', 'OFFSPRING_2', 'i_1', 'null_14', 'OFFSPRING_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc28b00>, '-', <__main__.AgrTerminal object at 0x10fc28320>, '#', <__main__.Root object at 0x10fc28e80>, '-', <__main__.NominalizerTerminal object at 0x10fc28da0>, '-', <__main__.SemanticTerminal object at 0x10fc28c50>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i_2'}
we picked null_14: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: li#OFFSPRING-i
full_pronunciation: li#OFFSPRINGi
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: OFFSPRING to the selectional of the nominalizer whose values are {'i_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2'}
    selectional: {'OFFSPRING'}
    selection_strength: True
    weight: 10.0
    linear: (<__main__.NominalizerTerminal object at 0x10fc0ecc0>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 12.599999999999994
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 10.299999999999999
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_1
    triggers: set()
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 10.0
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 11.2
line done
line done

---------------------

input line #12
input roots: [<__main__.Root object at 0x10fc287b8>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 13.199999999999994..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 11.299999999999997..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 10.999999999999998..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 13.299999999999994..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 10.399999999999999..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 11.099999999999998..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 13.399999999999993..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: MILKCOW in its selectional

now working with the word 'MILKCOW-e', mapping to 3 terminals:

create_vi: made atomic: e_2, triggers = set(), weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}

create_vi: made nominalizer: null_16, triggers = set(), weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16'}

create_vi: made nominalizer: null_17, triggers = {('e', frozenset({'-atomic'}))}, weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'null_17'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'MILKCOW_1', 'null_17'}

create_vi: made MILKCOW: MILKCOW_3, triggers = {('null', frozenset()), ('e', frozenset({'-atomic'}))}, weight = 10.0
     what if we combine triggers with the otherwise identical vi MILKCOW_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?

create_vi: made MILKCOW: MILKCOW_4, triggers = {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}, weight = 10.0
     -> created a new vi MILKCOW_4 	spelling out MILKCOW: set() 		 triggering {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'MILKCOW_3', 'MILKCOW_1', 'null_17'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc235f8>, '-', <__main__.AgrTerminal object at 0x10fc2add8>, '#', <__main__.Root object at 0x10fc23978>, '-', <__main__.NominalizerTerminal object at 0x10fc23898>, '-', <__main__.SemanticTerminal object at 0x10fc23748>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'o_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MILKCOW terminal with values set()
we picked MILKCOW_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i_2', 'o_2'}
we picked null_13: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: le#MILKCOW-e
full_pronunciation: li#MILKCOWi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 13.399999999999993
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 10.799999999999999
VocabularyItem:
    pronunciation: MILKCOW
    label: MILKCOW
    values: set()
    diacritic: MILKCOW_1
    triggers: set()
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2', 'o_2'}
    diacritic: null_13
    triggers: {('i', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 11.7
line done
line done

---------------------

input line #13
input roots: [<__main__.Root object at 0x10fc23828>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: set()
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 11.399999999999997..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 13.399999999999993..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 10.599999999999998..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 10.699999999999998..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}

create_vi: made PIBLING: PIBLING_1, triggers = set(), weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_11', 'null_10', 'a_1'}

create_vi: made PIBLING: PIBLING_2, triggers = {('null', frozenset()), ('a', frozenset({'+atomic'}))}, weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_2', 'a_1', 'PIBLING_1', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc1b978>, '#', <__main__.Root object at 0x10fc1bcf8>, '-', <__main__.NominalizerTerminal object at 0x10fc1bc18>, '-', <__main__.SemanticTerminal object at 0x10fc1bac8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite', 'i_2', '+atomic'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out PIBLING terminal with values set()
we picked PIBLING_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'a'}
we picked null_14 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: una#PIBLING-a
full_pronunciation: un#PIBLINGa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 10.699999999999998
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_2
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 10.5
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 11.1
line done
line done

---------------------

input line #14
input roots: [<__main__.Root object at 0x10fc1b710>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 13.499999999999993..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 11.499999999999996..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 11.199999999999998..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 13.599999999999993..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 10.499999999999998..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 11.299999999999997..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 13.699999999999992..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'null_17'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'e_2', 'null_16', 'null_17'}

create_vi: made PIBLING: PIBLING_3, triggers = {('null', frozenset()), ('e', frozenset({'-atomic'}))}, weight = 10.0
     what if we combine triggers with the otherwise identical vi PIBLING_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?

create_vi: made PIBLING: PIBLING_4, triggers = {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}, weight = 10.0
     -> created a new vi PIBLING_4 	spelling out PIBLING: set() 		 triggering {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'PIBLING_1', 'null_17', 'PIBLING_3'}
done processing input, time to test
we selected the nominalizer with values: {'e_1'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc2d080>, '-', <__main__.AgrTerminal object at 0x10fc2db00>, '#', <__main__.Root object at 0x10fc23ef0>, '-', <__main__.NominalizerTerminal object at 0x10fc1b3c8>, '-', <__main__.SemanticTerminal object at 0x10fc1bac8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'e_1', 'null'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: le#PIBLING-e
full_pronunciation: le#PIBLINGe
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: PIBLING to the selectional of the nominalizer whose values are {'e_1'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1'}
    selectional: {'KEY'}
    selection_strength: True
    weight: 10.2
    linear: (<__main__.NominalizerTerminal object at 0x10fbeb2e8>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 13.699999999999992
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 11.299999999999997
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_3
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 10.0
     what if we combine triggers with the otherwise identical vi PIBLING_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 11.600000000000001
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 10.1
line done
line done

---------------------

input line #15
input roots: [<__main__.Root object at 0x10fc2d978>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 14.299999999999992..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 11.899999999999997..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 10.599999999999998..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 14.399999999999991..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 10.699999999999998..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 10.699999999999998..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 14.499999999999991..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 14.59999999999999..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 10.799999999999999..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 10.799999999999997..already existed
  we're in a functional word...
  - nominalizer's values are now {'i_2', 'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_12'}

create_vi: made nominalizer: null_18, triggers = {('o', frozenset({'+atomic'}))}, weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_18', 'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_18', 'o_1', 'null_12'}

create_vi: made OFFSPRING: OFFSPRING_3, triggers = {('o', frozenset({'+atomic'})), ('null', frozenset())}, weight = 10.0
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?

create_vi: made OFFSPRING: OFFSPRING_4, triggers = {('o', frozenset({'+atomic'})), ('null', frozenset()), ('i', frozenset({'-atomic'}))}, weight = 10.0
     -> created a new vi OFFSPRING_4 	spelling out OFFSPRING: set() 		 triggering {('o', frozenset({'+atomic'})), ('null', frozenset()), ('i', frozenset({'-atomic'}))}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'OFFSPRING_3', 'o_1', 'null_18', 'OFFSPRING_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc2f550>, '#', <__main__.Root object at 0x10fc2f8d0>, '-', <__main__.NominalizerTerminal object at 0x10fc2f7f0>, '-', <__main__.SemanticTerminal object at 0x10fc2f6a0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '+atomic', 'i_2'}
we picked lo_1: no super match (neither decl nor L1-gender)
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i_2'}
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: lo#OFFSPRING-o
full_pronunciation: lo#OFFSPRINGa
vis_used:
Failure
VocabularyItem:
    pronunciation: lo
    label: definite
    values: {'+definite', '+atomic'}
    diacritic: lo_1
    triggers: set()
    weight: 9.9
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_1
    triggers: set()
    weight: 10.5
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 12.100000000000001
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 11.0
line done
line done

---------------------

input line #16
input roots: [<__main__.Root object at 0x10fc2fa90>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: set()
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 14.69999999999999..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 11.599999999999996..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 10.899999999999999..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 14.79999999999999..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 10.899999999999997..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 10.999999999999998..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 14.89999999999999..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: CLOWN in its selectional

now working with the word 'CLOWN-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}

create_vi: made CLOWN: CLOWN_1, triggers = set(), weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'CLOWN_1', 'i_1', 'null_15'}

create_vi: made CLOWN: CLOWN_2, triggers = {('null', frozenset()), ('i', frozenset({'-atomic'}))}, weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CLOWN_2', 'null_15', 'i_1', 'null_14', 'CLOWN_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc26908>, '#', <__main__.Root object at 0x10fc26cc0>, '-', <__main__.NominalizerTerminal object at 0x10fc26ba8>, '-', <__main__.SemanticTerminal object at 0x10fc26a58>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out CLOWN terminal with values set()
we picked CLOWN_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o_2'}
we picked null_9: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: li#CLOWN-i
full_pronunciation: l#CLOWNi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 14.89999999999999
VocabularyItem:
    pronunciation: CLOWN
    label: CLOWN
    values: set()
    diacritic: CLOWN_1
    triggers: set()
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_9
    triggers: {('o', frozenset({'+atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 11.7
line done
line done

---------------------

input line #17
input roots: [<__main__.Root object at 0x10fc266a0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 14.89999999999999..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 11.999999999999996..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 10.999999999999996..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 14.99999999999999..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 11.099999999999996..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 10.799999999999997..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 15.099999999999989..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 15.199999999999989..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 11.099999999999998..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 11.199999999999996..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_8', 'o_1', 'null_9'}

create_vi: made PIBLING: PIBLING_5, triggers = {('o', frozenset({'+atomic'})), ('null', frozenset())}, weight = 10.0
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?

create_vi: made PIBLING: PIBLING_6, triggers = {('o', frozenset({'+atomic'})), ('null', frozenset()), ('e', frozenset({'-atomic'}))}, weight = 10.0
     -> created a new vi PIBLING_6 	spelling out PIBLING: set() 		 triggering {('o', frozenset({'+atomic'})), ('null', frozenset()), ('e', frozenset({'-atomic'}))}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'PIBLING_1', 'o_1', 'PIBLING_5'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc31278>, '-', <__main__.AgrTerminal object at 0x10fc32a58>, '#', <__main__.Root object at 0x10fc31630>, '-', <__main__.NominalizerTerminal object at 0x10fc31518>, '-', <__main__.SemanticTerminal object at 0x10fc313c8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o_2'}
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: lo#PIBLING-o
full_pronunciation: lo#PIBLINGo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: PIBLING to the selectional of the nominalizer whose values are {'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'o_2'}
    selectional: {'PIBLING', 'MOUSE', 'CASTLE', 'GRANDPARENT'}
    selection_strength: True
    weight: 11.299999999999995
    linear: (<__main__.NominalizerTerminal object at 0x10fc08908>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 15.199999999999989
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 11.199999999999996
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_1
    triggers: set()
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 12.000000000000002
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 10.2
line done
line done

---------------------

input line #18
input roots: [<__main__.Root object at 0x10fc31358>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 15.799999999999988..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 12.099999999999996..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 11.799999999999995..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 15.899999999999988..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 11.899999999999995..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 10.899999999999997..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 15.999999999999988..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 16.099999999999987..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 11.199999999999998..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 11.999999999999995..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CASTLE in its selectional

now working with the word 'CASTLE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CASTLE_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'CASTLE_2', 'o_1', 'CASTLE_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc35588>, '#', <__main__.Root object at 0x10fc35908>, '-', <__main__.NominalizerTerminal object at 0x10fc35828>, '-', <__main__.SemanticTerminal object at 0x10fc356d8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', 'e_1', '+atomic'}
we picked lo_1: no super match (neither decl nor L1-gender)
now spelling out CASTLE terminal with values set()
we picked CASTLE_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1'}
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: lo#CASTLE-o
full_pronunciation: lo#CASTLEo
vis_used:
Successful derivation!
VocabularyItem:
    pronunciation: lo
    label: definite
    values: {'+definite', '+atomic'}
    diacritic: lo_1
    triggers: set()
    weight: 9.8
VocabularyItem:
    pronunciation: CASTLE
    label: CASTLE
    values: set()
    diacritic: CASTLE_1
    triggers: set()
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 12.500000000000002
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 10.799999999999999
line done
line done

---------------------

input line #19
input roots: [<__main__.Root object at 0x10fc35a90>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 11.699999999999996..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 16.19999999999999..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 10.999999999999996..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 11.099999999999996..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_2', 'a_1', 'PIBLING_1', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc32a58>, '-', <__main__.AgrTerminal object at 0x10fc31278>, '#', <__main__.Root object at 0x10fc26e48>, '-', <__main__.NominalizerTerminal object at 0x10fc32240>, '-', <__main__.SemanticTerminal object at 0x10fc328d0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2', 'a'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: una#PIBLING-a
full_pronunciation: una#PIBLINGa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: PIBLING to the selectional of the nominalizer whose values are {'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'a_2'}
    selectional: {'FROG', 'CHILD', 'PIBLING', 'GRANDPARENT', 'MILKCOW'}
    selection_strength: True
    weight: 11.699999999999994
    linear: (<__main__.NominalizerTerminal object at 0x10fc05f28>,)
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 11.099999999999996
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 11.699999999999996
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 10.0
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 11.0
line done
line done

---------------------

input line #20
input roots: [<__main__.Root object at 0x10fc313c8>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 12.099999999999994..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 16.29999999999999..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 11.699999999999996..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 11.799999999999995..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1', 'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_18', 'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_18', 'o_1', 'null_12'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'OFFSPRING_3', 'o_1', 'null_18', 'OFFSPRING_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc38240>, '-', <__main__.AgrTerminal object at 0x10fc369e8>, '#', <__main__.Root object at 0x10fc385c0>, '-', <__main__.NominalizerTerminal object at 0x10fc384e0>, '-', <__main__.SemanticTerminal object at 0x10fc38390>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1', 'a_2'}
we picked null_11: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: uno#OFFSPRING-o
full_pronunciation: una#OFFSPRINGa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 11.799999999999995
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 12.199999999999996
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_1
    triggers: set()
    weight: 10.4
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_11
    triggers: {('a', frozenset({'+atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 11.5
line done
line done

---------------------

input line #21
input roots: [<__main__.Root object at 0x10fc381d0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: set()
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 12.199999999999994..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 16.39999999999999..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 11.799999999999995..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 11.899999999999995..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FOOT in its selectional

now working with the word 'FOOT-e', mapping to 3 terminals:

create_vi: made atomic: e_3, triggers = set(), weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}

create_vi: made nominalizer: null_19, triggers = {('e', frozenset({'+atomic'}))}, weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}

create_vi: made FOOT: FOOT_1, triggers = set(), weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FOOT_1', 'null_8', 'e_3', 'null_19'}

create_vi: made FOOT: FOOT_2, triggers = {('null', frozenset()), ('e', frozenset({'+atomic'}))}, weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FOOT_1', 'e_3', 'FOOT_2', 'null_19'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc3bcf8>, '-', <__main__.AgrTerminal object at 0x10fc3b518>, '#', <__main__.Root object at 0x10fc3c0b8>, '-', <__main__.NominalizerTerminal object at 0x10fc3bf98>, '-', <__main__.SemanticTerminal object at 0x10fc3be48>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FOOT terminal with values set()
we picked FOOT_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: uno#FOOT-e
full_pronunciation: uno#FOOTe
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: FOOT to the selectional of the nominalizer whose values are {'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'o_2'}
    selectional: {'MOUSE', 'PIBLING', 'CASTLE', 'GRANDPARENT', 'FOOT'}
    selection_strength: True
    weight: 12.099999999999993
    linear: (<__main__.NominalizerTerminal object at 0x10fc08908>,)
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 11.899999999999995
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 12.199999999999994
VocabularyItem:
    pronunciation: FOOT
    label: FOOT
    values: set()
    diacritic: FOOT_2
    triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 13.000000000000002
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 10.0
line done
line done

---------------------

input line #22
input roots: [<__main__.Root object at 0x10fc3b9b0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 12.199999999999996..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 16.499999999999993..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 12.499999999999995..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 12.599999999999994..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: MILKCOW in its selectional

now working with the word 'MILKCOW-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'MILKCOW_1'}
     what if we combine triggers with the otherwise identical vi MILKCOW_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'MILKCOW_1', 'MILKCOW_2', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc3e5f8>, '-', <__main__.AgrTerminal object at 0x10fc3cdd8>, '#', <__main__.Root object at 0x10fc3e978>, '-', <__main__.NominalizerTerminal object at 0x10fc3e898>, '-', <__main__.SemanticTerminal object at 0x10fc3e748>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MILKCOW terminal with values set()
we picked MILKCOW_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'a_2', 'a'}
we picked null_16 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: una#MILKCOW-a
full_pronunciation: una#MILKCOWa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: MILKCOW to the selectional of the nominalizer whose values are {'e_1', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1', 'a_2'}
    selectional: {'PIBLING', 'MILKCOW'}
    selection_strength: True
    weight: 10.0
    linear: (<__main__.NominalizerTerminal object at 0x10fc2aa20>,)
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 12.599999999999994
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 12.199999999999996
VocabularyItem:
    pronunciation: MILKCOW
    label: MILKCOW
    values: set()
    diacritic: MILKCOW_2
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 10.0
     what if we combine triggers with the otherwise identical vi MILKCOW_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1', 'a_2'}
    diacritic: null_16
    triggers: set()
    weight: 10.0
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 11.5
line done
line done

---------------------

input line #23
input roots: [<__main__.Root object at 0x10fc3e2b0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: set()
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 16.599999999999994..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 12.799999999999995..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 11.299999999999997..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 16.699999999999996..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 12.799999999999994..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 11.399999999999997..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 16.799999999999997..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: FLOWER in its selectional

now working with the word 'FLOWER-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}

create_vi: made FLOWER: FLOWER_1, triggers = set(), weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'FLOWER_1', 'i_1', 'null_15'}

create_vi: made FLOWER: FLOWER_2, triggers = {('null', frozenset()), ('i', frozenset({'-atomic'}))}, weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_15', 'FLOWER_2', 'i_1', 'null_14', 'FLOWER_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc41eb8>, '-', <__main__.AgrTerminal object at 0x10fc416d8>, '#', <__main__.Root object at 0x10fc3cf28>, '-', <__main__.NominalizerTerminal object at 0x10fc3e320>, '-', <__main__.SemanticTerminal object at 0x10fc3eb00>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'o_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FLOWER terminal with values set()
we picked FLOWER_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i_2', 'o_2'}
we picked null_9: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: li#FLOWER-i
full_pronunciation: li#FLOWERe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 16.799999999999997
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 11.399999999999997
VocabularyItem:
    pronunciation: FLOWER
    label: FLOWER
    values: set()
    diacritic: FLOWER_1
    triggers: set()
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_9
    triggers: {('o', frozenset({'+atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 10.6
line done
line done

---------------------

input line #24
input roots: [<__main__.Root object at 0x10fc3c550>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 12.899999999999993..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 16.799999999999997..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 13.199999999999994..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 13.299999999999994..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CHILD_1', 'null_9'}

create_vi: made CHILD: CHILD_3, triggers = {('o', frozenset({'+atomic'})), ('null', frozenset())}, weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'CHILD_1', 'null_9', 'o_1', 'CHILD_3'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc42400>, '-', <__main__.AgrTerminal object at 0x10fc31e10>, '#', <__main__.Root object at 0x10fc42780>, '-', <__main__.NominalizerTerminal object at 0x10fc426a0>, '-', <__main__.SemanticTerminal object at 0x10fc42550>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1', 'a_2'}
we picked null_10: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: uno#CHILD-o
full_pronunciation: una#CHILDo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 13.299999999999994
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 12.799999999999995
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_1
    triggers: set()
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 10.5
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 11.499999999999998
line done
line done

---------------------

input line #25
input roots: [<__main__.Root object at 0x10fc42390>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 16.9..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 12.199999999999996..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 12.999999999999993..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 17.0..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 13.099999999999993..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 13.299999999999994..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 17.1..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 17.200000000000003..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 11.399999999999997..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 13.199999999999992..already existed
  we're in a functional word...
  - nominalizer's values are now {'e_1', 'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'o_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}

create_vi: made nominalizer: null_20, triggers = set(), weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_20'}

create_vi: made nominalizer: null_21, triggers = {('o', frozenset({'+atomic'}))}, weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_20', 'null_21'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'o_1', 'null_20', 'null_21'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_20', 'PIBLING_1', 'o_1', 'null_21', 'PIBLING_5'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc3dda0>, '-', <__main__.AgrTerminal object at 0x10fc3d5c0>, '#', <__main__.Root object at 0x10fc45160>, '-', <__main__.NominalizerTerminal object at 0x10fc45080>, '-', <__main__.SemanticTerminal object at 0x10fc3def0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2', 'a'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: lo#PIBLING-o
full_pronunciation: la#PIBLINGa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 17.200000000000003
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 12.699999999999996
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.5
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 10.4
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 12.0
line done
line done

---------------------

input line #26
input roots: [<__main__.Root object at 0x10fc3d470>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 17.200000000000003..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 12.299999999999995..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 13.299999999999992..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 17.300000000000004..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 13.399999999999991..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 13.399999999999993..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 17.400000000000006..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 17.500000000000007..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 11.499999999999996..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 13.499999999999991..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'PIBLING_1', 'o_1', 'PIBLING_5'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc43630>, '-', <__main__.AgrTerminal object at 0x10fc45e10>, '#', <__main__.Root object at 0x10fc439b0>, '-', <__main__.NominalizerTerminal object at 0x10fc438d0>, '-', <__main__.SemanticTerminal object at 0x10fc43780>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'a_2', 'a'}
we picked null_16 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: lo#PIBLING-o
full_pronunciation: la#PIBLINGa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 17.500000000000007
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 12.599999999999996
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.4
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1', 'a_2'}
    diacritic: null_16
    triggers: set()
    weight: 10.5
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 11.9
line done
line done

---------------------

input line #27
input roots: [<__main__.Root object at 0x10fc43860>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 17.500000000000007..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 12.599999999999996..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 11.599999999999996..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 17.60000000000001..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 13.59999999999999..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 11.699999999999996..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 17.70000000000001..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: MOUSE in its selectional

now working with the word 'MOUSE-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'MOUSE_1', 'null_12', 'null_13', 'i_1'}

create_vi: made MOUSE: MOUSE_3, triggers = {('null', frozenset()), ('i', frozenset({'-atomic'}))}, weight = 10.0
     what if we combine triggers with the otherwise identical vi MOUSE_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?

create_vi: made MOUSE: MOUSE_4, triggers = {('null', frozenset()), ('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}, weight = 10.0
     -> created a new vi MOUSE_4 	spelling out MOUSE: set() 		 triggering {('null', frozenset()), ('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'MOUSE_3', 'null_12', 'null_13', 'i_1', 'MOUSE_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc47fd0>, '-', <__main__.AgrTerminal object at 0x10fc477f0>, '#', <__main__.Root object at 0x10fc4b320>, '-', <__main__.NominalizerTerminal object at 0x10fc4b278>, '-', <__main__.SemanticTerminal object at 0x10fc4b160>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MOUSE terminal with values set()
we picked MOUSE_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'i_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#MOUSE-i
full_pronunciation: li#MOUSEi
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: MOUSE to the selectional of the nominalizer whose values are {'i_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2'}
    selectional: {'FLOWER', 'CLOWN', 'OFFSPRING'}
    selection_strength: True
    weight: 10.2
    linear: (<__main__.NominalizerTerminal object at 0x10fc0ecc0>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 17.70000000000001
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 11.699999999999996
VocabularyItem:
    pronunciation: MOUSE
    label: MOUSE
    values: set()
    diacritic: MOUSE_4
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 13.500000000000002
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 11.799999999999999
line done
line done

---------------------

input line #28
input roots: [<__main__.Root object at 0x10fc47a90>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 12.699999999999996..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 18.30000000000001..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 13.499999999999993..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 13.599999999999993..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1', 'e_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: KEY in its selectional

now working with the word 'KEY-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'e_3'}

create_vi: made nominalizer: null_22, triggers = {('e', frozenset({'+atomic'}))}, weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'e_3', 'null_22'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'e_3', 'KEY_1', 'null_22'}

create_vi: made KEY: KEY_3, triggers = {('null', frozenset()), ('e', frozenset({'+atomic'}))}, weight = 10.0
     what if we combine triggers with the otherwise identical vi KEY_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?

create_vi: made KEY: KEY_4, triggers = {('null', frozenset()), ('i', frozenset({'-atomic'})), ('e', frozenset({'+atomic'}))}, weight = 10.0
     -> created a new vi KEY_4 	spelling out KEY: set() 		 triggering {('null', frozenset()), ('i', frozenset({'-atomic'})), ('e', frozenset({'+atomic'}))}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'KEY_3', 'KEY_1', 'null_16', 'null_22', 'e_3'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc47ba8>, '#', <__main__.Root object at 0x10fc43630>, '-', <__main__.NominalizerTerminal object at 0x10fc43780>, '-', <__main__.SemanticTerminal object at 0x10fc439b0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite', '+atomic'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out KEY terminal with values set()
we picked KEY_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: una#KEY-e
full_pronunciation: un#KEYa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 13.599999999999993
VocabularyItem:
    pronunciation: KEY
    label: KEY
    values: set()
    diacritic: KEY_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 14.000000000000002
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 11.8
line done
line done

---------------------

input line #29
input roots: [<__main__.Root object at 0x10fc43198>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 18.400000000000013..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 12.399999999999995..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 12.799999999999995..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 18.500000000000014..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 12.899999999999995..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 13.599999999999993..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 18.600000000000016..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 18.700000000000017..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 12.299999999999995..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 12.999999999999995..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: MILKCOW in its selectional

now working with the word 'MILKCOW-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'MILKCOW_1'}
     what if we combine triggers with the otherwise identical vi MILKCOW_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'MILKCOW_1', 'MILKCOW_2', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc450f0>, '-', <__main__.AgrTerminal object at 0x10fc477f0>, '#', <__main__.Root object at 0x10fc3dba8>, '-', <__main__.NominalizerTerminal object at 0x10fc3de10>, '-', <__main__.SemanticTerminal object at 0x10fc3d470>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MILKCOW terminal with values set()
we picked MILKCOW_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'o_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#MILKCOW-a
full_pronunciation: lo#MILKCOWa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 18.700000000000017
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 13.59999999999999
VocabularyItem:
    pronunciation: MILKCOW
    label: MILKCOW
    values: set()
    diacritic: MILKCOW_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 13.900000000000002
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 11.8
line done
line done

---------------------

input line #30
input roots: [<__main__.Root object at 0x10fc45438>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 13.59999999999999..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 18.700000000000017..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 13.699999999999992..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 13.799999999999992..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1', 'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: FLOWER in its selectional

now working with the word 'FLOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'null_12'}

create_vi: made nominalizer: null_23, triggers = {('e', frozenset({'+atomic'}))}, weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'null_23', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'FLOWER_1', 'null_23', 'null_12'}

create_vi: made FLOWER: FLOWER_3, triggers = {('null', frozenset()), ('e', frozenset({'+atomic'}))}, weight = 10.0
     what if we combine triggers with the otherwise identical vi FLOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?

create_vi: made FLOWER: FLOWER_4, triggers = {('null', frozenset()), ('i', frozenset({'-atomic'})), ('e', frozenset({'+atomic'}))}, weight = 10.0
     -> created a new vi FLOWER_4 	spelling out FLOWER: set() 		 triggering {('null', frozenset()), ('i', frozenset({'-atomic'})), ('e', frozenset({'+atomic'}))}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_23', 'FLOWER_3', 'e_3', 'FLOWER_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc42710>, '-', <__main__.AgrTerminal object at 0x10fc45710>, '#', <__main__.Root object at 0x10fc412b0>, '-', <__main__.NominalizerTerminal object at 0x10fc41f98>, '-', <__main__.SemanticTerminal object at 0x10fc42240>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FLOWER terminal with values set()
we picked FLOWER_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e', 'e_1', 'a_2'}
we picked null_6 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: uno#FLOWER-e
full_pronunciation: una#FLOWERe
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 13.799999999999992
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 12.999999999999995
VocabularyItem:
    pronunciation: FLOWER
    label: FLOWER
    values: set()
    diacritic: FLOWER_3
    triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_6
    triggers: set()
    weight: 10.0
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 10.7
line done
line done

---------------------

input line #31
input roots: [<__main__.Root object at 0x10fc41748>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 18.80000000000002..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 12.499999999999995..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 12.999999999999995..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 18.90000000000002..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 13.099999999999994..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 13.799999999999992..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 19.00000000000002..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 19.100000000000023..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 12.399999999999995..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 13.199999999999994..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1', 'i_2'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'a_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}

create_vi: made nominalizer: null_24, triggers = set(), weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_24', 'a_1'}

create_vi: made nominalizer: null_25, triggers = {('a', frozenset({'+atomic'}))}, weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_25', 'null_24', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_25', 'null_24', 'a_1'}

create_vi: made OFFSPRING: OFFSPRING_5, triggers = {('null', frozenset()), ('a', frozenset({'+atomic'}))}, weight = 10.0
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?

create_vi: made OFFSPRING: OFFSPRING_6, triggers = {('null', frozenset()), ('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}, weight = 10.0
     -> created a new vi OFFSPRING_6 	spelling out OFFSPRING: set() 		 triggering {('null', frozenset()), ('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'null_25', 'null_24', 'OFFSPRING_1', 'OFFSPRING_5'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b550>, '-', <__main__.AgrTerminal object at 0x10fc3bf98>, '#', <__main__.Root object at 0x10fc4b2b0>, '-', <__main__.NominalizerTerminal object at 0x10fc4b240>, '-', <__main__.SemanticTerminal object at 0x10fc4b208>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'i_2', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_5: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a', 'i_2', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#OFFSPRING-a
full_pronunciation: la#OFFSPRINGa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: OFFSPRING to the selectional of the nominalizer whose values are {'i_2', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'a_2'}
    selectional: {'OFFSPRING'}
    selection_strength: True
    weight: 10.0
    linear: (<__main__.NominalizerTerminal object at 0x10fc36a90>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 19.100000000000023
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 13.199999999999994
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_5
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 10.0
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 10.3
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 11.8
line done
line done

---------------------

input line #32
input roots: [<__main__.Root object at 0x10fc425c0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 19.700000000000024..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 13.799999999999994..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 12.599999999999994..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 19.800000000000026..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 13.69999999999999..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 12.699999999999994..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 19.900000000000027..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_6'}

create_vi: made nominalizer: null_26, triggers = {('e', frozenset({'-atomic'}))}, weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'PIBLING_1', 'null_6'}
     what if we combine triggers with the otherwise identical vi PIBLING_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_5 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'PIBLING_3', 'PIBLING_1', 'null_26', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b8d0>, '#', <__main__.Root object at 0x10fc4be10>, '-', <__main__.NominalizerTerminal object at 0x10fc4bda0>, '-', <__main__.SemanticTerminal object at 0x10fc4bcc0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out PIBLING terminal with values set()
we picked PIBLING_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o_2'}
we picked null_8: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: le#PIBLING-e
full_pronunciation: l#PIBLINGi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 19.900000000000027
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_1
    triggers: set()
    weight: 10.5
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 10.0
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 12.299999999999999
line done
line done

---------------------

input line #33
input roots: [<__main__.Root object at 0x10fc4bd30>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 13.79999999999999..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 19.900000000000027..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 13.899999999999991..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 13.999999999999991..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'GRANDPARENT_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'GRANDPARENT_1', 'GRANDPARENT_2'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50198>, '#', <__main__.Root object at 0x10fc506d8>, '-', <__main__.NominalizerTerminal object at 0x10fc50668>, '-', <__main__.SemanticTerminal object at 0x10fc50588>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite', 'i_2', '+atomic'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_6: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'a'}
we picked null_14 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: uno#GRANDPARENT-o
full_pronunciation: un#GRANDPARENTa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 13.999999999999991
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_6
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 10.5
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 10.4
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 12.3
line done
line done

---------------------

input line #34
input roots: [<__main__.Root object at 0x10fc505f8>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 20.00000000000003..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 13.899999999999993..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 12.799999999999994..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 20.10000000000003..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 13.89999999999999..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 12.899999999999993..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 20.20000000000003..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: MILKCOW in its selectional

now working with the word 'MILKCOW-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'null_17'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'MILKCOW_1', 'null_17'}
     what if we combine triggers with the otherwise identical vi MILKCOW_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'MILKCOW_3', 'MILKCOW_1', 'null_17'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50160>, '#', <__main__.Root object at 0x10fc50f28>, '-', <__main__.NominalizerTerminal object at 0x10fc50eb8>, '-', <__main__.SemanticTerminal object at 0x10fc50dd8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out MILKCOW terminal with values set()
we picked MILKCOW_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values set()
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: le#MILKCOW-e
full_pronunciation: l#MILKCOWe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 20.20000000000003
VocabularyItem:
    pronunciation: MILKCOW
    label: MILKCOW
    values: set()
    diacritic: MILKCOW_1
    triggers: set()
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 13.800000000000002
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 10.7
line done
line done

---------------------

input line #35
input roots: [<__main__.Root object at 0x10fc50c18>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: set()
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 20.20000000000003..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 13.999999999999993..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 12.999999999999993..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 20.300000000000033..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 13.99999999999999..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 13.099999999999993..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 20.400000000000034..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: FROG in its selectional

now working with the word 'FROG-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6', 'FROG_1'}

create_vi: made FROG: FROG_3, triggers = {('null', frozenset()), ('e', frozenset({'-atomic'}))}, weight = 10.0
     what if we combine triggers with the otherwise identical vi FROG_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?

create_vi: made FROG: FROG_4, triggers = {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}, weight = 10.0
     -> created a new vi FROG_4 	spelling out FROG: set() 		 triggering {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'FROG_1', 'null_26', 'FROG_3', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc507b8>, '#', <__main__.Root object at 0x10fc50668>, '-', <__main__.NominalizerTerminal object at 0x10fc506d8>, '-', <__main__.SemanticTerminal object at 0x10fc50860>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out FROG terminal with values set()
we picked FROG_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'a_2'}
we picked null_10: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: le#FROG-e
full_pronunciation: l#FROGi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 20.400000000000034
VocabularyItem:
    pronunciation: FROG
    label: FROG
    values: set()
    diacritic: FROG_1
    triggers: set()
    weight: 10.5
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 10.8
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 12.2
line done
line done

---------------------

input line #36
input roots: [<__main__.Root object at 0x10fc508d0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 14.099999999999989..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 20.400000000000034..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 13.999999999999991..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 14.09999999999999..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1', 'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: MOUSE in its selectional

now working with the word 'MOUSE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_18', 'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'MOUSE_1', 'null_18', 'o_1', 'null_12'}
     what if we combine triggers with the otherwise identical vi MOUSE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'o_1', 'MOUSE_2', 'MOUSE_1', 'null_18'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc38470>, '-', <__main__.AgrTerminal object at 0x10fc50470>, '#', <__main__.Root object at 0x10fc412b0>, '-', <__main__.NominalizerTerminal object at 0x10fc41e48>, '-', <__main__.SemanticTerminal object at 0x10fc31e10>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MOUSE terminal with values set()
we picked MOUSE_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i_2', 'a_2'}
we picked null_10: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: uno#MOUSE-o
full_pronunciation: una#MOUSEo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 14.09999999999999
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 13.999999999999993
VocabularyItem:
    pronunciation: MOUSE
    label: MOUSE
    values: set()
    diacritic: MOUSE_1
    triggers: set()
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 10.700000000000001
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 11.799999999999997
line done
line done

---------------------

input line #37
input roots: [<__main__.Root object at 0x10fc36240>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 14.199999999999989..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 20.500000000000036..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 14.09999999999999..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 14.19999999999999..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: MOUSE in its selectional

now working with the word 'MOUSE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'MOUSE_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi MOUSE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'MOUSE_2', 'MOUSE_1'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc42240>, '#', <__main__.Root object at 0x10fc3dbe0>, '-', <__main__.NominalizerTerminal object at 0x10fc3d518>, '-', <__main__.SemanticTerminal object at 0x10fc42dd8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite', '+atomic'}
we picked una_1: no super match (neither decl nor L1-gender)
now spelling out MOUSE terminal with values set()
we picked MOUSE_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: uno#MOUSE-o
full_pronunciation: una#MOUSEo
vis_used:
Failure
VocabularyItem:
    pronunciation: una
    label: definite
    values: {'-definite', '+atomic'}
    diacritic: una_1
    triggers: set()
    weight: 10.0
VocabularyItem:
    pronunciation: MOUSE
    label: MOUSE
    values: set()
    diacritic: MOUSE_4
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 10.5
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 13.700000000000003
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 11.799999999999997
line done
line done

---------------------

input line #38
input roots: [<__main__.Root object at 0x10fc38908>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: set()
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 13.999999999999993..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 20.600000000000037..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 14.29999999999999..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 14.39999999999999..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: BALL in its selectional

now working with the word 'BALL-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}

create_vi: made BALL: BALL_1, triggers = set(), weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'BALL_1', 'a_1'}

create_vi: made BALL: BALL_2, triggers = {('null', frozenset()), ('a', frozenset({'+atomic'}))}, weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'BALL_1', 'BALL_2', 'null_10', 'null_11'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc45ba8>, '-', <__main__.AgrTerminal object at 0x10fc50128>, '#', <__main__.Root object at 0x10fc4bf98>, '-', <__main__.NominalizerTerminal object at 0x10fc45588>, '-', <__main__.SemanticTerminal object at 0x10fc45ef0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BALL terminal with values set()
we picked BALL_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'o_2', 'a'}
we picked null_6 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: una#BALL-a
full_pronunciation: uno#BALLa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 14.39999999999999
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 14.199999999999989
VocabularyItem:
    pronunciation: BALL
    label: BALL
    values: set()
    diacritic: BALL_2
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_6
    triggers: set()
    weight: 9.9
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 12.3
line done
line done

---------------------

input line #39
input roots: [<__main__.Root object at 0x10fc45400>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 14.199999999999989..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 20.70000000000004..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 14.39999999999999..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 14.49999999999999..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1', 'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: FLOWER in its selectional

now working with the word 'FLOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'null_23', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'FLOWER_1', 'null_23', 'null_12'}
     what if we combine triggers with the otherwise identical vi FLOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_23', 'FLOWER_3', 'e_3', 'FLOWER_1'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b160>, '#', <__main__.Root object at 0x10fc4b940>, '-', <__main__.NominalizerTerminal object at 0x10fc4ba20>, '-', <__main__.SemanticTerminal object at 0x10fc4ba90>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite', '+atomic'}
we picked una_1: no super match (neither decl nor L1-gender)
now spelling out FLOWER terminal with values set()
we picked FLOWER_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values set()
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: uno#FLOWER-e
full_pronunciation: una#FLOWERe
vis_used:
Failure
VocabularyItem:
    pronunciation: una
    label: definite
    values: {'-definite', '+atomic'}
    diacritic: una_1
    triggers: set()
    weight: 9.9
VocabularyItem:
    pronunciation: FLOWER
    label: FLOWER
    values: set()
    diacritic: FLOWER_1
    triggers: set()
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 13.600000000000003
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 10.7
line done
line done

---------------------

input line #40
input roots: [<__main__.Root object at 0x10fc4b9b0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 20.80000000000004..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 13.199999999999992..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 14.299999999999988..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 20.90000000000004..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 14.399999999999988..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 14.599999999999989..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 21.000000000000043..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 21.100000000000044..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 12.499999999999995..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 14.499999999999988..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CHILD_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'CHILD_1', 'null_9', 'o_1', 'CHILD_3'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc439e8>, '-', <__main__.AgrTerminal object at 0x10fc4b828>, '#', <__main__.Root object at 0x10fc47fd0>, '-', <__main__.NominalizerTerminal object at 0x10fc47da0>, '-', <__main__.SemanticTerminal object at 0x10fc43eb8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'i_2', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'i_2', 'a_2'}
we picked null_14 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: lo#CHILD-o
full_pronunciation: la#CHILDo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 21.100000000000044
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 13.999999999999993
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_3
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 10.3
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 11.799999999999997
line done
line done

---------------------

input line #41
input roots: [<__main__.Root object at 0x10fc3dba8>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 21.100000000000044..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 13.999999999999993..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 13.299999999999992..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 21.200000000000045..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 14.599999999999987..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 13.399999999999991..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 21.300000000000047..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: BALL in its selectional

now working with the word 'BALL-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'null_17'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'BALL_1', 'null_17'}

create_vi: made BALL: BALL_3, triggers = {('null', frozenset()), ('e', frozenset({'-atomic'}))}, weight = 10.0
     what if we combine triggers with the otherwise identical vi BALL_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?

create_vi: made BALL: BALL_4, triggers = {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}, weight = 10.0
     -> created a new vi BALL_4 	spelling out BALL: set() 		 triggering {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'BALL_1', 'BALL_3', 'null_17'}
done processing input, time to test
we selected the nominalizer with values: {'e_1'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc588d0>, '-', <__main__.AgrTerminal object at 0x10fc433c8>, '#', <__main__.Root object at 0x10fc58ba8>, '-', <__main__.NominalizerTerminal object at 0x10fc58b00>, '-', <__main__.SemanticTerminal object at 0x10fc58a20>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BALL terminal with values set()
we picked BALL_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'e_1', 'null'}
we picked null_6 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: le#BALL-e
full_pronunciation: le#BALLe
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: BALL to the selectional of the nominalizer whose values are {'e_1'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1'}
    selectional: {'KEY', 'FROG', 'PIBLING'}
    selection_strength: True
    weight: 10.499999999999998
    linear: (<__main__.NominalizerTerminal object at 0x10fbeb2e8>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'a_2'} as values: {'PIBLING', 'FROG', 'BALL'}
..so we'll also combine the vis that spell out {'a_2'}

create_vi: tried nominalizer: null_16, triggers = set(), weight = 10.5..already existed

create_vi: made nominalizer: null_27, triggers = {('a', frozenset({'+atomic'}))}, weight = 10.0
....made the new vi: VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1', 'a_2'}
    diacritic: null_27
    triggers: {('a', frozenset({'+atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 21.300000000000047
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 13.399999999999991
VocabularyItem:
    pronunciation: BALL
    label: BALL
    values: set()
    diacritic: BALL_3
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 10.0
     what if we combine triggers with the otherwise identical vi BALL_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_6
    triggers: set()
    weight: 9.8
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 10.799999999999999
line done
line done

---------------------

input line #42
input roots: [<__main__.Root object at 0x10fc589e8>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 21.90000000000005..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 14.099999999999993..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 12.599999999999994..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 22.00000000000005..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 14.699999999999987..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 12.699999999999994..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 22.10000000000005..already existed
  we're in a functional word...
  - nominalizer's values are now {'a_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'a_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_24', 'i_1'}

create_vi: made nominalizer: null_28, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_24', 'i_1', 'null_28'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_24', 'CHILD_1', 'i_1', 'null_28'}

create_vi: made CHILD: CHILD_4, triggers = {('null', frozenset()), ('i', frozenset({'-atomic'}))}, weight = 10.0
     what if we combine triggers with the otherwise identical vi CHILD_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?

create_vi: made CHILD: CHILD_5, triggers = {('null', frozenset()), ('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}, weight = 10.0
     -> created a new vi CHILD_5 	spelling out CHILD: set() 		 triggering {('null', frozenset()), ('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
     what if we combine triggers with the otherwise identical vi CHILD_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?

create_vi: made CHILD: CHILD_6, triggers = {('null', frozenset()), ('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}, weight = 10.0
     -> created a new vi CHILD_6 	spelling out CHILD: set() 		 triggering {('null', frozenset()), ('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CHILD_1', 'null_28', 'null_24', 'CHILD_4', 'i_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc477f0>, '-', <__main__.AgrTerminal object at 0x10fc58898>, '#', <__main__.Root object at 0x10fc43d68>, '-', <__main__.NominalizerTerminal object at 0x10fc43ba8>, '-', <__main__.SemanticTerminal object at 0x10fc430b8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'a_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: li#CHILD-i
full_pronunciation: li#CHILDe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 22.10000000000005
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 12.699999999999994
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_3
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 13.500000000000004
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 11.299999999999999
line done
line done

---------------------

input line #43
input roots: [<__main__.Root object at 0x10fc58e48>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 14.199999999999992..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 22.10000000000005..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 14.699999999999989..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 14.799999999999988..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: FROG in its selectional

now working with the word 'FROG-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi FROG_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_2', 'a_1', 'FROG_1', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b2b0>, '-', <__main__.AgrTerminal object at 0x10fc47588>, '#', <__main__.Root object at 0x10fc4ba20>, '-', <__main__.NominalizerTerminal object at 0x10fc4b940>, '-', <__main__.SemanticTerminal object at 0x10fc4b668>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FROG terminal with values set()
we picked FROG_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2', 'a'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: una#FROG-a
full_pronunciation: uno#FROGa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 14.799999999999988
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 14.699999999999987
VocabularyItem:
    pronunciation: FROG
    label: FROG
    values: set()
    diacritic: FROG_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 9.9
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 12.3
line done
line done

---------------------

input line #44
input roots: [<__main__.Root object at 0x10fc4b2e8>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 22.200000000000053..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 13.999999999999991..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 14.299999999999992..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 22.300000000000054..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 14.399999999999991..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 14.799999999999988..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 22.400000000000055..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 22.500000000000057..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 12.699999999999994..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 14.499999999999991..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'OFFSPRING_1', 'null_11', 'null_10', 'OFFSPRING_5'}
done processing input, time to test
we selected the nominalizer with values: {'e_1'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4bfd0>, '#', <__main__.Root object at 0x10fc45400>, '-', <__main__.NominalizerTerminal object at 0x10fc45f98>, '-', <__main__.SemanticTerminal object at 0x10fc45f60>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', 'e_1', '+atomic'}
we picked la_1: no super match (neither decl nor L1-gender)
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1', 'null'}
we picked null_6 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: la#OFFSPRING-a
full_pronunciation: la#OFFSPRINGo
vis_used:
Failure
VocabularyItem:
    pronunciation: la
    label: definite
    values: {'+definite', '+atomic'}
    diacritic: la_1
    triggers: set()
    weight: 10.4
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_6
    triggers: set()
    weight: 10.3
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 11.699999999999998
line done
line done

---------------------

input line #45
input roots: [<__main__.Root object at 0x10fc4ba90>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 22.60000000000006..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 14.09999999999999..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 14.59999999999999..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 22.70000000000006..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 14.69999999999999..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 14.899999999999988..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 22.80000000000006..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 22.900000000000063..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 12.799999999999994..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 14.79999999999999..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'OFFSPRING_1', 'null_11', 'null_10', 'OFFSPRING_5'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc3df60>, '-', <__main__.AgrTerminal object at 0x10fc4bcf8>, '#', <__main__.Root object at 0x10fc42f98>, '-', <__main__.NominalizerTerminal object at 0x10fc42048>, '-', <__main__.SemanticTerminal object at 0x10fc3d518>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'i_2', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'i_2', 'a_2'}
we picked null_24 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: la#OFFSPRING-a
full_pronunciation: la#OFFSPRINGo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 22.900000000000063
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 14.79999999999999
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_4
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2', 'a_2'}
    diacritic: null_24
    triggers: set()
    weight: 10.0
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 11.599999999999998
line done
line done

---------------------

input line #46
input roots: [<__main__.Root object at 0x10fc3d0b8>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 14.699999999999987..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 22.900000000000063..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 14.999999999999988..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 15.099999999999987..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FLOWER in its selectional

now working with the word 'FLOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19', 'FLOWER_1'}
     what if we combine triggers with the otherwise identical vi FLOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FLOWER_3', 'e_3', 'null_19', 'FLOWER_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc385c0>, '-', <__main__.AgrTerminal object at 0x10fc4b978>, '#', <__main__.Root object at 0x10fc3c4e0>, '-', <__main__.NominalizerTerminal object at 0x10fc3c748>, '-', <__main__.SemanticTerminal object at 0x10fc3bb00>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FLOWER terminal with values set()
we picked FLOWER_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: uno#FLOWER-e
full_pronunciation: uno#FLOWERe
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: FLOWER to the selectional of the nominalizer whose values are {'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'o_2'}
    selectional: {'MOUSE', 'CHILD', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'FOOT'}
    selection_strength: True
    weight: 14.999999999999982
    linear: (<__main__.NominalizerTerminal object at 0x10fc08908>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'FLOWER', 'MOUSE'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_14, triggers = set(), weight = 10.3..already existed

create_vi: tried nominalizer: null_15, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.1..already existed
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 15.099999999999987
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 14.699999999999987
VocabularyItem:
    pronunciation: FLOWER
    label: FLOWER
    values: set()
    diacritic: FLOWER_4
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'})), ('e', frozenset({'+atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 13.400000000000004
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 10.7
line done
line done

---------------------

input line #47
input roots: [<__main__.Root object at 0x10fc31e10>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 23.000000000000064..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 14.79999999999999..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 14.19999999999999..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 23.100000000000065..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 15.299999999999986..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 14.29999999999999..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 23.200000000000067..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: CHILD in its selectional

now working with the word 'CHILD-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6', 'CHILD_1'}

create_vi: made CHILD: CHILD_7, triggers = {('null', frozenset()), ('e', frozenset({'-atomic'}))}, weight = 10.0
     what if we combine triggers with the otherwise identical vi CHILD_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?

create_vi: made CHILD: CHILD_8, triggers = {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}, weight = 10.0
     -> created a new vi CHILD_8 	spelling out CHILD: set() 		 triggering {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
     what if we combine triggers with the otherwise identical vi CHILD_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?

create_vi: made CHILD: CHILD_9, triggers = {('null', frozenset()), ('o', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}, weight = 10.0
     -> created a new vi CHILD_9 	spelling out CHILD: set() 		 triggering {('null', frozenset()), ('o', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'CHILD_1', 'CHILD_7', 'null_26', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50668>, '-', <__main__.AgrTerminal object at 0x10fc38390>, '#', <__main__.Root object at 0x10fc50898>, '-', <__main__.NominalizerTerminal object at 0x10fc50978>, '-', <__main__.SemanticTerminal object at 0x10fc50860>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'o_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'i_2', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: le#CHILD-e
full_pronunciation: li#CHILDi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 23.200000000000067
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 12.799999999999994
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_4
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 13.900000000000004
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 12.2
line done
line done

---------------------

input line #48
input roots: [<__main__.Root object at 0x10fc45160>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 23.200000000000067..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 14.39999999999999..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 15.399999999999986..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 23.300000000000068..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 15.499999999999986..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 15.699999999999987..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 23.40000000000007..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 23.50000000000007..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 12.799999999999994..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 15.599999999999985..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'GRANDPARENT_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'GRANDPARENT_1', 'GRANDPARENT_2'}
done processing input, time to test
we selected the nominalizer with values: {'e_1'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc5d0f0>, '#', <__main__.Root object at 0x10fc5d630>, '-', <__main__.NominalizerTerminal object at 0x10fc5d5c0>, '-', <__main__.SemanticTerminal object at 0x10fc5d4e0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', 'e_1', '+atomic'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_6: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1', 'null', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: lo#GRANDPARENT-o
full_pronunciation: l#GRANDPARENTa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 23.50000000000007
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_6
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 10.4
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 13.800000000000004
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 12.4
line done
line done

---------------------

input line #49
input roots: [<__main__.Root object at 0x10fc5d470>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 23.50000000000007..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 14.89999999999999..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 12.899999999999993..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 23.600000000000072..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 15.699999999999985..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 12.999999999999993..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 23.700000000000074..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'PIBLING_1', 'i_1', 'null_15'}

create_vi: made PIBLING: PIBLING_7, triggers = {('null', frozenset()), ('i', frozenset({'-atomic'}))}, weight = 10.0
     what if we combine triggers with the otherwise identical vi PIBLING_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?

create_vi: made PIBLING: PIBLING_8, triggers = {('null', frozenset()), ('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}, weight = 10.0
     -> created a new vi PIBLING_8 	spelling out PIBLING: set() 		 triggering {('null', frozenset()), ('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
     what if we combine triggers with the otherwise identical vi PIBLING_5 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?

create_vi: made PIBLING: PIBLING_9, triggers = {('null', frozenset()), ('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}, weight = 10.0
     -> created a new vi PIBLING_9 	spelling out PIBLING: set() 		 triggering {('null', frozenset()), ('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_7', 'null_15', 'PIBLING_1', 'i_1', 'null_14'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc506a0>, '#', <__main__.Root object at 0x10fc50470>, '-', <__main__.NominalizerTerminal object at 0x10fc50a58>, '-', <__main__.SemanticTerminal object at 0x10fc50400>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic'}
we picked le_1: no super match (neither decl nor L1-gender)
now spelling out PIBLING terminal with values set()
we picked PIBLING_6: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: li#PIBLING-i
full_pronunciation: le#PIBLINGe
vis_used:
Failure
VocabularyItem:
    pronunciation: le
    label: definite
    values: {'+definite', '-atomic'}
    diacritic: le_1
    triggers: set()
    weight: 10.0
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_6
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 13.700000000000005
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 11.299999999999999
line done
line done

---------------------

input line #50
input roots: [<__main__.Root object at 0x10fc50e10>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 15.799999999999985..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 23.800000000000075..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 15.799999999999986..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 15.899999999999986..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FLOWER in its selectional

now working with the word 'FLOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19', 'FLOWER_1'}
     what if we combine triggers with the otherwise identical vi FLOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FLOWER_3', 'e_3', 'null_19', 'FLOWER_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc42780>, '-', <__main__.AgrTerminal object at 0x10fc50358>, '#', <__main__.Root object at 0x10fc42128>, '-', <__main__.NominalizerTerminal object at 0x10fc428d0>, '-', <__main__.SemanticTerminal object at 0x10fc42550>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FLOWER terminal with values set()
we picked FLOWER_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: uno#FLOWER-e
full_pronunciation: una#FLOWERa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 15.899999999999986
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 14.89999999999999
VocabularyItem:
    pronunciation: FLOWER
    label: FLOWER
    values: set()
    diacritic: FLOWER_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 13.600000000000005
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 12.3
line done
line done

---------------------

input line #51
input roots: [<__main__.Root object at 0x10fc41748>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: set()
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 23.900000000000077..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 14.89999999999999..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 14.49999999999999..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 24.000000000000078..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 15.899999999999984..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 14.599999999999989..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 24.10000000000008..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: CAR in its selectional

now working with the word 'CAR-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6'}

create_vi: made CAR: CAR_1, triggers = set(), weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'CAR_1', 'null_6'}

create_vi: made CAR: CAR_2, triggers = {('null', frozenset()), ('e', frozenset({'-atomic'}))}, weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'CAR_2', 'null_26', 'CAR_1', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc45198>, '-', <__main__.AgrTerminal object at 0x10fc356d8>, '#', <__main__.Root object at 0x10fc45940>, '-', <__main__.NominalizerTerminal object at 0x10fc45cc0>, '-', <__main__.SemanticTerminal object at 0x10fc45438>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic', 'a_2'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CAR terminal with values set()
we picked CAR_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e', 'e_1', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: le#CAR-e
full_pronunciation: le#CARe
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CAR to the selectional of the nominalizer whose values are {'e_1', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1', 'a_2'}
    selectional: {'KEY', 'FROG', 'BALL', 'PIBLING', 'MILKCOW'}
    selection_strength: True
    weight: 10.799999999999999
    linear: (<__main__.NominalizerTerminal object at 0x10fc2aa20>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 24.10000000000008
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 14.599999999999989
VocabularyItem:
    pronunciation: CAR
    label: CAR
    values: set()
    diacritic: CAR_2
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 13.500000000000005
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 11.299999999999999
line done
line done

---------------------

input line #52
input roots: [<__main__.Root object at 0x10fc3dfd0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 24.70000000000008..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 14.99999999999999..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 13.099999999999993..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 24.800000000000082..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 15.999999999999984..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 13.199999999999992..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 24.900000000000084..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: CLOWN in its selectional

now working with the word 'CLOWN-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'CLOWN_1', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CLOWN_2', 'null_15', 'i_1', 'null_14', 'CLOWN_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc452b0>, '#', <__main__.Root object at 0x10fc4bb70>, '-', <__main__.NominalizerTerminal object at 0x10fc4bda0>, '-', <__main__.SemanticTerminal object at 0x10fc4bd30>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out CLOWN terminal with values set()
we picked CLOWN_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#CLOWN-i
full_pronunciation: l#CLOWNi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 24.900000000000084
VocabularyItem:
    pronunciation: CLOWN
    label: CLOWN
    values: set()
    diacritic: CLOWN_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 14.000000000000005
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 12.299999999999999
line done
line done

---------------------

input line #53
input roots: [<__main__.Root object at 0x10fc4bc50>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 24.900000000000084..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 15.199999999999989..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 16.099999999999984..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 25.000000000000085..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 16.199999999999985..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 15.899999999999986..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 25.100000000000087..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 25.200000000000088..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 13.299999999999992..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 16.299999999999986..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CASTLE in its selectional

now working with the word 'CASTLE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CASTLE_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'CASTLE_2', 'o_1', 'CASTLE_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc43c18>, '-', <__main__.AgrTerminal object at 0x10fc4ba58>, '#', <__main__.Root object at 0x10fc43940>, '-', <__main__.NominalizerTerminal object at 0x10fc437f0>, '-', <__main__.SemanticTerminal object at 0x10fc436a0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CASTLE terminal with values set()
we picked CASTLE_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o_2'}
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: lo#CASTLE-o
full_pronunciation: lo#CASTLEo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CASTLE to the selectional of the nominalizer whose values are {'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'o_2'}
    selectional: {'MOUSE', 'CHILD', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'FOOT'}
    selection_strength: True
    weight: 16.599999999999987
    linear: (<__main__.NominalizerTerminal object at 0x10fc08908>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'PIBLING', 'CHILD'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_6, triggers = set(), weight = 10.3..already existed

create_vi: tried nominalizer: null_7, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.0..already existed

create_vi: tried nominalizer: null_26, triggers = {('e', frozenset({'-atomic'}))}, weight = 10.1..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'PIBLING', 'FLOWER', 'MOUSE'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_14, triggers = set(), weight = 10.4..already existed

create_vi: tried nominalizer: null_15, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.2..already existed
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 25.200000000000088
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 16.299999999999986
VocabularyItem:
    pronunciation: CASTLE
    label: CASTLE
    values: set()
    diacritic: CASTLE_1
    triggers: set()
    weight: 10.4
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 13.900000000000006
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 11.699999999999998
line done
line done

---------------------

input line #54
input roots: [<__main__.Root object at 0x10fc4bba8>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: set()
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 25.80000000000009..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 15.099999999999989..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 13.399999999999991..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 25.90000000000009..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 16.899999999999988..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 13.499999999999991..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 26.000000000000092..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: BOOK in its selectional

now working with the word 'BOOK-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}

create_vi: made BOOK: BOOK_1, triggers = set(), weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'BOOK_1', 'i_1', 'null_15'}

create_vi: made BOOK: BOOK_2, triggers = {('null', frozenset()), ('i', frozenset({'-atomic'}))}, weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_15', 'BOOK_2', 'BOOK_1', 'i_1', 'null_14'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc586d8>, '-', <__main__.AgrTerminal object at 0x10fc4b9e8>, '#', <__main__.Root object at 0x10fc5d6a0>, '-', <__main__.NominalizerTerminal object at 0x10fc5d978>, '-', <__main__.SemanticTerminal object at 0x10fc5d550>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'a_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BOOK terminal with values set()
we picked BOOK_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i_2', 'a_2'}
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: li#BOOK-i
full_pronunciation: li#BOOKi
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: BOOK to the selectional of the nominalizer whose values are {'i_2', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'a_2'}
    selectional: {'CHILD', 'OFFSPRING'}
    selection_strength: True
    weight: 10.2
    linear: (<__main__.NominalizerTerminal object at 0x10fc36a90>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 26.000000000000092
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 13.499999999999991
VocabularyItem:
    pronunciation: BOOK
    label: BOOK
    values: set()
    diacritic: BOOK_1
    triggers: set()
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 14.400000000000006
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 12.299999999999999
line done
line done

---------------------

input line #55
input roots: [<__main__.Root object at 0x10fc58780>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 15.199999999999989..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 26.600000000000094..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 15.999999999999986..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 16.099999999999987..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'GRANDPARENT_1'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'GRANDPARENT_1', 'null_11', 'null_10', 'GRANDPARENT_3'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc5d0b8>, '#', <__main__.Root object at 0x10fc5de48>, '-', <__main__.NominalizerTerminal object at 0x10fc5ddd8>, '-', <__main__.SemanticTerminal object at 0x10fc5dcf8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite', 'i_2', '+atomic'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i_2'}
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: una#GRANDPARENT-a
full_pronunciation: un#GRANDPARENTo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 16.099999999999987
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_1
    triggers: set()
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 14.900000000000006
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 12.199999999999998
line done
line done

---------------------

input line #56
input roots: [<__main__.Root object at 0x10fc5dc88>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 26.700000000000095..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 15.299999999999988..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 15.299999999999988..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 26.800000000000097..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 16.99999999999999..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 15.399999999999988..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 26.900000000000098..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: MILKCOW in its selectional

now working with the word 'MILKCOW-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'null_17'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'MILKCOW_1', 'null_17'}
     what if we combine triggers with the otherwise identical vi MILKCOW_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'MILKCOW_3', 'MILKCOW_1', 'null_17'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc5d630>, '#', <__main__.Root object at 0x10fc5dbe0>, '-', <__main__.NominalizerTerminal object at 0x10fc5d0b8>, '-', <__main__.SemanticTerminal object at 0x10fc5ddd8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out MILKCOW terminal with values set()
we picked MILKCOW_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: le#MILKCOW-e
full_pronunciation: l#MILKCOWi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 26.900000000000098
VocabularyItem:
    pronunciation: MILKCOW
    label: MILKCOW
    values: set()
    diacritic: MILKCOW_2
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 10.5
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 14.800000000000006
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 12.799999999999999
line done
line done

---------------------

input line #57
input roots: [<__main__.Root object at 0x10fc5dc18>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 17.09999999999999..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 26.900000000000098..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 16.099999999999987..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 16.19999999999999..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'GRANDPARENT_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'GRANDPARENT_1', 'GRANDPARENT_2'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc47da0>, '-', <__main__.AgrTerminal object at 0x10fc5dac8>, '#', <__main__.Root object at 0x10fc47588>, '-', <__main__.NominalizerTerminal object at 0x10fc477f0>, '-', <__main__.SemanticTerminal object at 0x10fc47a58>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'e_1', 'a_2'}
we picked null_16 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: uno#GRANDPARENT-o
full_pronunciation: una#GRANDPARENTo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 16.19999999999999
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 15.299999999999988
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_2
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1', 'a_2'}
    diacritic: null_16
    triggers: set()
    weight: 10.5
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 12.199999999999998
line done
line done

---------------------

input line #58
input roots: [<__main__.Root object at 0x10fc5d4e0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 15.299999999999988..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 27.0000000000001..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 16.19999999999999..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 16.29999999999999..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'GRANDPARENT_1'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'GRANDPARENT_1', 'null_11', 'null_10', 'GRANDPARENT_3'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4be10>, '-', <__main__.AgrTerminal object at 0x10fc43470>, '#', <__main__.Root object at 0x10fc4b278>, '-', <__main__.NominalizerTerminal object at 0x10fc4b358>, '-', <__main__.SemanticTerminal object at 0x10fc4b0b8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'e_1', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: una#GRANDPARENT-a
full_pronunciation: una#GRANDPARENTo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 16.29999999999999
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 15.299999999999988
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_2
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 10.600000000000001
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 12.099999999999998
line done
line done

---------------------

input line #59
input roots: [<__main__.Root object at 0x10fc5dd68>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 27.1000000000001..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 15.499999999999988..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 15.299999999999988..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 27.200000000000102..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 15.399999999999988..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 16.29999999999999..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 27.300000000000104..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 27.400000000000105..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 14.09999999999999..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 15.499999999999988..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1', 'e_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: KEY in its selectional

now working with the word 'KEY-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'e_3', 'null_22'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'e_3', 'KEY_1', 'null_22'}
     what if we combine triggers with the otherwise identical vi KEY_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'KEY_3', 'KEY_1', 'null_16', 'null_22', 'e_3'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc45b70>, '-', <__main__.AgrTerminal object at 0x10fc4bba8>, '#', <__main__.Root object at 0x10fc454a8>, '-', <__main__.NominalizerTerminal object at 0x10fc45518>, '-', <__main__.SemanticTerminal object at 0x10fc45358>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out KEY terminal with values set()
we picked KEY_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: la#KEY-e
full_pronunciation: lo#KEYo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 27.400000000000105
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 17.09999999999999
VocabularyItem:
    pronunciation: KEY
    label: KEY
    values: set()
    diacritic: KEY_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 9.8
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 11.999999999999998
line done
line done

---------------------

input line #60
input roots: [<__main__.Root object at 0x10fc4ba90>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 27.400000000000105..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 15.599999999999987..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 15.599999999999987..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 27.500000000000107..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 17.09999999999999..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 15.699999999999987..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 27.600000000000108..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: KEY in its selectional

now working with the word 'KEY-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_6', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_6', 'null_7', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'KEY_1', 'null_6', 'null_7', 'i_1'}
     what if we combine triggers with the otherwise identical vi KEY_3 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'KEY_1', 'null_7', 'i_1', 'KEY_2', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b198>, '#', <__main__.Root object at 0x10fc3dd30>, '-', <__main__.NominalizerTerminal object at 0x10fc3d198>, '-', <__main__.SemanticTerminal object at 0x10fc3d550>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out KEY terminal with values set()
we picked KEY_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: le#KEY-i
full_pronunciation: l#KEYi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 27.600000000000108
VocabularyItem:
    pronunciation: KEY
    label: KEY
    values: set()
    diacritic: KEY_4
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'})), ('e', frozenset({'+atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 14.700000000000006
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 12.799999999999999
line done
line done

---------------------

input line #61
input roots: [<__main__.Root object at 0x10fc3d470>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 27.600000000000108..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 15.699999999999987..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 14.19999999999999..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 27.70000000000011..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 17.199999999999992..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 14.29999999999999..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 27.80000000000011..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: FOOT in its selectional

now working with the word 'FOOT-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FOOT_1', 'null_12', 'null_13', 'i_1'}

create_vi: made FOOT: FOOT_3, triggers = {('null', frozenset()), ('i', frozenset({'-atomic'}))}, weight = 10.0
     what if we combine triggers with the otherwise identical vi FOOT_2 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?

create_vi: made FOOT: FOOT_4, triggers = {('null', frozenset()), ('e', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}, weight = 10.0
     -> created a new vi FOOT_4 	spelling out FOOT: set() 		 triggering {('null', frozenset()), ('e', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'FOOT_3', 'FOOT_1', 'null_13', 'i_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b8d0>, '#', <__main__.Root object at 0x10fc38390>, '-', <__main__.NominalizerTerminal object at 0x10fc38908>, '-', <__main__.SemanticTerminal object at 0x10fc3bf98>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked li_1: no super match (neither decl nor L1-gender)
now spelling out FOOT terminal with values set()
we picked FOOT_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: li#FOOT-i
full_pronunciation: li#FOOTe
vis_used:
Failure
VocabularyItem:
    pronunciation: li
    label: definite
    values: {'+definite', '-atomic'}
    diacritic: li_1
    triggers: set()
    weight: 10.5
VocabularyItem:
    pronunciation: FOOT
    label: FOOT
    values: set()
    diacritic: FOOT_2
    triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))}
    weight: 10.5
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 10.500000000000002
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 11.899999999999999
line done
line done

---------------------

input line #62
input roots: [<__main__.Root object at 0x10fc412b0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 27.900000000000112..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 15.799999999999986..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 14.39999999999999..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 28.000000000000114..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 17.299999999999994..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 14.49999999999999..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 28.100000000000115..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'PIBLING_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi PIBLING_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_5 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_7', 'null_15', 'PIBLING_1', 'i_1', 'null_14'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50198>, '-', <__main__.AgrTerminal object at 0x10fc42a20>, '#', <__main__.Root object at 0x10fc50f98>, '-', <__main__.NominalizerTerminal object at 0x10fc50b00>, '-', <__main__.SemanticTerminal object at 0x10fc50710>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'a_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'i_2', 'a_2'}
we picked null_24 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: li#PIBLING-i
full_pronunciation: li#PIBLINGe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 28.100000000000115
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 14.49999999999999
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_3
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 10.5
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2', 'a_2'}
    diacritic: null_24
    triggers: set()
    weight: 9.9
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 11.799999999999999
line done
line done

---------------------

input line #63
input roots: [<__main__.Root object at 0x10fc50e10>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 28.100000000000115..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 15.799999999999986..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 15.899999999999986..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 28.200000000000117..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 15.999999999999986..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 16.39999999999999..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 28.300000000000118..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 28.40000000000012..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 14.49999999999999..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 16.099999999999987..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: KEY in its selectional

now working with the word 'KEY-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'null_10'}

create_vi: made nominalizer: null_29, triggers = {('e', frozenset({'+atomic'}))}, weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'KEY_1', 'null_10'}
     what if we combine triggers with the otherwise identical vi KEY_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'KEY_3', 'KEY_1', 'e_3', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67a58>, '-', <__main__.AgrTerminal object at 0x10fc508d0>, '#', <__main__.Root object at 0x10fc3bf98>, '-', <__main__.NominalizerTerminal object at 0x10fc3c898>, '-', <__main__.SemanticTerminal object at 0x10fc67b38>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out KEY terminal with values set()
we picked KEY_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e', 'e_1', 'o_2'}
we picked null_6 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: la#KEY-e
full_pronunciation: lo#KEYe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 28.40000000000012
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 17.299999999999994
VocabularyItem:
    pronunciation: KEY
    label: KEY
    values: set()
    diacritic: KEY_3
    triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_6
    triggers: set()
    weight: 10.3
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 11.499999999999998
line done
line done

---------------------

input line #64
input roots: [<__main__.Root object at 0x10fc38908>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 17.299999999999994..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 28.40000000000012..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 16.499999999999993..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 16.599999999999994..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1', 'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: CLOWN in its selectional

now working with the word 'CLOWN-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_18', 'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_18', 'o_1', 'CLOWN_1', 'null_12'}

create_vi: made CLOWN: CLOWN_3, triggers = {('o', frozenset({'+atomic'})), ('null', frozenset())}, weight = 10.0
     what if we combine triggers with the otherwise identical vi CLOWN_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?

create_vi: made CLOWN: CLOWN_4, triggers = {('o', frozenset({'+atomic'})), ('null', frozenset()), ('i', frozenset({'-atomic'}))}, weight = 10.0
     -> created a new vi CLOWN_4 	spelling out CLOWN: set() 		 triggering {('o', frozenset({'+atomic'})), ('null', frozenset()), ('i', frozenset({'-atomic'}))}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'CLOWN_3', 'o_1', 'null_18', 'CLOWN_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc45f60>, '-', <__main__.AgrTerminal object at 0x10fc42dd8>, '#', <__main__.Root object at 0x10fc3de10>, '-', <__main__.NominalizerTerminal object at 0x10fc3d630>, '-', <__main__.SemanticTerminal object at 0x10fc3d898>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CLOWN terminal with values set()
we picked CLOWN_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'i_2', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: uno#CLOWN-o
full_pronunciation: uno#CLOWNo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CLOWN to the selectional of the nominalizer whose values are {'i_2', 'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'o_2'}
    selectional: {'MOUSE', 'CLOWN', 'FOOT', 'OFFSPRING', 'PIBLING', 'FLOWER', 'GRANDPARENT'}
    selection_strength: True
    weight: 11.299999999999999
    linear: (<__main__.NominalizerTerminal object at 0x10fc22eb8>,)
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 16.599999999999994
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 17.299999999999994
VocabularyItem:
    pronunciation: CLOWN
    label: CLOWN
    values: set()
    diacritic: CLOWN_3
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 10.0
     what if we combine triggers with the otherwise identical vi CLOWN_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 14.600000000000007
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 11.999999999999998
line done
line done

---------------------

input line #65
input roots: [<__main__.Root object at 0x10fc458d0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 28.50000000000012..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 15.899999999999986..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 16.19999999999999..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 28.600000000000122..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 16.29999999999999..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 17.199999999999996..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 28.700000000000124..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 28.800000000000125..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 14.599999999999989..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 16.39999999999999..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1', 'e_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: CAR in its selectional

now working with the word 'CAR-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'null_27', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'null_27', 'a_1', 'CAR_1'}

create_vi: made CAR: CAR_3, triggers = {('null', frozenset()), ('a', frozenset({'+atomic'}))}, weight = 10.0
     what if we combine triggers with the otherwise identical vi CAR_2 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?

create_vi: made CAR: CAR_4, triggers = {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}, weight = 10.0
     -> created a new vi CAR_4 	spelling out CAR: set() 		 triggering {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'null_16', 'CAR_1', 'null_27', 'CAR_3'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc582b0>, '-', <__main__.AgrTerminal object at 0x10fc45860>, '#', <__main__.Root object at 0x10fc58208>, '-', <__main__.NominalizerTerminal object at 0x10fc58748>, '-', <__main__.SemanticTerminal object at 0x10fc58eb8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'i_2', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CAR terminal with values set()
we picked CAR_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'a_2'}
we picked null_14 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: la#CAR-a
full_pronunciation: la#CARa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CAR to the selectional of the nominalizer whose values are {'i_2', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'a_2'}
    selectional: {'BOOK', 'CHILD', 'OFFSPRING'}
    selection_strength: True
    weight: 10.299999999999999
    linear: (<__main__.NominalizerTerminal object at 0x10fc36a90>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 28.800000000000125
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 16.39999999999999
VocabularyItem:
    pronunciation: CAR
    label: CAR
    values: set()
    diacritic: CAR_2
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 10.5
     what if we combine triggers with the otherwise identical vi CAR_3 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 10.4
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 12.5
line done
line done

---------------------

input line #66
input roots: [<__main__.Root object at 0x10fc58dd8>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 17.899999999999995..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 29.400000000000126..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 17.299999999999997..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 17.4..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FOOT in its selectional

now working with the word 'FOOT-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FOOT_1', 'null_8', 'e_3', 'null_19'}
     what if we combine triggers with the otherwise identical vi FOOT_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FOOT_1', 'e_3', 'FOOT_2', 'null_19'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50f60>, '-', <__main__.AgrTerminal object at 0x10fc58f28>, '#', <__main__.Root object at 0x10fc503c8>, '-', <__main__.NominalizerTerminal object at 0x10fc500b8>, '-', <__main__.SemanticTerminal object at 0x10fc50d30>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FOOT terminal with values set()
we picked FOOT_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: uno#FOOT-e
full_pronunciation: uno#FOOTe
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: FOOT to the selectional of the nominalizer whose values are {'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'o_2'}
    selectional: {'MOUSE', 'CHILD', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'FOOT'}
    selection_strength: True
    weight: 17.800000000000004
    linear: (<__main__.NominalizerTerminal object at 0x10fc08908>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'PIBLING', 'CHILD'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_6, triggers = set(), weight = 10.3..already existed

create_vi: tried nominalizer: null_7, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.1..already existed

create_vi: tried nominalizer: null_26, triggers = {('e', frozenset({'-atomic'}))}, weight = 10.2..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'PIBLING', 'FLOWER', 'MOUSE'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_14, triggers = set(), weight = 11.0..already existed

create_vi: tried nominalizer: null_15, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.299999999999999..already existed
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 17.4
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 17.899999999999995
VocabularyItem:
    pronunciation: FOOT
    label: FOOT
    values: set()
    diacritic: FOOT_4
    triggers: {('null', frozenset()), ('e', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 15.100000000000007
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 11.499999999999998
line done
line done

---------------------

input line #67
input roots: [<__main__.Root object at 0x10fc38470>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 18.499999999999996..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 29.500000000000128..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 18.0..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 18.1..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: MOUSE in its selectional

now working with the word 'MOUSE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'MOUSE_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi MOUSE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'MOUSE_2', 'MOUSE_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc43ba8>, '-', <__main__.AgrTerminal object at 0x10fc50588>, '#', <__main__.Root object at 0x10fc477f0>, '-', <__main__.NominalizerTerminal object at 0x10fc47588>, '-', <__main__.SemanticTerminal object at 0x10fc43b00>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MOUSE terminal with values set()
we picked MOUSE_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'e_1', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: uno#MOUSE-o
full_pronunciation: una#MOUSEo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 18.1
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 16.89999999999999
VocabularyItem:
    pronunciation: MOUSE
    label: MOUSE
    values: set()
    diacritic: MOUSE_2
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 10.400000000000002
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 12.599999999999998
line done
line done

---------------------

input line #68
input roots: [<__main__.Root object at 0x10fc438d0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 29.60000000000013..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 15.999999999999986..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 18.599999999999998..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 29.70000000000013..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 18.7..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 18.1..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 29.800000000000132..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 29.900000000000134..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 14.699999999999989..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 18.8..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: BOOK in its selectional

now working with the word 'BOOK-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'BOOK_1', 'null_9'}

create_vi: made BOOK: BOOK_3, triggers = {('o', frozenset({'+atomic'})), ('null', frozenset())}, weight = 10.0
     what if we combine triggers with the otherwise identical vi BOOK_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?

create_vi: made BOOK: BOOK_4, triggers = {('o', frozenset({'+atomic'})), ('null', frozenset()), ('i', frozenset({'-atomic'}))}, weight = 10.0
     -> created a new vi BOOK_4 	spelling out BOOK: set() 		 triggering {('o', frozenset({'+atomic'})), ('null', frozenset()), ('i', frozenset({'-atomic'}))}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'BOOK_1', 'BOOK_3'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc43438>, '#', <__main__.Root object at 0x10fc4b940>, '-', <__main__.NominalizerTerminal object at 0x10fc4bcc0>, '-', <__main__.SemanticTerminal object at 0x10fc4bfd0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '+atomic'}
we picked lo_1: no super match (neither decl nor L1-gender)
now spelling out BOOK terminal with values set()
we picked BOOK_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: lo#BOOK-o
full_pronunciation: lo#BOOKo
vis_used:
Successful derivation!
VocabularyItem:
    pronunciation: lo
    label: definite
    values: {'+definite', '+atomic'}
    diacritic: lo_1
    triggers: set()
    weight: 10.3
VocabularyItem:
    pronunciation: BOOK
    label: BOOK
    values: set()
    diacritic: BOOK_3
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 10.0
     what if we combine triggers with the otherwise identical vi BOOK_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 15.600000000000007
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 12.599999999999998
line done
line done

---------------------

input line #69
input roots: [<__main__.Root object at 0x10fc4b908>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 18.900000000000002..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 30.000000000000135..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 18.200000000000003..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 18.300000000000004..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1', 'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: BOOK in its selectional

now working with the word 'BOOK-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_18', 'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_18', 'o_1', 'BOOK_1', 'null_12'}
     what if we combine triggers with the otherwise identical vi BOOK_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'o_1', 'BOOK_1', 'BOOK_3', 'null_18'}
done processing input, time to test
we selected the nominalizer with values: {'e_1'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b208>, '#', <__main__.Root object at 0x10fc4b4e0>, '-', <__main__.NominalizerTerminal object at 0x10fc4b470>, '-', <__main__.SemanticTerminal object at 0x10fc4bf28>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'e_1', '-definite', '+atomic'}
we picked uno_1: no super match (neither decl nor L1-gender)
now spelling out BOOK terminal with values set()
we picked BOOK_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1', 'null'}
we picked null_6 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: uno#BOOK-o
full_pronunciation: uno#BOOKe
vis_used:
Failure
VocabularyItem:
    pronunciation: uno
    label: definite
    values: {'-definite', '+atomic'}
    diacritic: uno_1
    triggers: set()
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: BOOK
    label: BOOK
    values: set()
    diacritic: BOOK_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_6
    triggers: set()
    weight: 10.3
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 11.999999999999998
line done
line done

---------------------

input line #70
input roots: [<__main__.Root object at 0x10fc4bb70>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 30.100000000000136..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 16.099999999999987..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 19.000000000000004..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 30.200000000000138..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 19.100000000000005..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 18.400000000000006..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 30.30000000000014..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 30.40000000000014..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 14.799999999999988..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 19.200000000000006..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'PIBLING_1', 'o_1', 'PIBLING_5'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc412b0>, '-', <__main__.AgrTerminal object at 0x10fc41a90>, '#', <__main__.Root object at 0x10fc4b518>, '-', <__main__.NominalizerTerminal object at 0x10fc4b0f0>, '-', <__main__.SemanticTerminal object at 0x10fc4bc88>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1', 'o_2'}
we picked null_26: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: lo#PIBLING-o
full_pronunciation: lo#PIBLINGo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: PIBLING to the selectional of the nominalizer whose values are {'e_1', 'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1', 'o_2'}
    selectional: {'PIBLING', 'CHILD'}
    selection_strength: True
    weight: 11.1
    linear: (<__main__.NominalizerTerminal object at 0x10fc3d400>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 30.40000000000014
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 19.200000000000006
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_1
    triggers: set()
    weight: 10.4
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_26
    triggers: {('e', frozenset({'-atomic'}))}
    weight: 10.2
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 13.299999999999997
line done
line done

---------------------

input line #71
input roots: [<__main__.Root object at 0x10fc3e320>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 16.89999999999999..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 31.000000000000142..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 18.500000000000007..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 18.60000000000001..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: KEY in its selectional

now working with the word 'KEY-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'KEY_1', 'null_10'}
     what if we combine triggers with the otherwise identical vi KEY_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'KEY_3', 'KEY_1', 'e_3', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b128>, '#', <__main__.Root object at 0x10fc4beb8>, '-', <__main__.NominalizerTerminal object at 0x10fc4bf60>, '-', <__main__.SemanticTerminal object at 0x10fc4bd30>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite', 'i_2', '+atomic'}
we picked una_1: no super match (neither decl nor L1-gender)
now spelling out KEY terminal with values set()
we picked KEY_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'i_2'}
we picked null_14 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: una#KEY-e
full_pronunciation: una#KEYe
vis_used:
Successful derivation!
VocabularyItem:
    pronunciation: una
    label: definite
    values: {'-definite', '+atomic'}
    diacritic: una_1
    triggers: set()
    weight: 9.8
VocabularyItem:
    pronunciation: KEY
    label: KEY
    values: set()
    diacritic: KEY_4
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'})), ('e', frozenset({'+atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 11.0
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 11.999999999999998
line done
line done

---------------------

input line #72
input roots: [<__main__.Root object at 0x10fc4b898>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 31.100000000000144..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 16.19999999999999..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 19.800000000000008..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 31.200000000000145..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 19.90000000000001..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 18.70000000000001..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 31.300000000000146..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 31.400000000000148..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 14.899999999999988..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 20.00000000000001..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: MOUSE in its selectional

now working with the word 'MOUSE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'MOUSE_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi MOUSE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'MOUSE_2', 'MOUSE_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc433c8>, '-', <__main__.AgrTerminal object at 0x10fc4b080>, '#', <__main__.Root object at 0x10fc43470>, '-', <__main__.NominalizerTerminal object at 0x10fc439b0>, '-', <__main__.SemanticTerminal object at 0x10fc43940>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MOUSE terminal with values set()
we picked MOUSE_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1', 'a_2'}
we picked null_29: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: lo#MOUSE-o
full_pronunciation: la#MOUSEe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 31.400000000000148
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 16.89999999999999
VocabularyItem:
    pronunciation: MOUSE
    label: MOUSE
    values: set()
    diacritic: MOUSE_1
    triggers: set()
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_29
    triggers: {('e', frozenset({'+atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 12.499999999999998
line done
line done

---------------------

input line #73
input roots: [<__main__.Root object at 0x10fc4ba90>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: set()
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 16.89999999999999..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 31.400000000000148..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 18.80000000000001..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 18.900000000000013..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: FROG in its selectional

now working with the word 'FROG-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi FROG_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_2', 'a_1', 'FROG_1', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc58128>, '-', <__main__.AgrTerminal object at 0x10fc4b320>, '#', <__main__.Root object at 0x10fc586d8>, '-', <__main__.NominalizerTerminal object at 0x10fc58a58>, '-', <__main__.SemanticTerminal object at 0x10fc58c88>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FROG terminal with values set()
we picked FROG_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: una#FROG-a
full_pronunciation: uno#FROGa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 18.900000000000013
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 20.00000000000001
VocabularyItem:
    pronunciation: FROG
    label: FROG
    values: set()
    diacritic: FROG_2
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 16.10000000000001
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 13.1
line done
line done

---------------------

input line #74
input roots: [<__main__.Root object at 0x10fc582e8>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 31.50000000000015..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 16.29999999999999..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 20.00000000000001..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 31.60000000000015..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 20.100000000000012..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 18.900000000000013..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 31.700000000000152..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 31.800000000000153..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 14.999999999999988..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 20.200000000000014..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FLOWER in its selectional

now working with the word 'FLOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19', 'FLOWER_1'}
     what if we combine triggers with the otherwise identical vi FLOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FLOWER_3', 'e_3', 'null_19', 'FLOWER_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc3dba8>, '#', <__main__.Root object at 0x10fc45160>, '-', <__main__.NominalizerTerminal object at 0x10fc452b0>, '-', <__main__.SemanticTerminal object at 0x10fc453c8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '+atomic', 'i_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out FLOWER terminal with values set()
we picked FLOWER_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i_2'}
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: lo#FLOWER-e
full_pronunciation: l#FLOWERo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 31.800000000000153
VocabularyItem:
    pronunciation: FLOWER
    label: FLOWER
    values: set()
    diacritic: FLOWER_1
    triggers: set()
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 16.000000000000007
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 13.899999999999997
line done
line done

---------------------

input line #75
input roots: [<__main__.Root object at 0x10fc3d470>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 31.800000000000153..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 16.39999999999999..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 20.300000000000015..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 31.900000000000155..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 20.400000000000016..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 19.000000000000014..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 32.000000000000156..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 32.10000000000016..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 15.099999999999987..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 20.500000000000018..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'OFFSPRING_3', 'o_1', 'OFFSPRING_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50550>, '-', <__main__.AgrTerminal object at 0x10fc58f28>, '#', <__main__.Root object at 0x10fc504a8>, '-', <__main__.NominalizerTerminal object at 0x10fc50c18>, '-', <__main__.SemanticTerminal object at 0x10fc50400>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: lo#OFFSPRING-o
full_pronunciation: la#OFFSPRINGo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 32.10000000000016
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 16.89999999999999
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_3
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 15.900000000000007
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 13.899999999999997
line done
line done

---------------------

input line #76
input roots: [<__main__.Root object at 0x10fc42c50>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 16.89999999999999..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 32.10000000000016..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 19.100000000000016..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 19.200000000000017..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: MILKCOW in its selectional

now working with the word 'MILKCOW-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'MILKCOW_1'}
     what if we combine triggers with the otherwise identical vi MILKCOW_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'MILKCOW_1', 'MILKCOW_2', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50160>, '-', <__main__.AgrTerminal object at 0x10fc50be0>, '#', <__main__.Root object at 0x10fc3cf28>, '-', <__main__.NominalizerTerminal object at 0x10fc3bf98>, '-', <__main__.SemanticTerminal object at 0x10fc38908>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MILKCOW terminal with values set()
we picked MILKCOW_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'o_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: una#MILKCOW-a
full_pronunciation: uno#MILKCOWa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 19.200000000000017
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 20.500000000000018
VocabularyItem:
    pronunciation: MILKCOW
    label: MILKCOW
    values: set()
    diacritic: MILKCOW_2
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 10.4
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 15.800000000000008
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 13.1
line done
line done

---------------------

input line #77
input roots: [<__main__.Root object at 0x10fc50f98>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 20.500000000000018..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 32.20000000000016..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 19.200000000000017..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 19.30000000000002..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1', 'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_18', 'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_18', 'o_1', 'null_12'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'OFFSPRING_3', 'o_1', 'null_18', 'OFFSPRING_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc2dbe0>, '-', <__main__.AgrTerminal object at 0x10fc42400>, '#', <__main__.Root object at 0x10fc2d438>, '-', <__main__.NominalizerTerminal object at 0x10fc2d588>, '-', <__main__.SemanticTerminal object at 0x10fc2d780>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_5: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: uno#OFFSPRING-o
full_pronunciation: una#OFFSPRINGa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 19.30000000000002
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 16.89999999999999
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_5
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 10.5
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 15.700000000000008
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 13.0
line done
line done

---------------------

input line #78
input roots: [<__main__.Root object at 0x10fc3c748>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 20.60000000000002..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 32.30000000000016..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 19.30000000000002..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 19.40000000000002..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1', 'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: BOOK in its selectional

now working with the word 'BOOK-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_18', 'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_18', 'o_1', 'BOOK_1', 'null_12'}
     what if we combine triggers with the otherwise identical vi BOOK_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'o_1', 'BOOK_1', 'BOOK_3', 'null_18'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50390>, '-', <__main__.AgrTerminal object at 0x10fc357b8>, '#', <__main__.Root object at 0x10fc500f0>, '-', <__main__.NominalizerTerminal object at 0x10fc50be0>, '-', <__main__.SemanticTerminal object at 0x10fc50d30>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BOOK terminal with values set()
we picked BOOK_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'i_2', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: uno#BOOK-o
full_pronunciation: una#BOOKo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 19.40000000000002
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 16.79999999999999
VocabularyItem:
    pronunciation: BOOK
    label: BOOK
    values: set()
    diacritic: BOOK_3
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 10.5
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 10.300000000000002
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 13.999999999999996
line done
line done

---------------------

input line #79
input roots: [<__main__.Root object at 0x10fc35be0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 32.40000000000016..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 16.499999999999993..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 20.70000000000002..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 32.50000000000016..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 20.800000000000022..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 19.40000000000002..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 32.600000000000165..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 32.700000000000166..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 15.199999999999987..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 20.900000000000023..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FOOT in its selectional

now working with the word 'FOOT-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FOOT_1', 'null_8', 'e_3', 'null_19'}
     what if we combine triggers with the otherwise identical vi FOOT_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FOOT_1', 'e_3', 'FOOT_2', 'null_19'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc42400>, '-', <__main__.AgrTerminal object at 0x10fc32a58>, '#', <__main__.Root object at 0x10fc42550>, '-', <__main__.NominalizerTerminal object at 0x10fc42908>, '-', <__main__.SemanticTerminal object at 0x10fc42c50>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FOOT terminal with values set()
we picked FOOT_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: lo#FOOT-e
full_pronunciation: lo#FOOTo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 32.700000000000166
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 20.900000000000023
VocabularyItem:
    pronunciation: FOOT
    label: FOOT
    values: set()
    diacritic: FOOT_3
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 13.899999999999997
line done
line done

---------------------

input line #80
input roots: [<__main__.Root object at 0x10fc50588>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 32.700000000000166..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 16.79999999999999..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 16.599999999999994..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 32.80000000000017..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 20.900000000000023..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 16.699999999999996..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 32.90000000000017..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: CHILD in its selectional

now working with the word 'CHILD-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6', 'CHILD_1'}
     what if we combine triggers with the otherwise identical vi CHILD_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'CHILD_1', 'CHILD_7', 'null_26', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc3dd30>, '-', <__main__.AgrTerminal object at 0x10fc50b70>, '#', <__main__.Root object at 0x10fc3db38>, '-', <__main__.NominalizerTerminal object at 0x10fc3d550>, '-', <__main__.SemanticTerminal object at 0x10fc3d898>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'a_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i_2', 'a_2'}
we picked null_14: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: le#CHILD-e
full_pronunciation: li#CHILDe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 32.90000000000017
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 15.199999999999987
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_1
    triggers: set()
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 11.5
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 11.799999999999999
line done
line done

---------------------

input line #81
input roots: [<__main__.Root object at 0x10fc45940>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 32.90000000000017..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 16.799999999999997..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 16.89999999999999..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 33.00000000000017..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 16.999999999999993..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 19.50000000000002..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 33.10000000000017..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 33.20000000000017..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 15.199999999999987..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 17.099999999999994..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: FROG in its selectional

now working with the word 'FROG-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi FROG_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_2', 'a_1', 'FROG_1', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc589e8>, '-', <__main__.AgrTerminal object at 0x10fc459b0>, '#', <__main__.Root object at 0x10fc58400>, '-', <__main__.NominalizerTerminal object at 0x10fc58438>, '-', <__main__.SemanticTerminal object at 0x10fc58cf8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FROG terminal with values set()
we picked FROG_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: la#FROG-a
full_pronunciation: lo#FROGo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 33.20000000000017
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 20.900000000000023
VocabularyItem:
    pronunciation: FROG
    label: FROG
    values: set()
    diacritic: FROG_3
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 15.600000000000009
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 13.799999999999997
line done
line done

---------------------

input line #82
input roots: [<__main__.Root object at 0x10fc580f0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: set()
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 33.20000000000017..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 17.199999999999996..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 16.9..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 33.300000000000175..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 20.900000000000023..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 17.0..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 33.400000000000176..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: TOWER in its selectional

now working with the word 'TOWER-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_6', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_6', 'null_7', 'i_1'}

create_vi: made TOWER: TOWER_1, triggers = set(), weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'TOWER_1', 'null_6', 'null_7', 'i_1'}

create_vi: made TOWER: TOWER_2, triggers = {('null', frozenset()), ('i', frozenset({'-atomic'}))}, weight = 10.0
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'TOWER_1', 'null_7', 'i_1', 'TOWER_2', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc47c18>, '-', <__main__.AgrTerminal object at 0x10fc586d8>, '#', <__main__.Root object at 0x10fc47f28>, '-', <__main__.NominalizerTerminal object at 0x10fc47438>, '-', <__main__.SemanticTerminal object at 0x10fc47cf8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'o_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out TOWER terminal with values set()
we picked TOWER_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'i_2', 'o_2'}
we picked null_14 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: le#TOWER-i
full_pronunciation: li#TOWERi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 33.400000000000176
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 15.199999999999987
VocabularyItem:
    pronunciation: TOWER
    label: TOWER
    values: set()
    diacritic: TOWER_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 11.4
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 12.999999999999998
line done
line done

---------------------

input line #83
input roots: [<__main__.Root object at 0x10fc43eb8>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 33.400000000000176..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 17.299999999999997..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 15.199999999999987..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 33.50000000000018..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 21.000000000000025..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 15.299999999999986..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 33.60000000000018..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: MOUSE in its selectional

now working with the word 'MOUSE-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'MOUSE_1', 'null_12', 'null_13', 'i_1'}
     what if we combine triggers with the otherwise identical vi MOUSE_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'MOUSE_3', 'null_12', 'null_13', 'i_1', 'MOUSE_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b1d0>, '-', <__main__.AgrTerminal object at 0x10fc43d68>, '#', <__main__.Root object at 0x10fc4bf28>, '-', <__main__.NominalizerTerminal object at 0x10fc4b358>, '-', <__main__.SemanticTerminal object at 0x10fc4b2e8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic', 'a_2'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MOUSE terminal with values set()
we picked MOUSE_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: li#MOUSE-i
full_pronunciation: le#MOUSEi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 33.60000000000018
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 17.0
VocabularyItem:
    pronunciation: MOUSE
    label: MOUSE
    values: set()
    diacritic: MOUSE_2
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 10.200000000000003
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 12.999999999999998
line done
line done

---------------------

input line #84
input roots: [<__main__.Root object at 0x10fc4b9b0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 33.60000000000018..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 17.0..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 17.4..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 33.70000000000018..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 17.5..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 19.600000000000023..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 33.80000000000018..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 33.90000000000018..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 15.399999999999986..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 17.6..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1', 'e_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: TOWER in its selectional

now working with the word 'TOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'e_3', 'null_22'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'TOWER_1', 'null_16', 'e_3', 'null_22'}

create_vi: made TOWER: TOWER_3, triggers = {('null', frozenset()), ('e', frozenset({'+atomic'}))}, weight = 10.0
     what if we combine triggers with the otherwise identical vi TOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?

create_vi: made TOWER: TOWER_4, triggers = {('null', frozenset()), ('i', frozenset({'-atomic'})), ('e', frozenset({'+atomic'}))}, weight = 10.0
     -> created a new vi TOWER_4 	spelling out TOWER: set() 		 triggering {('null', frozenset()), ('i', frozenset({'-atomic'})), ('e', frozenset({'+atomic'}))}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'TOWER_1', 'TOWER_3', 'null_16', 'null_22', 'e_3'}
done processing input, time to test
we selected the nominalizer with values: {'e_1'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b5c0>, '#', <__main__.Root object at 0x10fc20b38>, '-', <__main__.NominalizerTerminal object at 0x10fc28128>, '-', <__main__.SemanticTerminal object at 0x10fc22940>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', 'e_1', '+atomic'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out TOWER terminal with values set()
we picked TOWER_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'e_1', 'null'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: la#TOWER-e
full_pronunciation: l#TOWERe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 33.90000000000018
VocabularyItem:
    pronunciation: TOWER
    label: TOWER
    values: set()
    diacritic: TOWER_3
    triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 15.500000000000009
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 12.699999999999998
line done
line done

---------------------

input line #85
input roots: [<__main__.Root object at 0x10fc4b6a0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 33.90000000000018..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 17.700000000000003..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 15.499999999999986..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 34.000000000000185..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 21.100000000000026..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 15.599999999999985..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 34.100000000000186..already existed
  we're in a functional word...
  - nominalizer's values are now {'a_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'a_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_24', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_24', 'i_1', 'null_28'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'GRANDPARENT_1', 'null_24', 'i_1', 'null_28'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_3 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_28', 'null_24', 'i_1', 'GRANDPARENT_4', 'GRANDPARENT_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4bc88>, '#', <__main__.Root object at 0x10fc4ba20>, '-', <__main__.NominalizerTerminal object at 0x10fc4b1d0>, '-', <__main__.SemanticTerminal object at 0x10fc4b358>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked le_1: no super match (neither decl nor L1-gender)
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'a_2'}
we picked null_11: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: li#GRANDPARENT-i
full_pronunciation: le#GRANDPARENTe
vis_used:
Failure
VocabularyItem:
    pronunciation: le
    label: definite
    values: {'+definite', '-atomic'}
    diacritic: le_1
    triggers: set()
    weight: 9.9
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_1
    triggers: set()
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_11
    triggers: {('a', frozenset({'+atomic'}))}
    weight: 9.8
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 11.7
line done
line done

---------------------

input line #86
input roots: [<__main__.Root object at 0x10fc20b38>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 34.20000000000019..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 17.1..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 21.200000000000028..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 34.30000000000019..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 21.30000000000003..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 19.700000000000024..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 34.40000000000019..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 34.50000000000019..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 15.699999999999985..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 21.40000000000003..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'OFFSPRING_3', 'o_1', 'OFFSPRING_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc477f0>, '-', <__main__.AgrTerminal object at 0x10fc3e2b0>, '#', <__main__.Root object at 0x10fc43eb8>, '-', <__main__.NominalizerTerminal object at 0x10fc433c8>, '-', <__main__.SemanticTerminal object at 0x10fc47e48>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1', 'a_2'}
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: lo#OFFSPRING-o
full_pronunciation: la#OFFSPRINGe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 34.50000000000019
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 17.700000000000003
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_1
    triggers: set()
    weight: 10.3
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 15.40000000000001
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 12.599999999999998
line done
line done

---------------------

input line #87
input roots: [<__main__.Root object at 0x10fc20ef0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 17.700000000000003..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 34.50000000000019..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 19.800000000000026..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 19.900000000000027..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'GRANDPARENT_1'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'GRANDPARENT_1', 'null_11', 'null_10', 'GRANDPARENT_3'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc585c0>, '-', <__main__.AgrTerminal object at 0x10fc43c88>, '#', <__main__.Root object at 0x10fc58080>, '-', <__main__.NominalizerTerminal object at 0x10fc58748>, '-', <__main__.SemanticTerminal object at 0x10fc58278>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'a_2'}
we picked null_14 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: una#GRANDPARENT-a
full_pronunciation: una#GRANDPARENTa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: GRANDPARENT to the selectional of the nominalizer whose values are {'i_2', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'a_2'}
    selectional: {'BOOK', 'CHILD', 'GRANDPARENT', 'CAR', 'OFFSPRING'}
    selection_strength: True
    weight: 10.399999999999999
    linear: (<__main__.NominalizerTerminal object at 0x10fc36a90>,)
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 19.900000000000027
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 17.700000000000003
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_4
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.0
     what if we combine triggers with the otherwise identical vi GRANDPARENT_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_3 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 11.3
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 13.1
line done
line done

---------------------

input line #88
input roots: [<__main__.Root object at 0x10fc580f0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 21.500000000000032..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 34.60000000000019..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 20.50000000000003..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 20.60000000000003..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CASTLE in its selectional

now working with the word 'CASTLE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CASTLE_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'CASTLE_2', 'o_1', 'CASTLE_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc3dfd0>, '-', <__main__.AgrTerminal object at 0x10fc58fd0>, '#', <__main__.Root object at 0x10fc45518>, '-', <__main__.NominalizerTerminal object at 0x10fc45f60>, '-', <__main__.SemanticTerminal object at 0x10fc45f98>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CASTLE terminal with values set()
we picked CASTLE_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1', 'o_2'}
we picked null_19: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: uno#CASTLE-o
full_pronunciation: uno#CASTLEe
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 20.60000000000003
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 21.500000000000032
VocabularyItem:
    pronunciation: CASTLE
    label: CASTLE
    values: set()
    diacritic: CASTLE_1
    triggers: set()
    weight: 10.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_19
    triggers: {('e', frozenset({'+atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 12.499999999999998
line done
line done

---------------------

input line #89
input roots: [<__main__.Root object at 0x10fc58a20>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 34.700000000000195..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 17.200000000000003..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 21.500000000000032..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 34.800000000000196..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 21.600000000000033..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 20.60000000000003..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 34.9000000000002..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 35.0000000000002..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 15.799999999999985..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 21.700000000000035..already existed
  we're in a functional word...
  - nominalizer's values are now {'i_2', 'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: BOOK in its selectional

now working with the word 'BOOK-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_18', 'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_18', 'o_1', 'BOOK_1', 'null_12'}
     what if we combine triggers with the otherwise identical vi BOOK_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'o_1', 'BOOK_1', 'BOOK_3', 'null_18'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc3d710>, '#', <__main__.Root object at 0x10fc42048>, '-', <__main__.NominalizerTerminal object at 0x10fc42128>, '-', <__main__.SemanticTerminal object at 0x10fc42f28>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '+atomic'}
we picked lo_1: no super match (neither decl nor L1-gender)
now spelling out BOOK terminal with values set()
we picked BOOK_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: lo#BOOK-o
full_pronunciation: lo#BOOKa
vis_used:
Failure
VocabularyItem:
    pronunciation: lo
    label: definite
    values: {'+definite', '+atomic'}
    diacritic: lo_1
    triggers: set()
    weight: 10.8
VocabularyItem:
    pronunciation: BOOK
    label: BOOK
    values: set()
    diacritic: BOOK_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 15.30000000000001
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 13.6
line done
line done

---------------------

input line #90
input roots: [<__main__.Root object at 0x10fc42208>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 35.1000000000002..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 18.300000000000004..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 17.300000000000004..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 35.2000000000002..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 21.800000000000036..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 17.400000000000006..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 35.3000000000002..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'null_17'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'CHILD_1', 'null_17'}
     what if we combine triggers with the otherwise identical vi CHILD_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'CHILD_1', 'CHILD_7', 'null_16', 'null_17'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50710>, '-', <__main__.AgrTerminal object at 0x10fc45e80>, '#', <__main__.Root object at 0x10fc38470>, '-', <__main__.NominalizerTerminal object at 0x10fc50390>, '-', <__main__.SemanticTerminal object at 0x10fc50be0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'a_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_8: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'i_2', 'a_2'}
we picked null_14 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: le#CHILD-e
full_pronunciation: li#CHILDe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 35.3000000000002
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 15.799999999999985
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_8
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 11.8
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 11.7
line done
line done

---------------------

input line #91
input roots: [<__main__.Root object at 0x10fc500f0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 35.3000000000002..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 17.500000000000007..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 21.900000000000038..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 35.400000000000205..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 22.00000000000004..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 20.70000000000003..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 35.500000000000206..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 35.60000000000021..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 15.799999999999985..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 22.10000000000004..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'PIBLING_1', 'o_1', 'PIBLING_5'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc2d9e8>, '-', <__main__.AgrTerminal object at 0x10fc355c0>, '#', <__main__.Root object at 0x10fc184e0>, '-', <__main__.NominalizerTerminal object at 0x10fc18748>, '-', <__main__.SemanticTerminal object at 0x10fc2d518>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: lo#PIBLING-o
full_pronunciation: lo#PIBLINGa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 35.60000000000021
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 22.10000000000004
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.3
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 15.20000000000001
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 13.5
line done
line done

---------------------

input line #92
input roots: [<__main__.Root object at 0x10fc2d3c8>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 22.10000000000004..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 35.60000000000021..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 20.800000000000033..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 20.900000000000034..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'GRANDPARENT_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'GRANDPARENT_1', 'GRANDPARENT_2'}
done processing input, time to test
we selected the nominalizer with values: {'e_1'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc10a20>, '#', <__main__.Root object at 0x10fc2d780>, '-', <__main__.NominalizerTerminal object at 0x10fc2db70>, '-', <__main__.SemanticTerminal object at 0x10fc18358>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'e_1', '-definite', '+atomic'}
we picked una_1: no super match (neither decl nor L1-gender)
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1'}
we picked null_6: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: uno#GRANDPARENT-o
full_pronunciation: una#GRANDPARENTo
vis_used:
Failure
VocabularyItem:
    pronunciation: una
    label: definite
    values: {'-definite', '+atomic'}
    diacritic: una_1
    triggers: set()
    weight: 10.3
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_1
    triggers: set()
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_6
    triggers: set()
    weight: 10.200000000000001
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 14.199999999999996
line done
line done

---------------------

input line #93
input roots: [<__main__.Root object at 0x10fc10dd8>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 18.400000000000006..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 35.70000000000021..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 21.000000000000036..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 21.100000000000037..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_2', 'a_1', 'PIBLING_1', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc506a0>, '-', <__main__.AgrTerminal object at 0x10fc3ce48>, '#', <__main__.Root object at 0x10fc50b00>, '-', <__main__.NominalizerTerminal object at 0x10fc50358>, '-', <__main__.SemanticTerminal object at 0x10fc50860>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: una#PIBLING-a
full_pronunciation: una#PIBLINGo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 21.100000000000037
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 18.400000000000006
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_3
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 10.4
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 15.10000000000001
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 14.099999999999996
line done
line done

---------------------

input line #94
input roots: [<__main__.Root object at 0x10fc355c0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 35.80000000000021..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 17.60000000000001..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 18.400000000000006..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 35.90000000000021..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 18.500000000000007..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 21.100000000000037..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 36.00000000000021..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 36.100000000000215..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 15.899999999999984..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 18.60000000000001..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: CAR in its selectional

now working with the word 'CAR-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'CAR_1'}
     what if we combine triggers with the otherwise identical vi CAR_2 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'null_10', 'CAR_1', 'null_11', 'CAR_3'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc505c0>, '#', <__main__.Root object at 0x10fc42550>, '-', <__main__.NominalizerTerminal object at 0x10fc42198>, '-', <__main__.SemanticTerminal object at 0x10fc505f8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '+atomic'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out CAR terminal with values set()
we picked CAR_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values set()
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: la#CAR-a
full_pronunciation: l#CARe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 36.100000000000215
VocabularyItem:
    pronunciation: CAR
    label: CAR
    values: set()
    diacritic: CAR_1
    triggers: set()
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 15.00000000000001
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 12.399999999999999
line done
line done

---------------------

input line #95
input roots: [<__main__.Root object at 0x10fc50198>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 22.200000000000042..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 36.100000000000215..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 21.20000000000004..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 21.30000000000004..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CLOWN in its selectional

now working with the word 'CLOWN-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CLOWN_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CLOWN_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'CLOWN_3', 'o_1', 'CLOWN_1'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc42be0>, '#', <__main__.Root object at 0x10fc3d710>, '-', <__main__.NominalizerTerminal object at 0x10fc45b70>, '-', <__main__.SemanticTerminal object at 0x10fc45860>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite', '+atomic'}
we picked uno_1: no super match (neither decl nor L1-gender)
now spelling out CLOWN terminal with values set()
we picked CLOWN_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: uno#CLOWN-o
full_pronunciation: uno#CLOWNe
vis_used:
Failure
VocabularyItem:
    pronunciation: uno
    label: definite
    values: {'-definite', '+atomic'}
    diacritic: uno_1
    triggers: set()
    weight: 9.600000000000001
VocabularyItem:
    pronunciation: CLOWN
    label: CLOWN
    values: set()
    diacritic: CLOWN_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 14.900000000000011
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 12.299999999999999
line done
line done

---------------------

input line #96
input roots: [<__main__.Root object at 0x10fc457f0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 36.200000000000216..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 17.70000000000001..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 22.300000000000043..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 36.30000000000022..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 22.400000000000045..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 21.40000000000004..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 36.40000000000022..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 36.50000000000022..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 15.999999999999984..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 22.500000000000046..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CASTLE in its selectional

now working with the word 'CASTLE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CASTLE_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'CASTLE_2', 'o_1', 'CASTLE_1'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc45358>, '#', <__main__.Root object at 0x10fc58d30>, '-', <__main__.NominalizerTerminal object at 0x10fc58630>, '-', <__main__.SemanticTerminal object at 0x10fc58c50>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '+atomic'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out CASTLE terminal with values set()
we picked CASTLE_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values set()
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: lo#CASTLE-o
full_pronunciation: l#CASTLEo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 36.50000000000022
VocabularyItem:
    pronunciation: CASTLE
    label: CASTLE
    values: set()
    diacritic: CASTLE_1
    triggers: set()
    weight: 10.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 14.800000000000011
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 14.199999999999996
line done
line done

---------------------

input line #97
input roots: [<__main__.Root object at 0x10fc58860>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 18.70000000000001..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 36.50000000000022..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 21.500000000000043..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 21.600000000000044..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: BALL in its selectional

now working with the word 'BALL-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'BALL_1', 'a_1'}
     what if we combine triggers with the otherwise identical vi BALL_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'BALL_1', 'BALL_2', 'null_10', 'null_11'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc43940>, '-', <__main__.AgrTerminal object at 0x10fc58f28>, '#', <__main__.Root object at 0x10fc43278>, '-', <__main__.NominalizerTerminal object at 0x10fc43208>, '-', <__main__.SemanticTerminal object at 0x10fc439e8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BALL terminal with values set()
we picked BALL_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: una#BALL-a
full_pronunciation: una#BALLa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: BALL to the selectional of the nominalizer whose values are {'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'a_2'}
    selectional: {'FROG', 'CHILD', 'BALL', 'PIBLING', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 19.50000000000003
    linear: (<__main__.NominalizerTerminal object at 0x10fc05f28>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'CHILD', 'BALL', 'FROG', 'PIBLING', 'CAR', 'KEY'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_6, triggers = set(), weight = 10.200000000000001..already existed

create_vi: tried nominalizer: null_7, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.2..already existed

create_vi: tried nominalizer: null_26, triggers = {('e', frozenset({'-atomic'}))}, weight = 10.799999999999999..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'PIBLING', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_14, triggers = set(), weight = 11.8..already existed

create_vi: tried nominalizer: null_15, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.399999999999999..already existed
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 21.600000000000044
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 18.70000000000001
VocabularyItem:
    pronunciation: BALL
    label: BALL
    values: set()
    diacritic: BALL_2
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 9.9
     what if we combine triggers with the otherwise identical vi BALL_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 14.700000000000012
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 13.7
line done
line done

---------------------

input line #98
input roots: [<__main__.Root object at 0x10fc437f0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 36.60000000000022..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 17.80000000000001..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 19.30000000000001..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 36.70000000000022..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 19.400000000000013..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 22.200000000000045..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 36.800000000000225..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 36.900000000000226..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 16.099999999999984..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 19.500000000000014..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: BALL in its selectional

now working with the word 'BALL-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'BALL_1', 'a_1'}
     what if we combine triggers with the otherwise identical vi BALL_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'BALL_1', 'BALL_2', 'null_10', 'null_11'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b320>, '-', <__main__.AgrTerminal object at 0x10fc3e320>, '#', <__main__.Root object at 0x10fc4b470>, '-', <__main__.NominalizerTerminal object at 0x10fc4b7f0>, '-', <__main__.SemanticTerminal object at 0x10fc4b208>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BALL terminal with values set()
we picked BALL_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'a_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#BALL-a
full_pronunciation: la#BALLa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: BALL to the selectional of the nominalizer whose values are {'e_1', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1', 'a_2'}
    selectional: {'FROG', 'BALL', 'CHILD', 'TOWER', 'PIBLING', 'CAR', 'KEY', 'MILKCOW'}
    selection_strength: True
    weight: 11.699999999999998
    linear: (<__main__.NominalizerTerminal object at 0x10fc2aa20>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 36.900000000000226
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 19.500000000000014
VocabularyItem:
    pronunciation: BALL
    label: BALL
    values: set()
    diacritic: BALL_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 15.200000000000012
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 14.299999999999999
line done
line done

---------------------

input line #99
input roots: [<__main__.Root object at 0x10fc412b0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 37.50000000000023..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 20.100000000000016..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 17.900000000000013..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 37.60000000000023..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 22.600000000000048..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 18.000000000000014..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 37.70000000000023..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: FROG in its selectional

now working with the word 'FROG-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'null_17'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_1', 'e_2', 'null_16', 'null_17'}
     what if we combine triggers with the otherwise identical vi FROG_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'FROG_1', 'FROG_3', 'null_17'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4be10>, '#', <__main__.Root object at 0x10fc207b8>, '-', <__main__.NominalizerTerminal object at 0x10fc20ef0>, '-', <__main__.SemanticTerminal object at 0x10fc226d8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out FROG terminal with values set()
we picked FROG_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: le#FROG-e
full_pronunciation: l#FROGe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 37.70000000000023
VocabularyItem:
    pronunciation: FROG
    label: FROG
    values: set()
    diacritic: FROG_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 9.600000000000001
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 11.7
line done
line done

---------------------

input line #100
input roots: [<__main__.Root object at 0x10fc4b5c0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 37.70000000000023..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 20.200000000000017..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 16.199999999999985..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 37.80000000000023..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 22.70000000000005..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 16.299999999999986..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 37.90000000000023..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: FLOWER in its selectional

now working with the word 'FLOWER-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'FLOWER_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi FLOWER_3 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_15', 'FLOWER_2', 'i_1', 'null_14', 'FLOWER_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b550>, '-', <__main__.AgrTerminal object at 0x10fc4bf98>, '#', <__main__.Root object at 0x10fc4bbe0>, '-', <__main__.NominalizerTerminal object at 0x10fc4b2e8>, '-', <__main__.SemanticTerminal object at 0x10fc4b828>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FLOWER terminal with values set()
we picked FLOWER_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i_2'}
we picked null_14: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: li#FLOWER-i
full_pronunciation: li#FLOWERe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 37.90000000000023
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 16.299999999999986
VocabularyItem:
    pronunciation: FLOWER
    label: FLOWER
    values: set()
    diacritic: FLOWER_1
    triggers: set()
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 11.8
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 11.6
line done
line done

---------------------

input line #101
input roots: [<__main__.Root object at 0x10fc4b860>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 37.90000000000023..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 20.30000000000002..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 16.299999999999986..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 38.000000000000234..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 22.80000000000005..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 16.399999999999988..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 38.100000000000236..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: CLOWN in its selectional

now working with the word 'CLOWN-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'CLOWN_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi CLOWN_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CLOWN_2', 'null_15', 'i_1', 'null_14', 'CLOWN_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc47400>, '-', <__main__.AgrTerminal object at 0x10fc4be48>, '#', <__main__.Root object at 0x10fc43d68>, '-', <__main__.NominalizerTerminal object at 0x10fc43f60>, '-', <__main__.SemanticTerminal object at 0x10fc438d0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic', 'a_2'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CLOWN terminal with values set()
we picked CLOWN_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i', 'e_1', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#CLOWN-i
full_pronunciation: le#CLOWNi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 38.100000000000236
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 18.000000000000014
VocabularyItem:
    pronunciation: CLOWN
    label: CLOWN
    values: set()
    diacritic: CLOWN_4
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 15.700000000000012
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 13.199999999999998
line done
line done

---------------------

input line #102
input roots: [<__main__.Root object at 0x10fc47080>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 38.100000000000236..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 20.40000000000002..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 18.000000000000014..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 38.20000000000024..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 22.900000000000052..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 18.100000000000016..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 38.30000000000024..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'PIBLING_1', 'null_6'}
     what if we combine triggers with the otherwise identical vi PIBLING_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_5 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'PIBLING_3', 'PIBLING_1', 'null_26', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc47320>, '#', <__main__.Root object at 0x10fc58128>, '-', <__main__.NominalizerTerminal object at 0x10fc58198>, '-', <__main__.SemanticTerminal object at 0x10fc587b8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out PIBLING terminal with values set()
we picked PIBLING_9: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: le#PIBLING-e
full_pronunciation: l#PIBLINGi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 38.30000000000024
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_9
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 10.100000000000003
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 13.099999999999998
line done
line done

---------------------

input line #103
input roots: [<__main__.Root object at 0x10fc58e10>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 38.30000000000024..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 20.50000000000002..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 16.49999999999999..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 38.40000000000024..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 23.000000000000053..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 16.59999999999999..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 38.50000000000024..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'CHILD_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi CHILD_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CHILD_1', 'null_15', 'CHILD_4', 'i_1', 'null_14'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc58e80>, '#', <__main__.Root object at 0x10fc3dfd0>, '-', <__main__.NominalizerTerminal object at 0x10fc3dba8>, '-', <__main__.SemanticTerminal object at 0x10fc3d5c0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out CHILD terminal with values set()
we picked CHILD_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: li#CHILD-i
full_pronunciation: l#CHILDe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 38.50000000000024
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_3
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 15.600000000000012
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 11.6
line done
line done

---------------------

input line #104
input roots: [<__main__.Root object at 0x10fc3d358>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 23.100000000000055..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 38.50000000000024..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 22.300000000000047..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 22.40000000000005..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FOOT in its selectional

now working with the word 'FOOT-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FOOT_1', 'null_8', 'e_3', 'null_19'}
     what if we combine triggers with the otherwise identical vi FOOT_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FOOT_1', 'e_3', 'FOOT_2', 'null_19'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc42a20>, '-', <__main__.AgrTerminal object at 0x10fc58630>, '#', <__main__.Root object at 0x10fc42cc0>, '-', <__main__.NominalizerTerminal object at 0x10fc42b00>, '-', <__main__.SemanticTerminal object at 0x10fc42f28>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FOOT terminal with values set()
we picked FOOT_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e', 'e_1', 'a_2'}
we picked null_6 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: uno#FOOT-e
full_pronunciation: una#FOOTe
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 22.40000000000005
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 20.50000000000002
VocabularyItem:
    pronunciation: FOOT
    label: FOOT
    values: set()
    diacritic: FOOT_2
    triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))}
    weight: 10.4
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_6
    triggers: set()
    weight: 10.200000000000001
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 12.299999999999999
line done
line done

---------------------

input line #105
input roots: [<__main__.Root object at 0x10fc226d8>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 38.60000000000024..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 20.50000000000002..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 16.699999999999992..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 38.700000000000244..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 23.200000000000056..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 16.799999999999994..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 38.800000000000246..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: FLOWER in its selectional

now working with the word 'FLOWER-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'FLOWER_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi FLOWER_3 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_15', 'FLOWER_2', 'i_1', 'null_14', 'FLOWER_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50198>, '#', <__main__.Root object at 0x10fc50240>, '-', <__main__.NominalizerTerminal object at 0x10fc500b8>, '-', <__main__.SemanticTerminal object at 0x10fc50a90>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked le_1: no super match (neither decl nor L1-gender)
now spelling out FLOWER terminal with values set()
we picked FLOWER_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#FLOWER-i
full_pronunciation: le#FLOWERi
vis_used:
Failure
VocabularyItem:
    pronunciation: le
    label: definite
    values: {'+definite', '-atomic'}
    diacritic: le_1
    triggers: set()
    weight: 9.8
VocabularyItem:
    pronunciation: FLOWER
    label: FLOWER
    values: set()
    diacritic: FLOWER_4
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'})), ('e', frozenset({'+atomic'}))}
    weight: 10.5
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 10.000000000000004
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 13.199999999999998
line done
line done

---------------------

input line #106
input roots: [<__main__.Root object at 0x10fc503c8>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: set()
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 38.90000000000025..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 20.600000000000023..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 18.200000000000017..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 39.00000000000025..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 23.300000000000058..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 18.30000000000002..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 39.10000000000025..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: FROG in its selectional

now working with the word 'FROG-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6', 'FROG_1'}
     what if we combine triggers with the otherwise identical vi FROG_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'FROG_1', 'null_26', 'FROG_3', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc36710>, '-', <__main__.AgrTerminal object at 0x10fc50390>, '#', <__main__.Root object at 0x10fc2d6d8>, '-', <__main__.NominalizerTerminal object at 0x10fc2dbe0>, '-', <__main__.SemanticTerminal object at 0x10fc2dd68>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'o_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FROG terminal with values set()
we picked FROG_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i_2', 'o_2'}
we picked null_9: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: le#FROG-e
full_pronunciation: li#FROGi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 39.10000000000025
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 16.799999999999994
VocabularyItem:
    pronunciation: FROG
    label: FROG
    values: set()
    diacritic: FROG_1
    triggers: set()
    weight: 10.4
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_9
    triggers: {('o', frozenset({'+atomic'}))}
    weight: 9.8
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 13.099999999999998
line done
line done

---------------------

input line #107
input roots: [<__main__.Root object at 0x10fc50be0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 23.40000000000006..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 39.10000000000025..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 22.40000000000005..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 22.50000000000005..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CASTLE in its selectional

now working with the word 'CASTLE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CASTLE_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'CASTLE_2', 'o_1', 'CASTLE_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67be0>, '-', <__main__.AgrTerminal object at 0x10fc362b0>, '#', <__main__.Root object at 0x10fc67e10>, '-', <__main__.NominalizerTerminal object at 0x10fc67da0>, '-', <__main__.SemanticTerminal object at 0x10fc67cc0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CASTLE terminal with values set()
we picked CASTLE_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: uno#CASTLE-o
full_pronunciation: una#CASTLEo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 22.50000000000005
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 20.600000000000023
VocabularyItem:
    pronunciation: CASTLE
    label: CASTLE
    values: set()
    diacritic: CASTLE_2
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 9.900000000000004
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 14.199999999999996
line done
line done

---------------------

input line #108
input roots: [<__main__.Root object at 0x10fc3e828>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 39.20000000000025..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 20.600000000000023..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 16.799999999999994..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 39.30000000000025..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 23.50000000000006..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 16.899999999999995..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 39.400000000000254..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_12', 'null_13', 'i_1'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_5 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'OFFSPRING_2', 'null_13', 'i_1', 'OFFSPRING_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc36160>, '#', <__main__.Root object at 0x10fc3bb00>, '-', <__main__.NominalizerTerminal object at 0x10fc3bf98>, '-', <__main__.SemanticTerminal object at 0x10fc08550>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_6: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#OFFSPRING-i
full_pronunciation: l#OFFSPRINGi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 39.400000000000254
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_6
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 15.500000000000012
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 13.099999999999998
line done
line done

---------------------

input line #109
input roots: [<__main__.Root object at 0x10fc2db70>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 20.700000000000024..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 39.400000000000254..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 22.50000000000005..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 22.60000000000005..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1', 'e_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: FROG in its selectional

now working with the word 'FROG-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'null_27', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_1', 'null_16', 'null_27', 'a_1'}
     what if we combine triggers with the otherwise identical vi FROG_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_2', 'a_1', 'null_16', 'null_27', 'FROG_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc502e8>, '#', <__main__.Root object at 0x10fc50f60>, '-', <__main__.NominalizerTerminal object at 0x10fc50ba8>, '-', <__main__.SemanticTerminal object at 0x10fc50c88>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'e_1', '-definite', '+atomic'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out FROG terminal with values set()
we picked FROG_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1'}
we picked null_26: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: una#FROG-a
full_pronunciation: un#FROGe
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 22.60000000000005
VocabularyItem:
    pronunciation: FROG
    label: FROG
    values: set()
    diacritic: FROG_1
    triggers: set()
    weight: 10.3
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_26
    triggers: {('e', frozenset({'-atomic'}))}
    weight: 10.799999999999999
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 12.2
line done
line done

---------------------

input line #110
input roots: [<__main__.Root object at 0x10fc50ac8>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 39.500000000000256..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 18.40000000000002..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 23.600000000000062..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 39.60000000000026..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 23.700000000000063..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 22.60000000000005..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 39.70000000000026..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 39.80000000000026..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 16.999999999999996..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 23.800000000000065..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: MOUSE in its selectional

now working with the word 'MOUSE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'MOUSE_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi MOUSE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'MOUSE_2', 'MOUSE_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc45198>, '-', <__main__.AgrTerminal object at 0x10fc509e8>, '#', <__main__.Root object at 0x10fc45b70>, '-', <__main__.NominalizerTerminal object at 0x10fc459b0>, '-', <__main__.SemanticTerminal object at 0x10fc45cc0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MOUSE terminal with values set()
we picked MOUSE_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: lo#MOUSE-o
full_pronunciation: lo#MOUSEo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: MOUSE to the selectional of the nominalizer whose values are {'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'o_2'}
    selectional: {'MOUSE', 'CHILD', 'BOOK', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 24.800000000000104
    linear: (<__main__.NominalizerTerminal object at 0x10fc08908>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'PIBLING', 'CHILD'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_20, triggers = set(), weight = 10.1..already existed

create_vi: made nominalizer: null_30, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.0
....made the new vi: VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1', 'o_2'}
    diacritic: null_30
    triggers: {('i', frozenset({'-atomic'}))}
    weight: 10.0

create_vi: made nominalizer: null_31, triggers = {('e', frozenset({'-atomic'}))}, weight = 10.0
....made the new vi: VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1', 'o_2'}
    diacritic: null_31
    triggers: {('e', frozenset({'-atomic'}))}
    weight: 10.0
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'CLOWN', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_12, triggers = set(), weight = 10.1..already existed

create_vi: tried nominalizer: null_13, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.0..already existed
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 39.80000000000026
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 23.800000000000065
VocabularyItem:
    pronunciation: MOUSE
    label: MOUSE
    values: set()
    diacritic: MOUSE_2
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 9.8
     what if we combine triggers with the otherwise identical vi MOUSE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 9.500000000000002
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 14.199999999999996
line done
line done

---------------------

input line #111
input roots: [<__main__.Root object at 0x10fc45860>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 20.800000000000026..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 40.40000000000026..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 22.700000000000053..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 22.800000000000054..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1', 'e_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: CAR in its selectional

now working with the word 'CAR-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'null_27', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'null_27', 'a_1', 'CAR_1'}
     what if we combine triggers with the otherwise identical vi CAR_2 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'null_16', 'CAR_1', 'null_27', 'CAR_3'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc58c50>, '-', <__main__.AgrTerminal object at 0x10fc45160>, '#', <__main__.Root object at 0x10fc58320>, '-', <__main__.NominalizerTerminal object at 0x10fc58438>, '-', <__main__.SemanticTerminal object at 0x10fc58c88>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CAR terminal with values set()
we picked CAR_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1', 'o_2'}
we picked null_19: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: una#CAR-a
full_pronunciation: uno#CARe
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 22.800000000000054
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 24.300000000000065
VocabularyItem:
    pronunciation: CAR
    label: CAR
    values: set()
    diacritic: CAR_1
    triggers: set()
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_19
    triggers: {('e', frozenset({'+atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 12.1
line done
line done

---------------------

input line #112
input roots: [<__main__.Root object at 0x10fc58048>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 40.50000000000026..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 18.50000000000002..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 20.900000000000027..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 40.600000000000264..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 21.00000000000003..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 22.800000000000054..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 40.700000000000266..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 40.80000000000027..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 17.099999999999998..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 21.10000000000003..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: BALL in its selectional

now working with the word 'BALL-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'BALL_1', 'a_1'}
     what if we combine triggers with the otherwise identical vi BALL_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'BALL_1', 'BALL_2', 'null_10', 'null_11'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc436a0>, '-', <__main__.AgrTerminal object at 0x10fc58fd0>, '#', <__main__.Root object at 0x10fc47080>, '-', <__main__.NominalizerTerminal object at 0x10fc47e10>, '-', <__main__.SemanticTerminal object at 0x10fc43128>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'i_2', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BALL terminal with values set()
we picked BALL_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a', 'i_2', 'a_2'}
we picked null_24 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#BALL-a
full_pronunciation: la#BALLa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: BALL to the selectional of the nominalizer whose values are {'i_2', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'a_2'}
    selectional: {'BOOK', 'CHILD', 'OFFSPRING', 'PIBLING', 'GRANDPARENT', 'CAR'}
    selection_strength: True
    weight: 11.099999999999998
    linear: (<__main__.NominalizerTerminal object at 0x10fc36a90>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 40.80000000000027
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 21.10000000000003
VocabularyItem:
    pronunciation: BALL
    label: BALL
    values: set()
    diacritic: BALL_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.5
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2', 'a_2'}
    diacritic: null_24
    triggers: set()
    weight: 9.8
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 15.099999999999998
line done
line done

---------------------

input line #113
input roots: [<__main__.Root object at 0x10fc438d0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 41.40000000000027..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 21.70000000000003..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 17.2..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 41.50000000000027..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 24.300000000000065..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 17.3..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 41.60000000000027..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: FLOWER in its selectional

now working with the word 'FLOWER-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'FLOWER_1', 'i_1'}
     what if we combine triggers with the otherwise identical vi FLOWER_3 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'FLOWER_2', 'null_13', 'i_1', 'FLOWER_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc47320>, '#', <__main__.Root object at 0x10fc4bfd0>, '-', <__main__.NominalizerTerminal object at 0x10fc4bac8>, '-', <__main__.SemanticTerminal object at 0x10fc4b3c8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out FLOWER terminal with values set()
we picked FLOWER_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#FLOWER-i
full_pronunciation: l#FLOWERi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 41.60000000000027
VocabularyItem:
    pronunciation: FLOWER
    label: FLOWER
    values: set()
    diacritic: FLOWER_4
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'})), ('e', frozenset({'+atomic'}))}
    weight: 10.4
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 10.000000000000002
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 13.099999999999998
line done
line done

---------------------

input line #114
input roots: [<__main__.Root object at 0x10fc4b198>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 41.60000000000027..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 18.600000000000023..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 21.800000000000033..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 41.70000000000027..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 21.900000000000034..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 22.900000000000055..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 41.800000000000274..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 41.900000000000276..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 17.400000000000002..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 22.000000000000036..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_2', 'a_1', 'PIBLING_1', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b518>, '#', <__main__.Root object at 0x10fc67ef0>, '-', <__main__.NominalizerTerminal object at 0x10fc67ba8>, '-', <__main__.SemanticTerminal object at 0x10fc20b38>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '+atomic', 'i_2'}
we picked lo_1: no super match (neither decl nor L1-gender)
now spelling out PIBLING terminal with values set()
we picked PIBLING_5: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'i_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: la#PIBLING-a
full_pronunciation: lo#PIBLINGo
vis_used:
Failure
VocabularyItem:
    pronunciation: lo
    label: definite
    values: {'+definite', '+atomic'}
    diacritic: lo_1
    triggers: set()
    weight: 10.700000000000001
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_5
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 15.400000000000013
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 14.699999999999996
line done
line done

---------------------

input line #115
input roots: [<__main__.Root object at 0x10fc4bef0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 42.00000000000028..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 18.700000000000024..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 24.400000000000066..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 42.10000000000028..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 24.500000000000068..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 23.000000000000057..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 42.20000000000028..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 42.30000000000028..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 17.500000000000004..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 24.60000000000007..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CLOWN in its selectional

now working with the word 'CLOWN-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CLOWN_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CLOWN_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'CLOWN_3', 'o_1', 'CLOWN_1'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67f98>, '#', <__main__.Root object at 0x10fc6a358>, '-', <__main__.NominalizerTerminal object at 0x10fc6a2e8>, '-', <__main__.SemanticTerminal object at 0x10fc6a208>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '+atomic'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out CLOWN terminal with values set()
we picked CLOWN_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values set()
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: lo#CLOWN-o
full_pronunciation: l#CLOWNo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 42.30000000000028
VocabularyItem:
    pronunciation: CLOWN
    label: CLOWN
    values: set()
    diacritic: CLOWN_1
    triggers: set()
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 15.300000000000013
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 14.699999999999996
line done
line done

---------------------

input line #116
input roots: [<__main__.Root object at 0x10fc4bbe0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 42.30000000000028..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 22.100000000000037..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 17.600000000000005..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 42.40000000000028..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 24.70000000000007..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 17.700000000000006..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 42.500000000000284..already existed
  we're in a functional word...
  - nominalizer's values are now {'a_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'a_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_24', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_24', 'i_1', 'null_28'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'GRANDPARENT_1', 'null_24', 'i_1', 'null_28'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_3 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_28', 'null_24', 'i_1', 'GRANDPARENT_4', 'GRANDPARENT_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b128>, '-', <__main__.AgrTerminal object at 0x10fc67d68>, '#', <__main__.Root object at 0x10fc4bfd0>, '-', <__main__.NominalizerTerminal object at 0x10fc4b198>, '-', <__main__.SemanticTerminal object at 0x10fc4b908>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'o_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'o_2'}
we picked null_12 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: li#GRANDPARENT-i
full_pronunciation: li#GRANDPARENTe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 42.500000000000284
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 17.700000000000006
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_3
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2', 'o_2'}
    diacritic: null_12
    triggers: set()
    weight: 10.1
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 11.6
line done
line done

---------------------

input line #117
input roots: [<__main__.Root object at 0x10fc4bf60>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 42.500000000000284..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 18.800000000000026..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 22.20000000000004..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 42.600000000000286..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 22.30000000000004..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 23.10000000000006..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 42.70000000000029..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 42.80000000000029..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 17.700000000000006..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 22.40000000000004..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: KEY in its selectional

now working with the word 'KEY-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'KEY_1', 'null_10'}
     what if we combine triggers with the otherwise identical vi KEY_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'KEY_3', 'KEY_1', 'e_3', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc43780>, '-', <__main__.AgrTerminal object at 0x10fc67ba8>, '#', <__main__.Root object at 0x10fc43860>, '-', <__main__.NominalizerTerminal object at 0x10fc43f60>, '-', <__main__.SemanticTerminal object at 0x10fc438d0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out KEY terminal with values set()
we picked KEY_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e', 'e_1', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: la#KEY-e
full_pronunciation: lo#KEYe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 42.80000000000029
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 24.70000000000007
VocabularyItem:
    pronunciation: KEY
    label: KEY
    values: set()
    diacritic: KEY_4
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'})), ('e', frozenset({'+atomic'}))}
    weight: 10.4
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 15.200000000000014
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 12.1
line done
line done

---------------------

input line #118
input roots: [<__main__.Root object at 0x10fc47240>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 22.500000000000043..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 42.80000000000029..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 23.20000000000006..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 23.30000000000006..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: BALL in its selectional

now working with the word 'BALL-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'BALL_1', 'a_1'}
     what if we combine triggers with the otherwise identical vi BALL_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'BALL_1', 'BALL_2', 'null_10', 'null_11'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc58320>, '-', <__main__.AgrTerminal object at 0x10fc47080>, '#', <__main__.Root object at 0x10fc581d0>, '-', <__main__.NominalizerTerminal object at 0x10fc58f60>, '-', <__main__.SemanticTerminal object at 0x10fc58c88>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BALL terminal with values set()
we picked BALL_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'a_2'}
we picked null_16 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: una#BALL-a
full_pronunciation: una#BALLa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: BALL to the selectional of the nominalizer whose values are {'e_1', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1', 'a_2'}
    selectional: {'FROG', 'BALL', 'CHILD', 'TOWER', 'PIBLING', 'CAR', 'KEY', 'MILKCOW'}
    selection_strength: True
    weight: 12.199999999999996
    linear: (<__main__.NominalizerTerminal object at 0x10fc2aa20>,)
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 23.30000000000006
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 22.500000000000043
VocabularyItem:
    pronunciation: BALL
    label: BALL
    values: set()
    diacritic: BALL_3
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 10.5
     what if we combine triggers with the otherwise identical vi BALL_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1', 'a_2'}
    diacritic: null_16
    triggers: set()
    weight: 10.4
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 15.799999999999997
line done
line done

---------------------

input line #119
input roots: [<__main__.Root object at 0x10fc4be48>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 23.100000000000044..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 42.90000000000029..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 23.900000000000063..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 24.000000000000064..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: MILKCOW in its selectional

now working with the word 'MILKCOW-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'MILKCOW_1'}
     what if we combine triggers with the otherwise identical vi MILKCOW_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'MILKCOW_1', 'MILKCOW_2', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc580b8>, '#', <__main__.Root object at 0x10fc45358>, '-', <__main__.NominalizerTerminal object at 0x10fc45438>, '-', <__main__.SemanticTerminal object at 0x10fc45940>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite', 'i_2', '+atomic'}
we picked una_1: no super match (neither decl nor L1-gender)
now spelling out MILKCOW terminal with values set()
we picked MILKCOW_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i_2'}
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: una#MILKCOW-a
full_pronunciation: una#MILKCOWa
vis_used:
Successful derivation!
VocabularyItem:
    pronunciation: una
    label: definite
    values: {'-definite', '+atomic'}
    diacritic: una_1
    triggers: set()
    weight: 10.200000000000001
VocabularyItem:
    pronunciation: MILKCOW
    label: MILKCOW
    values: set()
    diacritic: MILKCOW_1
    triggers: set()
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 15.100000000000014
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 16.4
line done
line done

---------------------

input line #120
input roots: [<__main__.Root object at 0x10fc582b0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 43.00000000000029..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 23.200000000000045..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 18.900000000000027..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 43.10000000000029..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 24.70000000000007..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 19.00000000000003..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 43.200000000000294..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'o_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'o_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_20'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_20', 'null_31'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'OFFSPRING_1', 'null_20', 'null_31'}

create_vi: made OFFSPRING: OFFSPRING_7, triggers = {('null', frozenset()), ('e', frozenset({'-atomic'}))}, weight = 10.0
     what if we combine triggers with the otherwise identical vi OFFSPRING_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?

create_vi: made OFFSPRING: OFFSPRING_8, triggers = {('null', frozenset()), ('o', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}, weight = 10.0
     -> created a new vi OFFSPRING_8 	spelling out OFFSPRING: set() 		 triggering {('null', frozenset()), ('o', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
     what if we combine triggers with the otherwise identical vi OFFSPRING_5 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?

create_vi: made OFFSPRING: OFFSPRING_9, triggers = {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}, weight = 10.0
     -> created a new vi OFFSPRING_9 	spelling out OFFSPRING: set() 		 triggering {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_20', 'OFFSPRING_7', 'OFFSPRING_1', 'null_31'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50940>, '-', <__main__.AgrTerminal object at 0x10fc58630>, '#', <__main__.Root object at 0x10fc50828>, '-', <__main__.NominalizerTerminal object at 0x10fc50198>, '-', <__main__.SemanticTerminal object at 0x10fc50a58>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'a_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: le#OFFSPRING-e
full_pronunciation: li#OFFSPRINGi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 43.200000000000294
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 17.700000000000006
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_3
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 15.600000000000014
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 13.099999999999998
line done
line done

---------------------

input line #121
input roots: [<__main__.Root object at 0x10fc42128>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 43.200000000000294..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 19.10000000000003..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 23.300000000000047..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 43.300000000000296..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 23.40000000000005..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 24.100000000000065..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 43.4000000000003..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 43.5000000000003..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 17.700000000000006..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 23.50000000000005..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'CHILD_1', 'a_1'}
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CHILD_1', 'a_1', 'CHILD_2', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc3ce48>, '-', <__main__.AgrTerminal object at 0x10fc500b8>, '#', <__main__.Root object at 0x10fc36160>, '-', <__main__.NominalizerTerminal object at 0x10fc361d0>, '-', <__main__.SemanticTerminal object at 0x10fc35e48>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2', 'a'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#CHILD-a
full_pronunciation: la#CHILDa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CHILD to the selectional of the nominalizer whose values are {'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'a_2'}
    selectional: {'FROG', 'CHILD', 'BALL', 'PIBLING', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 23.400000000000084
    linear: (<__main__.NominalizerTerminal object at 0x10fc05f28>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'CHILD', 'BALL', 'FROG', 'PIBLING', 'CAR', 'KEY'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_16, triggers = set(), weight = 11.0..already existed

create_vi: made nominalizer: null_32, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.0
....made the new vi: VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1', 'a_2'}
    diacritic: null_32
    triggers: {('i', frozenset({'-atomic'}))}
    weight: 10.0

create_vi: tried nominalizer: null_17, triggers = {('e', frozenset({'-atomic'}))}, weight = 10.1..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'PIBLING', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_24, triggers = set(), weight = 10.4..already existed

create_vi: tried nominalizer: null_28, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.1..already existed
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 43.5000000000003
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 23.50000000000005
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_2
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 10.5
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 9.800000000000004
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 17.0
line done
line done

---------------------

input line #122
input roots: [<__main__.Root object at 0x10fc385c0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 44.1000000000003..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 24.10000000000005..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 19.20000000000003..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 44.2000000000003..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 24.80000000000007..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 19.300000000000033..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 44.3000000000003..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: KEY in its selectional

now working with the word 'KEY-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'null_32', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'KEY_1', 'null_32', 'i_1'}
     what if we combine triggers with the otherwise identical vi KEY_3 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'KEY_1', 'null_16', 'null_32', 'i_1', 'KEY_2'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50780>, '#', <__main__.Root object at 0x10fc6a0b8>, '-', <__main__.NominalizerTerminal object at 0x10fc6a080>, '-', <__main__.SemanticTerminal object at 0x10fc6a208>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic'}
we picked le_1: no super match (neither decl nor L1-gender)
now spelling out KEY terminal with values set()
we picked KEY_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values set()
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: le#KEY-i
full_pronunciation: le#KEYi
vis_used:
Successful derivation!
VocabularyItem:
    pronunciation: le
    label: definite
    values: {'+definite', '-atomic'}
    diacritic: le_1
    triggers: set()
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: KEY
    label: KEY
    values: set()
    diacritic: KEY_1
    triggers: set()
    weight: 10.5
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 15.500000000000014
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 13.099999999999998
line done
line done

---------------------

input line #123
input roots: [<__main__.Root object at 0x10fc45400>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 44.400000000000304..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 19.400000000000034..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 24.900000000000073..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 44.500000000000306..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 25.000000000000075..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 24.200000000000067..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 44.60000000000031..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 44.70000000000031..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 17.800000000000008..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 25.100000000000076..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FOOT in its selectional

now working with the word 'FOOT-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FOOT_1', 'null_8', 'e_3', 'null_19'}
     what if we combine triggers with the otherwise identical vi FOOT_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FOOT_1', 'e_3', 'FOOT_2', 'null_19'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50a20>, '-', <__main__.AgrTerminal object at 0x10fc36390>, '#', <__main__.Root object at 0x10fc505f8>, '-', <__main__.NominalizerTerminal object at 0x10fc502b0>, '-', <__main__.SemanticTerminal object at 0x10fc500f0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FOOT terminal with values set()
we picked FOOT_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'a_2'}
we picked null_29: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: lo#FOOT-e
full_pronunciation: la#FOOTe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 44.70000000000031
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 24.10000000000005
VocabularyItem:
    pronunciation: FOOT
    label: FOOT
    values: set()
    diacritic: FOOT_1
    triggers: set()
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_29
    triggers: {('e', frozenset({'+atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 12.1
line done
line done

---------------------

input line #124
input roots: [<__main__.Root object at 0x10fc36160>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 24.10000000000005..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 44.70000000000031..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 24.300000000000068..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 24.40000000000007..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: CAR in its selectional

now working with the word 'CAR-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'CAR_1'}
     what if we combine triggers with the otherwise identical vi CAR_2 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'null_10', 'CAR_1', 'null_11', 'CAR_3'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc42048>, '-', <__main__.AgrTerminal object at 0x10fc50a90>, '#', <__main__.Root object at 0x10fc457f0>, '-', <__main__.NominalizerTerminal object at 0x10fc42c50>, '-', <__main__.SemanticTerminal object at 0x10fc42710>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CAR terminal with values set()
we picked CAR_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: una#CAR-a
full_pronunciation: una#CARa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CAR to the selectional of the nominalizer whose values are {'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'a_2'}
    selectional: {'FROG', 'CHILD', 'BALL', 'PIBLING', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 23.90000000000009
    linear: (<__main__.NominalizerTerminal object at 0x10fc05f28>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'CHILD', 'BALL', 'FROG', 'PIBLING', 'CAR', 'KEY'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_6, triggers = set(), weight = 10.200000000000001..already existed

create_vi: tried nominalizer: null_7, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.299999999999999..already existed

create_vi: tried nominalizer: null_26, triggers = {('e', frozenset({'-atomic'}))}, weight = 10.799999999999999..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'PIBLING', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_14, triggers = set(), weight = 11.8..already existed

create_vi: tried nominalizer: null_15, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.499999999999998..already existed
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 24.40000000000007
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 24.10000000000005
VocabularyItem:
    pronunciation: CAR
    label: CAR
    values: set()
    diacritic: CAR_2
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 11.0
     what if we combine triggers with the otherwise identical vi CAR_3 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 16.000000000000014
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 17.6
line done
line done

---------------------

input line #125
input roots: [<__main__.Root object at 0x10fc427b8>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 44.80000000000031..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 24.700000000000053..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 19.500000000000036..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 44.90000000000031..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 25.200000000000077..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 19.600000000000037..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 45.00000000000031..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'null_17'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'GRANDPARENT_1', 'null_17'}

create_vi: made GRANDPARENT: GRANDPARENT_7, triggers = {('null', frozenset()), ('e', frozenset({'-atomic'}))}, weight = 10.0
     what if we combine triggers with the otherwise identical vi GRANDPARENT_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?

create_vi: made GRANDPARENT: GRANDPARENT_8, triggers = {('null', frozenset()), ('o', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}, weight = 10.0
     -> created a new vi GRANDPARENT_8 	spelling out GRANDPARENT: set() 		 triggering {('null', frozenset()), ('o', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_3 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?

create_vi: made GRANDPARENT: GRANDPARENT_9, triggers = {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}, weight = 10.0
     -> created a new vi GRANDPARENT_9 	spelling out GRANDPARENT: set() 		 triggering {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'GRANDPARENT_7', 'null_17', 'GRANDPARENT_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc425c0>, '#', <__main__.Root object at 0x10fc412b0>, '-', <__main__.NominalizerTerminal object at 0x10fc3d828>, '-', <__main__.SemanticTerminal object at 0x10fc3d5c0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked li_1: no super match (neither decl nor L1-gender)
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: le#GRANDPARENT-e
full_pronunciation: li#GRANDPARENTi
vis_used:
Failure
VocabularyItem:
    pronunciation: li
    label: definite
    values: {'+definite', '-atomic'}
    diacritic: li_1
    triggers: set()
    weight: 10.4
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_4
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.5
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 10.300000000000004
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 13.599999999999998
line done
line done

---------------------

input line #126
input roots: [<__main__.Root object at 0x10fc3dbe0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 45.100000000000314..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 24.800000000000054..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 19.70000000000004..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 45.200000000000315..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 25.30000000000008..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 19.80000000000004..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 45.30000000000032..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: TOWER in its selectional

now working with the word 'TOWER-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_6', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_6', 'null_7', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'TOWER_1', 'null_6', 'null_7', 'i_1'}
     what if we combine triggers with the otherwise identical vi TOWER_3 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'TOWER_1', 'null_7', 'i_1', 'TOWER_2', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc58f60>, '#', <__main__.Root object at 0x10fc58f28>, '-', <__main__.NominalizerTerminal object at 0x10fc58be0>, '-', <__main__.SemanticTerminal object at 0x10fc587b8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked le_1: no super match (neither decl nor L1-gender)
now spelling out TOWER terminal with values set()
we picked TOWER_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: le#TOWER-i
full_pronunciation: le#TOWERi
vis_used:
Successful derivation!
VocabularyItem:
    pronunciation: le
    label: definite
    values: {'+definite', '-atomic'}
    diacritic: le_1
    triggers: set()
    weight: 10.200000000000001
VocabularyItem:
    pronunciation: TOWER
    label: TOWER
    values: set()
    diacritic: TOWER_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.9
     what if we combine triggers with the otherwise identical vi TOWER_3 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 16.500000000000014
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 13.599999999999998
line done
line done

---------------------

input line #127
input roots: [<__main__.Root object at 0x10fc583c8>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 45.40000000000032..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 19.90000000000004..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 24.900000000000055..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 45.50000000000032..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 25.000000000000057..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 25.00000000000007..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 45.60000000000032..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 45.70000000000032..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 17.90000000000001..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 25.10000000000006..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: MILKCOW in its selectional

now working with the word 'MILKCOW-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'MILKCOW_1'}
     what if we combine triggers with the otherwise identical vi MILKCOW_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'MILKCOW_1', 'MILKCOW_2', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc47160>, '-', <__main__.AgrTerminal object at 0x10fc58d30>, '#', <__main__.Root object at 0x10fc28128>, '-', <__main__.NominalizerTerminal object at 0x10fc47400>, '-', <__main__.SemanticTerminal object at 0x10fc47cf8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'i_2', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MILKCOW terminal with values set()
we picked MILKCOW_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: la#MILKCOW-a
full_pronunciation: la#MILKCOWo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 45.70000000000032
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 25.10000000000006
VocabularyItem:
    pronunciation: MILKCOW
    label: MILKCOW
    values: set()
    diacritic: MILKCOW_3
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 10.200000000000005
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 14.599999999999996
line done
line done

---------------------

input line #128
input roots: [<__main__.Root object at 0x10fc471d0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 25.10000000000006..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 45.70000000000032..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 25.100000000000072..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 25.200000000000074..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'OFFSPRING_1', 'null_11', 'null_10', 'OFFSPRING_5'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b2e8>, '-', <__main__.AgrTerminal object at 0x10fc43710>, '#', <__main__.Root object at 0x10fc4bf98>, '-', <__main__.NominalizerTerminal object at 0x10fc4bba8>, '-', <__main__.SemanticTerminal object at 0x10fc4b208>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_9: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'o_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: una#OFFSPRING-a
full_pronunciation: uno#OFFSPRINGa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 25.200000000000074
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 25.30000000000008
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_9
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 17.000000000000014
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 18.300000000000004
line done
line done

---------------------

input line #129
input roots: [<__main__.Root object at 0x10fc42208>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 45.800000000000324..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 20.000000000000043..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 25.20000000000006..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 45.900000000000325..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 25.30000000000006..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 25.200000000000074..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 46.00000000000033..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 46.10000000000033..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 18.00000000000001..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 25.400000000000063..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'GRANDPARENT_1'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'GRANDPARENT_1', 'null_11', 'null_10', 'GRANDPARENT_3'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a080>, '-', <__main__.AgrTerminal object at 0x10fc4b2b0>, '#', <__main__.Root object at 0x10fc6a898>, '-', <__main__.NominalizerTerminal object at 0x10fc6a400>, '-', <__main__.SemanticTerminal object at 0x10fc6a2b0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_5: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: la#GRANDPARENT-a
full_pronunciation: la#GRANDPARENTo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 46.10000000000033
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 25.400000000000063
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_5
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 16.900000000000013
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 14.499999999999996
line done
line done

---------------------

input line #130
input roots: [<__main__.Root object at 0x10fc43e48>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 46.10000000000033..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 25.400000000000063..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 20.100000000000044..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 46.20000000000033..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 25.30000000000008..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 20.200000000000045..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 46.30000000000033..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'null_17'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'GRANDPARENT_1', 'null_17'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_3 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'GRANDPARENT_7', 'null_17', 'GRANDPARENT_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b240>, '-', <__main__.AgrTerminal object at 0x10fc67c88>, '#', <__main__.Root object at 0x10fc4ba58>, '-', <__main__.NominalizerTerminal object at 0x10fc4b518>, '-', <__main__.SemanticTerminal object at 0x10fc4b390>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic', 'a_2'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'a_2'}
we picked null_6 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: le#GRANDPARENT-e
full_pronunciation: le#GRANDPARENTi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 46.30000000000033
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 20.200000000000045
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_3
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_6
    triggers: set()
    weight: 10.200000000000001
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 14.099999999999998
line done
line done

---------------------

input line #131
input roots: [<__main__.Root object at 0x10fc67ba8>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 46.30000000000033..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 25.500000000000064..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 20.200000000000045..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 46.40000000000033..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 25.40000000000008..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 20.300000000000047..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 46.500000000000334..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'null_17'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'e_2', 'null_16', 'null_17'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_5 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'OFFSPRING_7', 'null_16', 'OFFSPRING_1', 'null_17'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc471d0>, '-', <__main__.AgrTerminal object at 0x10fc4b4a8>, '#', <__main__.Root object at 0x10fc47fd0>, '-', <__main__.NominalizerTerminal object at 0x10fc47e48>, '-', <__main__.SemanticTerminal object at 0x10fc47320>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'o_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_7: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'i_2', 'o_2'}
we picked null_14 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: le#OFFSPRING-e
full_pronunciation: li#OFFSPRINGe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 46.500000000000334
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 18.00000000000001
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_7
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 11.8
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 11.899999999999999
line done
line done

---------------------

input line #132
input roots: [<__main__.Root object at 0x10fc4bf28>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 25.50000000000008..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 46.500000000000334..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 25.300000000000075..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 25.400000000000077..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: BOOK in its selectional

now working with the word 'BOOK-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'BOOK_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi BOOK_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'BOOK_1', 'BOOK_3'}
done processing input, time to test
we selected the nominalizer with values: {'e_1'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc672b0>, '#', <__main__.Root object at 0x10fc58e80>, '-', <__main__.NominalizerTerminal object at 0x10fc58390>, '-', <__main__.SemanticTerminal object at 0x10fc58c50>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'e_1', '-definite', '+atomic'}
we picked una_1: no super match (neither decl nor L1-gender)
now spelling out BOOK terminal with values set()
we picked BOOK_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1'}
we picked null_7: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: uno#BOOK-o
full_pronunciation: una#BOOKe
vis_used:
Failure
VocabularyItem:
    pronunciation: una
    label: definite
    values: {'-definite', '+atomic'}
    diacritic: una_1
    triggers: set()
    weight: 10.700000000000001
VocabularyItem:
    pronunciation: BOOK
    label: BOOK
    values: set()
    diacritic: BOOK_1
    triggers: set()
    weight: 10.5
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_7
    triggers: {('i', frozenset({'-atomic'}))}
    weight: 10.299999999999999
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 12.0
line done
line done

---------------------

input line #133
input roots: [<__main__.Root object at 0x10fc433c8>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 25.600000000000083..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 46.600000000000335..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 25.500000000000078..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 25.60000000000008..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'OFFSPRING_3', 'o_1', 'OFFSPRING_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc3dbe0>, '-', <__main__.AgrTerminal object at 0x10fc58f28>, '#', <__main__.Root object at 0x10fc3d358>, '-', <__main__.NominalizerTerminal object at 0x10fc3dfd0>, '-', <__main__.SemanticTerminal object at 0x10fc3d5c0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_9: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'o_2', 'a'}
we picked null_14 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: uno#OFFSPRING-o
full_pronunciation: uno#OFFSPRINGa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 25.60000000000008
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 25.600000000000083
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_9
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 11.700000000000001
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 18.300000000000004
line done
line done

---------------------

input line #134
input roots: [<__main__.Root object at 0x10fc58c18>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 46.70000000000034..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 20.40000000000005..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 25.600000000000083..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 46.80000000000034..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 25.700000000000085..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 25.60000000000008..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 46.90000000000034..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 47.00000000000034..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 18.00000000000001..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 25.800000000000086..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'PIBLING_1', 'o_1', 'PIBLING_5'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc42f28>, '-', <__main__.AgrTerminal object at 0x10fc45940>, '#', <__main__.Root object at 0x10fc38908>, '-', <__main__.NominalizerTerminal object at 0x10fc05400>, '-', <__main__.SemanticTerminal object at 0x10fc42128>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_9: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'a_2', 'o'}
we picked null_6 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: lo#PIBLING-o
full_pronunciation: la#PIBLINGo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 47.00000000000034
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 25.500000000000064
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_9
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_6
    triggers: set()
    weight: 10.100000000000001
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 14.699999999999996
line done
line done

---------------------

input line #135
input roots: [<__main__.Root object at 0x10fc4b358>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 25.500000000000064..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 47.00000000000034..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 25.70000000000008..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 25.800000000000082..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: KEY in its selectional

now working with the word 'KEY-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'KEY_1', 'null_10'}
     what if we combine triggers with the otherwise identical vi KEY_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'KEY_3', 'KEY_1', 'e_3', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50a20>, '-', <__main__.AgrTerminal object at 0x10fc42550>, '#', <__main__.Root object at 0x10fc357b8>, '-', <__main__.NominalizerTerminal object at 0x10fc3ce48>, '-', <__main__.SemanticTerminal object at 0x10fc3bf98>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out KEY terminal with values set()
we picked KEY_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1', 'a_2'}
we picked null_22: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: una#KEY-e
full_pronunciation: una#KEYe
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: KEY to the selectional of the nominalizer whose values are {'e_1', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1', 'a_2'}
    selectional: {'FROG', 'BALL', 'CHILD', 'TOWER', 'PIBLING', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 13.599999999999994
    linear: (<__main__.NominalizerTerminal object at 0x10fc2aa20>,)
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 25.800000000000082
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 25.500000000000064
VocabularyItem:
    pronunciation: KEY
    label: KEY
    values: set()
    diacritic: KEY_1
    triggers: set()
    weight: 11.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1', 'a_2'}
    diacritic: null_22
    triggers: {('e', frozenset({'+atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 12.0
line done
line done

---------------------

input line #136
input roots: [<__main__.Root object at 0x10fc50710>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 47.10000000000034..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 20.50000000000005..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 25.900000000000087..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 47.200000000000344..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 26.00000000000009..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 26.400000000000084..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 47.300000000000345..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 47.40000000000035..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 18.100000000000012..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 26.10000000000009..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: BOOK in its selectional

now working with the word 'BOOK-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'BOOK_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi BOOK_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'BOOK_1', 'BOOK_3'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a898>, '-', <__main__.AgrTerminal object at 0x10fc50c88>, '#', <__main__.Root object at 0x10fc6a390>, '-', <__main__.NominalizerTerminal object at 0x10fc6a0b8>, '-', <__main__.SemanticTerminal object at 0x10fc6a2b0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'i_2', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BOOK terminal with values set()
we picked BOOK_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'i_2', 'o_2'}
we picked null_12 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: lo#BOOK-o
full_pronunciation: lo#BOOKo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: BOOK to the selectional of the nominalizer whose values are {'i_2', 'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'o_2'}
    selectional: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 13.099999999999996
    linear: (<__main__.NominalizerTerminal object at 0x10fc22eb8>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 47.40000000000035
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 26.10000000000009
VocabularyItem:
    pronunciation: BOOK
    label: BOOK
    values: set()
    diacritic: BOOK_4
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2', 'o_2'}
    diacritic: null_12
    triggers: set()
    weight: 10.0
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 14.699999999999996
line done
line done

---------------------

input line #137
input roots: [<__main__.Root object at 0x10fc36390>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 48.00000000000035..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 26.100000000000065..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 18.200000000000014..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 48.10000000000035..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 26.70000000000009..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 18.300000000000015..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 48.20000000000035..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: CLOWN in its selectional

now working with the word 'CLOWN-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'CLOWN_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi CLOWN_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CLOWN_2', 'null_15', 'i_1', 'null_14', 'CLOWN_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a2e8>, '-', <__main__.AgrTerminal object at 0x10fc6a0f0>, '#', <__main__.Root object at 0x10fc6a470>, '-', <__main__.NominalizerTerminal object at 0x10fc6a4e0>, '-', <__main__.SemanticTerminal object at 0x10fc6a400>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'a_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CLOWN terminal with values set()
we picked CLOWN_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i_2', 'a_2'}
we picked null_28: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#CLOWN-i
full_pronunciation: li#CLOWNi
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CLOWN to the selectional of the nominalizer whose values are {'i_2', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'a_2'}
    selectional: {'BOOK', 'CHILD', 'BALL', 'PIBLING', 'GRANDPARENT', 'CAR', 'OFFSPRING'}
    selection_strength: True
    weight: 12.299999999999997
    linear: (<__main__.NominalizerTerminal object at 0x10fc36a90>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 48.20000000000035
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 18.300000000000015
VocabularyItem:
    pronunciation: CLOWN
    label: CLOWN
    values: set()
    diacritic: CLOWN_1
    triggers: set()
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2', 'a_2'}
    diacritic: null_28
    triggers: {('i', frozenset({'-atomic'}))}
    weight: 10.1
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 14.099999999999998
line done
line done

---------------------

input line #138
input roots: [<__main__.Root object at 0x10fc6af28>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 48.80000000000035..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 26.200000000000067..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 20.60000000000005..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 48.900000000000354..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 26.800000000000093..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 20.700000000000053..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 49.000000000000355..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: BALL in its selectional

now working with the word 'BALL-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'BALL_1', 'null_6'}
     what if we combine triggers with the otherwise identical vi BALL_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'BALL_1', 'BALL_3', 'null_26', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc505c0>, '-', <__main__.AgrTerminal object at 0x10fc6a240>, '#', <__main__.Root object at 0x10fc50ba8>, '-', <__main__.NominalizerTerminal object at 0x10fc50390>, '-', <__main__.SemanticTerminal object at 0x10fc50400>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BALL terminal with values set()
we picked BALL_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i_2'}
we picked null_14: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: le#BALL-e
full_pronunciation: li#BALLe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 49.000000000000355
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 18.800000000000015
VocabularyItem:
    pronunciation: BALL
    label: BALL
    values: set()
    diacritic: BALL_1
    triggers: set()
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 11.600000000000001
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 11.899999999999999
line done
line done

---------------------

input line #139
input roots: [<__main__.Root object at 0x10fc3cf28>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 26.300000000000068..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 49.000000000000355..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 26.500000000000085..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 26.600000000000087..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'OFFSPRING_1', 'null_11', 'null_10', 'OFFSPRING_5'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc505f8>, '#', <__main__.Root object at 0x10fc42b00>, '-', <__main__.NominalizerTerminal object at 0x10fc42550>, '-', <__main__.SemanticTerminal object at 0x10fc14668>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite', '+atomic'}
we picked uno_1: no super match (neither decl nor L1-gender)
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_7: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: una#OFFSPRING-a
full_pronunciation: uno#OFFSPRINGe
vis_used:
Failure
VocabularyItem:
    pronunciation: uno
    label: definite
    values: {'-definite', '+atomic'}
    diacritic: uno_1
    triggers: set()
    weight: 9.500000000000002
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_7
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 16.80000000000001
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 12.5
line done
line done

---------------------

input line #140
input roots: [<__main__.Root object at 0x10fc506a0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 49.10000000000036..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 26.40000000000007..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 20.800000000000054..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 49.20000000000036..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 26.900000000000095..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 20.900000000000055..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 49.30000000000036..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: BALL in its selectional

now working with the word 'BALL-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'BALL_1', 'null_6'}
     what if we combine triggers with the otherwise identical vi BALL_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'BALL_1', 'BALL_3', 'null_26', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc42630>, '#', <__main__.Root object at 0x10fc3d828>, '-', <__main__.NominalizerTerminal object at 0x10fc412b0>, '-', <__main__.SemanticTerminal object at 0x10fc45e80>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked li_1: no super match (neither decl nor L1-gender)
now spelling out BALL terminal with values set()
we picked BALL_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: le#BALL-e
full_pronunciation: li#BALLe
vis_used:
Failure
VocabularyItem:
    pronunciation: li
    label: definite
    values: {'+definite', '-atomic'}
    diacritic: li_1
    triggers: set()
    weight: 10.3
VocabularyItem:
    pronunciation: BALL
    label: BALL
    values: set()
    diacritic: BALL_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 11.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 9.900000000000002
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 11.899999999999999
line done
line done

---------------------

input line #141
input roots: [<__main__.Root object at 0x10fc45f60>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 49.40000000000036..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 26.50000000000007..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 18.800000000000015..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 49.50000000000036..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 27.000000000000096..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 18.900000000000016..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 49.600000000000364..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: CLOWN in its selectional

now working with the word 'CLOWN-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'CLOWN_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi CLOWN_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CLOWN_2', 'null_15', 'i_1', 'null_14', 'CLOWN_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50dd8>, '#', <__main__.Root object at 0x10fc58198>, '-', <__main__.NominalizerTerminal object at 0x10fc58cc0>, '-', <__main__.SemanticTerminal object at 0x10fc58f60>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out CLOWN terminal with values set()
we picked CLOWN_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#CLOWN-i
full_pronunciation: l#CLOWNi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 49.600000000000364
VocabularyItem:
    pronunciation: CLOWN
    label: CLOWN
    values: set()
    diacritic: CLOWN_4
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 16.70000000000001
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 14.699999999999998
line done
line done

---------------------

input line #142
input roots: [<__main__.Root object at 0x10fc580f0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 26.600000000000072..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 49.600000000000364..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 26.700000000000088..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 26.80000000000009..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_2', 'a_1', 'PIBLING_1', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc58eb8>, '#', <__main__.Root object at 0x10fc436a0>, '-', <__main__.NominalizerTerminal object at 0x10fc43b00>, '-', <__main__.SemanticTerminal object at 0x10fc43940>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite', 'i_2', '+atomic'}
we picked una_1: no super match (neither decl nor L1-gender)
now spelling out PIBLING terminal with values set()
we picked PIBLING_7: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2'}
we picked null_14 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: una#PIBLING-a
full_pronunciation: una#PIBLINGe
vis_used:
Failure
VocabularyItem:
    pronunciation: una
    label: definite
    values: {'-definite', '+atomic'}
    diacritic: una_1
    triggers: set()
    weight: 10.600000000000001
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_7
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 11.500000000000002
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 12.4
line done
line done

---------------------

input line #143
input roots: [<__main__.Root object at 0x10fc43c88>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 49.700000000000365..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 21.000000000000057..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 27.100000000000097..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 49.80000000000037..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 27.2000000000001..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 26.90000000000009..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 49.90000000000037..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 50.00000000000037..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 19.000000000000018..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 27.3000000000001..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'PIBLING_1', 'o_1', 'PIBLING_5'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b2e8>, '-', <__main__.AgrTerminal object at 0x10fc47f28>, '#', <__main__.Root object at 0x10fc4b3c8>, '-', <__main__.NominalizerTerminal object at 0x10fc4bda0>, '-', <__main__.SemanticTerminal object at 0x10fc4be48>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'o_2', 'a'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: lo#PIBLING-o
full_pronunciation: lo#PIBLINGa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 50.00000000000037
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 27.3000000000001
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.200000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 9.800000000000002
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 18.400000000000006
line done
line done

---------------------

input line #144
input roots: [<__main__.Root object at 0x10fc47da0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 27.3000000000001..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 50.00000000000037..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 27.000000000000092..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 27.100000000000094..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'PIBLING_1', 'o_1', 'PIBLING_5'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67fd0>, '-', <__main__.AgrTerminal object at 0x10fc4b860>, '#', <__main__.Root object at 0x10fc6f470>, '-', <__main__.NominalizerTerminal object at 0x10fc6f400>, '-', <__main__.SemanticTerminal object at 0x10fc6f2e8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_8: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: uno#PIBLING-o
full_pronunciation: una#PIBLINGa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 27.100000000000094
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 26.600000000000072
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_8
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 16.60000000000001
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 18.300000000000004
line done
line done

---------------------

input line #145
input roots: [<__main__.Root object at 0x10fc67ef0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 50.10000000000037..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 21.10000000000006..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 27.4000000000001..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 50.20000000000037..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 27.500000000000103..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 27.100000000000094..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 50.300000000000374..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 50.400000000000375..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 19.10000000000002..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 27.600000000000104..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'GRANDPARENT_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'GRANDPARENT_1', 'GRANDPARENT_2'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4bfd0>, '-', <__main__.AgrTerminal object at 0x10fc673c8>, '#', <__main__.Root object at 0x10fc4b940>, '-', <__main__.NominalizerTerminal object at 0x10fc4b080>, '-', <__main__.SemanticTerminal object at 0x10fc4b390>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_6: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'a_2', 'a'}
we picked null_16 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: lo#GRANDPARENT-o
full_pronunciation: la#GRANDPARENTa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 50.400000000000375
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 26.50000000000007
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_6
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 10.3
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1', 'a_2'}
    diacritic: null_16
    triggers: set()
    weight: 11.0
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 18.200000000000003
line done
line done

---------------------

input line #146
input roots: [<__main__.Root object at 0x10fc67c88>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 27.700000000000106..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 50.400000000000375..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 27.200000000000095..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 27.300000000000097..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'PIBLING_1', 'o_1', 'PIBLING_5'}
done processing input, time to test
we selected the nominalizer with values: {'e_1'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4ba58>, '#', <__main__.Root object at 0x10fc47c18>, '-', <__main__.NominalizerTerminal object at 0x10fc477f0>, '-', <__main__.SemanticTerminal object at 0x10fc47f28>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'e_1', '-definite', '+atomic'}
we picked una_1: no super match (neither decl nor L1-gender)
now spelling out PIBLING terminal with values set()
we picked PIBLING_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1', 'null', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: uno#PIBLING-o
full_pronunciation: una#PIBLINGa
vis_used:
Failure
VocabularyItem:
    pronunciation: una
    label: definite
    values: {'-definite', '+atomic'}
    diacritic: una_1
    triggers: set()
    weight: 10.500000000000002
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.100000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 16.500000000000007
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 18.1
line done
line done

---------------------

input line #147
input roots: [<__main__.Root object at 0x10fc471d0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 50.50000000000038..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 21.20000000000006..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 26.50000000000007..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 50.60000000000038..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 26.600000000000072..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 27.400000000000098..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 50.70000000000038..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 50.80000000000038..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 19.20000000000002..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 26.700000000000074..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: KEY in its selectional

now working with the word 'KEY-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'KEY_1', 'null_10'}
     what if we combine triggers with the otherwise identical vi KEY_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'KEY_3', 'KEY_1', 'e_3', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc58438>, '-', <__main__.AgrTerminal object at 0x10fc43198>, '#', <__main__.Root object at 0x10fc585c0>, '-', <__main__.NominalizerTerminal object at 0x10fc58ac8>, '-', <__main__.SemanticTerminal object at 0x10fc58a58>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out KEY terminal with values set()
we picked KEY_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: la#KEY-e
full_pronunciation: la#KEYe
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: KEY to the selectional of the nominalizer whose values are {'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'a_2'}
    selectional: {'FROG', 'CHILD', 'BALL', 'PIBLING', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 26.900000000000134
    linear: (<__main__.NominalizerTerminal object at 0x10fc05f28>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'CHILD', 'BALL', 'FROG', 'PIBLING', 'CAR', 'KEY'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_6, triggers = set(), weight = 10.100000000000001..already existed

create_vi: tried nominalizer: null_7, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.299999999999999..already existed

create_vi: tried nominalizer: null_26, triggers = {('e', frozenset({'-atomic'}))}, weight = 10.899999999999999..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'PIBLING', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_14, triggers = set(), weight = 11.500000000000002..already existed

create_vi: tried nominalizer: null_15, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.599999999999998..already existed
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 50.80000000000038
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 26.700000000000074
VocabularyItem:
    pronunciation: KEY
    label: KEY
    values: set()
    diacritic: KEY_4
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'})), ('e', frozenset({'+atomic'}))}
    weight: 10.3
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 16.400000000000006
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 12.4
line done
line done

---------------------

input line #148
input roots: [<__main__.Root object at 0x10fc582e8>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 51.40000000000038..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 21.30000000000006..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 27.300000000000075..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 51.500000000000384..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 27.400000000000077..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 27.5000000000001..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 51.600000000000385..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 51.70000000000039..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 19.300000000000022..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 27.500000000000078..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: MILKCOW in its selectional

now working with the word 'MILKCOW-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'MILKCOW_1'}
     what if we combine triggers with the otherwise identical vi MILKCOW_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'MILKCOW_1', 'MILKCOW_2', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc3d470>, '-', <__main__.AgrTerminal object at 0x10fc58320>, '#', <__main__.Root object at 0x10fc45f98>, '-', <__main__.NominalizerTerminal object at 0x10fc45860>, '-', <__main__.SemanticTerminal object at 0x10fc3d828>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MILKCOW terminal with values set()
we picked MILKCOW_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: la#MILKCOW-a
full_pronunciation: lo#MILKCOWe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 51.70000000000039
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 27.700000000000106
VocabularyItem:
    pronunciation: MILKCOW
    label: MILKCOW
    values: set()
    diacritic: MILKCOW_3
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 9.700000000000003
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 12.9
line done
line done

---------------------

input line #149
input roots: [<__main__.Root object at 0x10fc3dda0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 51.70000000000039..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 21.400000000000063..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 27.60000000000008..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 51.80000000000039..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 27.70000000000008..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 27.6000000000001..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 51.90000000000039..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 52.00000000000039..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 19.400000000000023..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 27.800000000000082..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_2', 'a_1', 'PIBLING_1', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc42198>, '-', <__main__.AgrTerminal object at 0x10fc58048>, '#', <__main__.Root object at 0x10fc502b0>, '-', <__main__.NominalizerTerminal object at 0x10fc50dd8>, '-', <__main__.SemanticTerminal object at 0x10fc185c0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1', 'a_2'}
we picked null_11: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#PIBLING-a
full_pronunciation: la#PIBLINGa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: PIBLING to the selectional of the nominalizer whose values are {'e_1', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1', 'a_2'}
    selectional: {'FROG', 'BALL', 'CHILD', 'TOWER', 'PIBLING', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 14.299999999999994
    linear: (<__main__.NominalizerTerminal object at 0x10fc2aa20>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 52.00000000000039
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 27.800000000000082
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_1
    triggers: set()
    weight: 10.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_11
    triggers: {('a', frozenset({'+atomic'}))}
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 18.200000000000003
line done
line done

---------------------

input line #150
input roots: [<__main__.Root object at 0x10fc05630>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 52.60000000000039..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 28.400000000000084..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 21.500000000000064..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 52.700000000000394..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 27.700000000000106..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 21.600000000000065..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 52.800000000000395..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'PIBLING_1', 'null_6'}
     what if we combine triggers with the otherwise identical vi PIBLING_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_5 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'PIBLING_3', 'PIBLING_1', 'null_26', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc357b8>, '-', <__main__.AgrTerminal object at 0x10fc3bf28>, '#', <__main__.Root object at 0x10fc2f048>, '-', <__main__.NominalizerTerminal object at 0x10fc36240>, '-', <__main__.SemanticTerminal object at 0x10fc363c8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic', 'a_2'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'a_2'}
we picked null_16 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: le#PIBLING-e
full_pronunciation: le#PIBLINGe
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: PIBLING to the selectional of the nominalizer whose values are {'e_1', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1', 'a_2'}
    selectional: {'FROG', 'BALL', 'CHILD', 'TOWER', 'PIBLING', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 14.499999999999993
    linear: (<__main__.NominalizerTerminal object at 0x10fc2aa20>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 52.800000000000395
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 21.600000000000065
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_2
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 9.9
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1', 'a_2'}
    diacritic: null_16
    triggers: set()
    weight: 10.9
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 11.899999999999999
line done
line done

---------------------

input line #151
input roots: [<__main__.Root object at 0x10fc05400>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 53.4000000000004..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 28.500000000000085..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 19.500000000000025..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 53.5000000000004..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 27.800000000000107..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 19.600000000000026..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 53.6000000000004..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: CASTLE in its selectional

now working with the word 'CASTLE-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CASTLE_1', 'null_12', 'null_13', 'i_1'}

create_vi: made CASTLE: CASTLE_3, triggers = {('null', frozenset()), ('i', frozenset({'-atomic'}))}, weight = 10.0
     what if we combine triggers with the otherwise identical vi CASTLE_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?

create_vi: made CASTLE: CASTLE_4, triggers = {('null', frozenset()), ('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}, weight = 10.0
     -> created a new vi CASTLE_4 	spelling out CASTLE: set() 		 triggering {('null', frozenset()), ('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1', 'CASTLE_1', 'CASTLE_3'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a828>, '#', <__main__.Root object at 0x10fc6a400>, '-', <__main__.NominalizerTerminal object at 0x10fc6a4e0>, '-', <__main__.SemanticTerminal object at 0x10fc6af28>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out CASTLE terminal with values set()
we picked CASTLE_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#CASTLE-i
full_pronunciation: l#CASTLEi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 53.6000000000004
VocabularyItem:
    pronunciation: CASTLE
    label: CASTLE
    values: set()
    diacritic: CASTLE_3
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 16.900000000000006
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 14.699999999999998
line done
line done

---------------------

input line #152
input roots: [<__main__.Root object at 0x10fc4bc88>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 53.6000000000004..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 28.600000000000087..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 19.700000000000028..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 53.7000000000004..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 27.90000000000011..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 19.80000000000003..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 53.8000000000004..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: BOOK in its selectional

now working with the word 'BOOK-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'BOOK_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi BOOK_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_15', 'BOOK_2', 'BOOK_1', 'i_1', 'null_14'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6fc88>, '-', <__main__.AgrTerminal object at 0x10fc6a898>, '#', <__main__.Root object at 0x10fc58320>, '-', <__main__.NominalizerTerminal object at 0x10fc58128>, '-', <__main__.SemanticTerminal object at 0x10fc28128>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic', 'o_2'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BOOK terminal with values set()
we picked BOOK_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: li#BOOK-i
full_pronunciation: le#BOOKi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 53.8000000000004
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 22.100000000000065
VocabularyItem:
    pronunciation: BOOK
    label: BOOK
    values: set()
    diacritic: BOOK_3
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 10.4
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 9.600000000000003
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 14.699999999999998
line done
line done

---------------------

input line #153
input roots: [<__main__.Root object at 0x10fc58f98>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 28.00000000000011..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 53.8000000000004..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 27.700000000000102..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 27.800000000000104..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: BOOK in its selectional

now working with the word 'BOOK-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'BOOK_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi BOOK_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'BOOK_1', 'BOOK_3'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc43f60>, '-', <__main__.AgrTerminal object at 0x10fc58860>, '#', <__main__.Root object at 0x10fc43ba8>, '-', <__main__.NominalizerTerminal object at 0x10fc43c88>, '-', <__main__.SemanticTerminal object at 0x10fc43940>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BOOK terminal with values set()
we picked BOOK_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'e_1', 'o_2'}
we picked null_20 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: uno#BOOK-o
full_pronunciation: uno#BOOKo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: BOOK to the selectional of the nominalizer whose values are {'e_1', 'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1', 'o_2'}
    selectional: {'PIBLING', 'CHILD', 'OFFSPRING'}
    selection_strength: True
    weight: 11.899999999999999
    linear: (<__main__.NominalizerTerminal object at 0x10fc3d400>,)
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 27.800000000000104
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 28.00000000000011
VocabularyItem:
    pronunciation: BOOK
    label: BOOK
    values: set()
    diacritic: BOOK_4
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.5
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1', 'o_2'}
    diacritic: null_20
    triggers: set()
    weight: 10.1
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 15.699999999999994
line done
line done

---------------------

input line #154
input roots: [<__main__.Root object at 0x10fc580f0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 28.700000000000088..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 53.900000000000404..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 28.400000000000105..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 28.500000000000107..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: CAR in its selectional

now working with the word 'CAR-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'CAR_1'}
     what if we combine triggers with the otherwise identical vi CAR_2 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'null_10', 'CAR_1', 'null_11', 'CAR_3'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc43278>, '#', <__main__.Root object at 0x10fc45160>, '-', <__main__.NominalizerTerminal object at 0x10fc45518>, '-', <__main__.SemanticTerminal object at 0x10fc45358>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite', '+atomic'}
we picked una_1: no super match (neither decl nor L1-gender)
now spelling out CAR terminal with values set()
we picked CAR_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: una#CAR-a
full_pronunciation: una#CARa
vis_used:
Successful derivation!
VocabularyItem:
    pronunciation: una
    label: definite
    values: {'-definite', '+atomic'}
    diacritic: una_1
    triggers: set()
    weight: 10.400000000000002
VocabularyItem:
    pronunciation: CAR
    label: CAR
    values: set()
    diacritic: CAR_2
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 11.5
     what if we combine triggers with the otherwise identical vi CAR_3 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 16.800000000000004
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 18.800000000000004
line done
line done

---------------------

input line #155
input roots: [<__main__.Root object at 0x10fc457f0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 54.000000000000405..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 28.80000000000009..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 19.90000000000003..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 54.100000000000406..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 28.60000000000011..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 20.000000000000032..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 54.20000000000041..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: CASTLE in its selectional

now working with the word 'CASTLE-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CASTLE_1', 'null_12', 'null_13', 'i_1'}
     what if we combine triggers with the otherwise identical vi CASTLE_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1', 'CASTLE_1', 'CASTLE_3'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a240>, '-', <__main__.AgrTerminal object at 0x10fc45860>, '#', <__main__.Root object at 0x10fc6a978>, '-', <__main__.NominalizerTerminal object at 0x10fc6aeb8>, '-', <__main__.SemanticTerminal object at 0x10fc6acf8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic', 'a_2'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CASTLE terminal with values set()
we picked CASTLE_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: li#CASTLE-i
full_pronunciation: le#CASTLEe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 54.20000000000041
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 22.000000000000064
VocabularyItem:
    pronunciation: CASTLE
    label: CASTLE
    values: set()
    diacritic: CASTLE_2
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 17.300000000000004
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 12.399999999999999
line done
line done

---------------------

input line #156
input roots: [<__main__.Root object at 0x10fc281d0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 54.20000000000041..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 22.000000000000064..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 28.700000000000113..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 54.30000000000041..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 28.800000000000114..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 28.600000000000108..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 54.40000000000041..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 54.50000000000041..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 20.100000000000033..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 28.900000000000116..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CLOWN in its selectional

now working with the word 'CLOWN-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CLOWN_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CLOWN_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'CLOWN_3', 'o_1', 'CLOWN_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc3d470>, '-', <__main__.AgrTerminal object at 0x10fc6a080>, '#', <__main__.Root object at 0x10fc67128>, '-', <__main__.NominalizerTerminal object at 0x10fc3d128>, '-', <__main__.SemanticTerminal object at 0x10fc3dbe0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CLOWN terminal with values set()
we picked CLOWN_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'e_1', 'o_2'}
we picked null_20 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: lo#CLOWN-o
full_pronunciation: lo#CLOWNo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CLOWN to the selectional of the nominalizer whose values are {'e_1', 'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1', 'o_2'}
    selectional: {'PIBLING', 'BOOK', 'CHILD', 'OFFSPRING'}
    selection_strength: True
    weight: 11.999999999999998
    linear: (<__main__.NominalizerTerminal object at 0x10fc3d400>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 54.50000000000041
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 28.900000000000116
VocabularyItem:
    pronunciation: CLOWN
    label: CLOWN
    values: set()
    diacritic: CLOWN_4
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1', 'o_2'}
    diacritic: null_20
    triggers: set()
    weight: 10.6
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 16.299999999999997
line done
line done

---------------------

input line #157
input roots: [<__main__.Root object at 0x10fc3d5c0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 28.90000000000009..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 55.10000000000041..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 28.70000000000011..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 28.80000000000011..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: FROG in its selectional

now working with the word 'FROG-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi FROG_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_2', 'a_1', 'FROG_1', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67f98>, '#', <__main__.Root object at 0x10fc67c50>, '-', <__main__.NominalizerTerminal object at 0x10fc67080>, '-', <__main__.SemanticTerminal object at 0x10fc67550>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite', '+atomic'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out FROG terminal with values set()
we picked FROG_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: una#FROG-a
full_pronunciation: un#FROGa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 28.80000000000011
VocabularyItem:
    pronunciation: FROG
    label: FROG
    values: set()
    diacritic: FROG_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 17.200000000000003
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 19.400000000000006
line done
line done

---------------------

input line #158
input roots: [<__main__.Root object at 0x10fc67470>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 55.200000000000415..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 22.100000000000065..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 29.500000000000117..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 55.300000000000416..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 29.60000000000012..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 28.80000000000011..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 55.40000000000042..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 55.50000000000042..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 20.200000000000035..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 29.70000000000012..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: MOUSE in its selectional

now working with the word 'MOUSE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'MOUSE_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi MOUSE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'MOUSE_2', 'MOUSE_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc47cf8>, '-', <__main__.AgrTerminal object at 0x10fc20b38>, '#', <__main__.Root object at 0x10fc47a90>, '-', <__main__.NominalizerTerminal object at 0x10fc471d0>, '-', <__main__.SemanticTerminal object at 0x10fc47ef0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MOUSE terminal with values set()
we picked MOUSE_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: lo#MOUSE-o
full_pronunciation: la#MOUSEo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 55.50000000000042
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 28.90000000000009
VocabularyItem:
    pronunciation: MOUSE
    label: MOUSE
    values: set()
    diacritic: MOUSE_3
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 17.1
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 16.9
line done
line done

---------------------

input line #159
input roots: [<__main__.Root object at 0x10fc055c0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 55.50000000000042..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 22.200000000000067..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 29.80000000000012..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 55.60000000000042..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 29.900000000000123..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 28.900000000000112..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 55.70000000000042..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 55.80000000000042..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 20.300000000000036..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 30.000000000000124..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CHILD_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'CHILD_1', 'null_9', 'o_1', 'CHILD_3'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc22a20>, '-', <__main__.AgrTerminal object at 0x10fc67390>, '#', <__main__.Root object at 0x10fc2d588>, '-', <__main__.NominalizerTerminal object at 0x10fc2dd68>, '-', <__main__.SemanticTerminal object at 0x10fc22c88>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_9: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: lo#CHILD-o
full_pronunciation: lo#CHILDo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CHILD to the selectional of the nominalizer whose values are {'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'o_2'}
    selectional: {'MOUSE', 'CHILD', 'BOOK', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 31.300000000000196
    linear: (<__main__.NominalizerTerminal object at 0x10fc08908>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'PIBLING', 'CHILD'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_6, triggers = set(), weight = 10.200000000000001..already existed

create_vi: tried nominalizer: null_7, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.399999999999999..already existed

create_vi: tried nominalizer: null_26, triggers = {('e', frozenset({'-atomic'}))}, weight = 10.999999999999998..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'CLOWN', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_14, triggers = set(), weight = 11.600000000000001..already existed

create_vi: tried nominalizer: null_15, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.699999999999998..already existed
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 55.80000000000042
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 30.000000000000124
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_9
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 17.0
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 16.9
line done
line done

---------------------

input line #160
input roots: [<__main__.Root object at 0x10fc228d0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 56.400000000000425..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 22.300000000000068..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 28.90000000000009..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 56.500000000000426..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 29.000000000000092..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 29.000000000000114..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 56.60000000000043..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 56.70000000000043..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 20.400000000000038..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 29.100000000000094..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'CHILD_1', 'a_1'}
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CHILD_1', 'a_1', 'CHILD_2', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'e_1'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc18320>, '#', <__main__.Root object at 0x10fc47fd0>, '-', <__main__.NominalizerTerminal object at 0x10fc47cf8>, '-', <__main__.SemanticTerminal object at 0x10fc471d0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', 'e_1', '+atomic'}
we picked la_1: no super match (neither decl nor L1-gender)
now spelling out CHILD terminal with values set()
we picked CHILD_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'e_1', 'null'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: la#CHILD-a
full_pronunciation: la#CHILDo
vis_used:
Failure
VocabularyItem:
    pronunciation: la
    label: definite
    values: {'+definite', '+atomic'}
    diacritic: la_1
    triggers: set()
    weight: 10.3
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_3
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 17.5
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 17.4
line done
line done

---------------------

input line #161
input roots: [<__main__.Root object at 0x10fc477f0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 30.600000000000126..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 56.80000000000043..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 29.100000000000115..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 29.200000000000117..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FLOWER in its selectional

now working with the word 'FLOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19', 'FLOWER_1'}
     what if we combine triggers with the otherwise identical vi FLOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FLOWER_3', 'e_3', 'null_19', 'FLOWER_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67c50>, '-', <__main__.AgrTerminal object at 0x10fc38470>, '#', <__main__.Root object at 0x10fc67668>, '-', <__main__.NominalizerTerminal object at 0x10fc67b00>, '-', <__main__.SemanticTerminal object at 0x10fc67550>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FLOWER terminal with values set()
we picked FLOWER_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: uno#FLOWER-e
full_pronunciation: una#FLOWERo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 29.200000000000117
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 29.100000000000094
VocabularyItem:
    pronunciation: FLOWER
    label: FLOWER
    values: set()
    diacritic: FLOWER_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 10.100000000000005
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 17.299999999999997
line done
line done

---------------------

input line #162
input roots: [<__main__.Root object at 0x10fc22940>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 56.90000000000043..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 29.100000000000094..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 20.50000000000004..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 57.00000000000043..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 30.700000000000127..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 20.60000000000004..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 57.100000000000435..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'OFFSPRING_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_5 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_15', 'OFFSPRING_2', 'i_1', 'null_14', 'OFFSPRING_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc207b8>, '#', <__main__.Root object at 0x10fc3dda0>, '-', <__main__.NominalizerTerminal object at 0x10fc3d470>, '-', <__main__.SemanticTerminal object at 0x10fc3d128>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_5: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: li#OFFSPRING-i
full_pronunciation: l#OFFSPRINGe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 57.100000000000435
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_5
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 10.4
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 17.4
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 12.299999999999999
line done
line done

---------------------

input line #163
input roots: [<__main__.Root object at 0x10fc20ef0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 57.100000000000435..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 29.200000000000095..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 20.700000000000042..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 57.200000000000436..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 30.80000000000013..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 20.800000000000043..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 57.30000000000044..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'OFFSPRING_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_5 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_15', 'OFFSPRING_2', 'i_1', 'null_14', 'OFFSPRING_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc673c8>, '#', <__main__.Root object at 0x10fc427b8>, '-', <__main__.NominalizerTerminal object at 0x10fc428d0>, '-', <__main__.SemanticTerminal object at 0x10fc42a20>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked le_1: no super match (neither decl nor L1-gender)
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_9: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: li#OFFSPRING-i
full_pronunciation: le#OFFSPRINGe
vis_used:
Failure
VocabularyItem:
    pronunciation: le
    label: definite
    values: {'+definite', '-atomic'}
    diacritic: le_1
    triggers: set()
    weight: 10.700000000000001
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_9
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 17.299999999999997
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 12.2
line done
line done

---------------------

input line #164
input roots: [<__main__.Root object at 0x10fc42cc0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 30.90000000000013..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 57.40000000000044..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 29.200000000000117..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 29.300000000000118..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'PIBLING_1', 'o_1', 'PIBLING_5'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a278>, '-', <__main__.AgrTerminal object at 0x10fc43f60>, '#', <__main__.Root object at 0x10fc6a6a0>, '-', <__main__.NominalizerTerminal object at 0x10fc6a588>, '-', <__main__.SemanticTerminal object at 0x10fc6aa20>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_7: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: uno#PIBLING-o
full_pronunciation: una#PIBLINGo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 29.300000000000118
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 29.200000000000095
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_7
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 17.199999999999996
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 17.299999999999997
line done
line done

---------------------

input line #165
input roots: [<__main__.Root object at 0x10fc457f0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 29.200000000000095..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 57.50000000000044..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 29.300000000000118..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 29.40000000000012..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'CHILD_1', 'a_1'}
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CHILD_1', 'a_1', 'CHILD_2', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a2b0>, '-', <__main__.AgrTerminal object at 0x10fc6a748>, '#', <__main__.Root object at 0x10fc3bf28>, '-', <__main__.NominalizerTerminal object at 0x10fc6a5f8>, '-', <__main__.SemanticTerminal object at 0x10fc6ae10>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'o_2', 'a'}
we picked null_20 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: una#CHILD-a
full_pronunciation: uno#CHILDa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 29.40000000000012
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 30.90000000000013
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_2
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 11.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1', 'o_2'}
    diacritic: null_20
    triggers: set()
    weight: 11.1
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 19.500000000000007
line done
line done

---------------------

input line #166
input roots: [<__main__.Root object at 0x10fc6a470>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 57.60000000000044..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 29.300000000000097..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 22.40000000000007..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 57.70000000000044..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 30.90000000000013..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 22.50000000000007..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 57.800000000000445..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'OFFSPRING_1', 'null_6'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_5 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'OFFSPRING_1', 'OFFSPRING_7', 'null_26', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc584a8>, '#', <__main__.Root object at 0x10fc583c8>, '-', <__main__.NominalizerTerminal object at 0x10fc589e8>, '-', <__main__.SemanticTerminal object at 0x10fc58cf8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_7: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: le#OFFSPRING-e
full_pronunciation: l#OFFSPRINGe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 57.800000000000445
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_7
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 17.099999999999994
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 12.2
line done
line done

---------------------

input line #167
input roots: [<__main__.Root object at 0x10fc581d0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 57.800000000000445..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 29.400000000000098..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 20.900000000000045..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 57.900000000000446..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 31.00000000000013..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 21.000000000000046..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 58.00000000000045..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: CASTLE in its selectional

now working with the word 'CASTLE-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CASTLE_1', 'null_12', 'null_13', 'i_1'}
     what if we combine triggers with the otherwise identical vi CASTLE_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1', 'CASTLE_1', 'CASTLE_3'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc36320>, '-', <__main__.AgrTerminal object at 0x10fc58fd0>, '#', <__main__.Root object at 0x10fc58400>, '-', <__main__.NominalizerTerminal object at 0x10fc2df28>, '-', <__main__.SemanticTerminal object at 0x10fc50da0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'o_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CASTLE terminal with values set()
we picked CASTLE_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: li#CASTLE-i
full_pronunciation: li#CASTLEi
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CASTLE to the selectional of the nominalizer whose values are {'i_2', 'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'o_2'}
    selectional: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'GRANDPARENT', 'CASTLE', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 13.999999999999995
    linear: (<__main__.NominalizerTerminal object at 0x10fc22eb8>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 58.00000000000045
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 21.000000000000046
VocabularyItem:
    pronunciation: CASTLE
    label: CASTLE
    values: set()
    diacritic: CASTLE_2
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 9.8
     what if we combine triggers with the otherwise identical vi CASTLE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 16.999999999999993
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 14.999999999999996
line done
line done

---------------------

input line #168
input roots: [<__main__.Root object at 0x10fc36710>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 58.60000000000045..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 29.5000000000001..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 21.600000000000048..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 58.70000000000045..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 31.100000000000133..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 21.70000000000005..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 58.80000000000045..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: BOOK in its selectional

now working with the word 'BOOK-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'BOOK_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi BOOK_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_15', 'BOOK_2', 'BOOK_1', 'i_1', 'null_14'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6abe0>, '-', <__main__.AgrTerminal object at 0x10fc3bf98>, '#', <__main__.Root object at 0x10fc6a470>, '-', <__main__.NominalizerTerminal object at 0x10fc6a048>, '-', <__main__.SemanticTerminal object at 0x10fc6ac50>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic', 'a_2'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BOOK terminal with values set()
we picked BOOK_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i', 'e_1', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#BOOK-i
full_pronunciation: le#BOOKi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 58.80000000000045
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 22.50000000000007
VocabularyItem:
    pronunciation: BOOK
    label: BOOK
    values: set()
    diacritic: BOOK_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 10.000000000000005
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 15.599999999999996
line done
line done

---------------------

input line #169
input roots: [<__main__.Root object at 0x10fc58320>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 58.80000000000045..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 29.6000000000001..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 22.50000000000007..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 58.90000000000045..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 31.200000000000134..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 22.600000000000072..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 59.000000000000455..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'null_17'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'GRANDPARENT_1', 'null_17'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_3 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'GRANDPARENT_7', 'null_17', 'GRANDPARENT_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a710>, '-', <__main__.AgrTerminal object at 0x10fc58a58>, '#', <__main__.Root object at 0x10fc6ac88>, '-', <__main__.NominalizerTerminal object at 0x10fc6a668>, '-', <__main__.SemanticTerminal object at 0x10fc6a1d0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic', 'o_2'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1', 'o_2'}
we picked null_30: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: le#GRANDPARENT-e
full_pronunciation: le#GRANDPARENTi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 59.000000000000455
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 22.600000000000072
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_1
    triggers: set()
    weight: 9.600000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1', 'o_2'}
    diacritic: null_30
    triggers: {('i', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 15.499999999999996
line done
line done

---------------------

input line #170
input roots: [<__main__.Root object at 0x10fc6ab70>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 59.000000000000455..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 29.700000000000102..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 21.80000000000005..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 59.100000000000456..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 31.300000000000136..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 21.900000000000052..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 59.20000000000046..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'CHILD_1', 'i_1'}
     what if we combine triggers with the otherwise identical vi CHILD_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CHILD_1', 'null_12', 'null_13', 'CHILD_4', 'i_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc42b00>, '-', <__main__.AgrTerminal object at 0x10fc6aa58>, '#', <__main__.Root object at 0x10fc42208>, '-', <__main__.NominalizerTerminal object at 0x10fc42710>, '-', <__main__.SemanticTerminal object at 0x10fc42c50>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_6: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'i_2'}
we picked null_14 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#CHILD-i
full_pronunciation: li#CHILDi
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CHILD to the selectional of the nominalizer whose values are {'i_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2'}
    selectional: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'CLOWN', 'OFFSPRING'}
    selection_strength: True
    weight: 11.599999999999994
    linear: (<__main__.NominalizerTerminal object at 0x10fc0ecc0>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'a_2'} as values: {'PIBLING', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'a_2'}

create_vi: tried nominalizer: null_24, triggers = set(), weight = 10.5..already existed

create_vi: tried nominalizer: null_25, triggers = {('a', frozenset({'+atomic'}))}, weight = 10.1..already existed

create_vi: made nominalizer: null_33, triggers = {('e', frozenset({'+atomic'}))}, weight = 10.0
....made the new vi: VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2', 'a_2'}
    diacritic: null_33
    triggers: {('e', frozenset({'+atomic'}))}
    weight: 10.0
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'o_2'} as values: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'CLOWN', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'o_2'}

create_vi: tried nominalizer: null_12, triggers = set(), weight = 10.6..already existed

create_vi: tried nominalizer: null_18, triggers = {('o', frozenset({'+atomic'}))}, weight = 10.1..already existed

create_vi: tried nominalizer: null_23, triggers = {('e', frozenset({'+atomic'}))}, weight = 10.1..already existed
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 59.20000000000046
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 21.900000000000052
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_6
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 11.600000000000001
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 15.499999999999996
line done
line done

---------------------

input line #171
input roots: [<__main__.Root object at 0x10fc425c0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 31.400000000000137..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 59.80000000000046..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 29.40000000000012..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 29.50000000000012..already existed
  we're in a functional word...
  - nominalizer's values are now {'e_1', 'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'o_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_20'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_20', 'null_21'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'o_1', 'null_20', 'null_21'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_20', 'PIBLING_1', 'o_1', 'null_21', 'PIBLING_5'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc20ef0>, '-', <__main__.AgrTerminal object at 0x10fc2da90>, '#', <__main__.Root object at 0x10fc67128>, '-', <__main__.NominalizerTerminal object at 0x10fc673c8>, '-', <__main__.SemanticTerminal object at 0x10fc385c0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i_2', 'o_2'}
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: uno#PIBLING-o
full_pronunciation: uno#PIBLINGo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: PIBLING to the selectional of the nominalizer whose values are {'i_2', 'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'o_2'}
    selectional: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'GRANDPARENT', 'CASTLE', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 14.799999999999994
    linear: (<__main__.NominalizerTerminal object at 0x10fc22eb8>,)
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 29.50000000000012
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 31.400000000000137
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_1
    triggers: set()
    weight: 11.4
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 17.499999999999993
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 17.299999999999997
line done
line done

---------------------

input line #172
input roots: [<__main__.Root object at 0x10fc3d828>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 59.90000000000046..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 29.800000000000104..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 22.600000000000072..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 60.00000000000046..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 32.000000000000135..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 22.700000000000074..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 60.10000000000046..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'OFFSPRING_1', 'null_6'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_5 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'OFFSPRING_1', 'OFFSPRING_7', 'null_26', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'e_1'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67048>, '-', <__main__.AgrTerminal object at 0x10fc3d710>, '#', <__main__.Root object at 0x10fc10780>, '-', <__main__.NominalizerTerminal object at 0x10fc67908>, '-', <__main__.SemanticTerminal object at 0x10fc67d68>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1'}
we picked null_26: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: le#OFFSPRING-e
full_pronunciation: le#OFFSPRINGe
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: OFFSPRING to the selectional of the nominalizer whose values are {'e_1'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1'}
    selectional: {'CHILD', 'FROG', 'BALL', 'PIBLING', 'TOWER', 'CAR', 'KEY', 'OFFSPRING'}
    selection_strength: True
    weight: 11.499999999999995
    linear: (<__main__.NominalizerTerminal object at 0x10fbeb2e8>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'a_2'} as values: {'CHILD', 'BALL', 'FROG', 'PIBLING', 'CAR', 'KEY', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'a_2'}

create_vi: tried nominalizer: null_17, triggers = {('e', frozenset({'-atomic'}))}, weight = 10.2..already existed

create_vi: made nominalizer: null_34, triggers = {('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}, weight = 10.0
....made the new vi: VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1', 'a_2'}
    diacritic: null_34
    triggers: {('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.0

create_vi: made nominalizer: null_35, triggers = {('e', frozenset({'-atomic'})), ('e', frozenset({'+atomic'}))}, weight = 10.0
....made the new vi: VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1', 'a_2'}
    diacritic: null_35
    triggers: {('e', frozenset({'-atomic'})), ('e', frozenset({'+atomic'}))}
    weight: 10.0
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'o_2'} as values: {'PIBLING', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'o_2'}

create_vi: tried nominalizer: null_31, triggers = {('e', frozenset({'-atomic'}))}, weight = 10.1..already existed

create_vi: made nominalizer: null_36, triggers = {('o', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}, weight = 10.0
....made the new vi: VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1', 'o_2'}
    diacritic: null_36
    triggers: {('o', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.0

create_vi: made nominalizer: null_37, triggers = {('e', frozenset({'-atomic'})), ('e', frozenset({'+atomic'}))}, weight = 10.0
....made the new vi: VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1', 'o_2'}
    diacritic: null_37
    triggers: {('e', frozenset({'-atomic'})), ('e', frozenset({'+atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 60.10000000000046
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 22.700000000000074
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_1
    triggers: set()
    weight: 10.200000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_26
    triggers: {('e', frozenset({'-atomic'}))}
    weight: 10.999999999999998
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 12.299999999999999
line done
line done

---------------------

input line #173
input roots: [<__main__.Root object at 0x10fc677b8>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 60.700000000000465..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 23.300000000000075..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 29.900000000000105..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 60.800000000000466..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 30.000000000000107..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 30.100000000000122..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 60.90000000000047..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 61.00000000000047..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 22.500000000000053..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 30.100000000000108..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'CHILD_1', 'a_1'}
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CHILD_1', 'a_1', 'CHILD_2', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc1b710>, '-', <__main__.AgrTerminal object at 0x10fc67208>, '#', <__main__.Root object at 0x10fc22c88>, '-', <__main__.NominalizerTerminal object at 0x10fc226d8>, '-', <__main__.SemanticTerminal object at 0x10fc35be0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_5: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2', 'a'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#CHILD-a
full_pronunciation: la#CHILDa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CHILD to the selectional of the nominalizer whose values are {'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'a_2'}
    selectional: {'FROG', 'CHILD', 'BALL', 'PIBLING', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 30.500000000000185
    linear: (<__main__.NominalizerTerminal object at 0x10fc05f28>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'CHILD', 'BALL', 'FROG', 'PIBLING', 'CAR', 'KEY', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_16, triggers = set(), weight = 11.5..already existed

create_vi: tried nominalizer: null_32, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.1..already existed

create_vi: tried nominalizer: null_17, triggers = {('e', frozenset({'-atomic'}))}, weight = 10.299999999999999..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'PIBLING', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_24, triggers = set(), weight = 10.6..already existed

create_vi: tried nominalizer: null_28, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.7..already existed
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 61.00000000000047
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 30.100000000000108
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_5
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 9.900000000000006
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 19.500000000000007
line done
line done

---------------------

input line #174
input roots: [<__main__.Root object at 0x10fc35fd0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 30.70000000000011..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 61.60000000000047..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 30.200000000000124..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 30.300000000000125..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'CHILD_1', 'a_1'}
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CHILD_1', 'a_1', 'CHILD_2', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc185c0>, '-', <__main__.AgrTerminal object at 0x10fc22a90>, '#', <__main__.Root object at 0x10fc47a90>, '-', <__main__.NominalizerTerminal object at 0x10fc47780>, '-', <__main__.SemanticTerminal object at 0x10fc47400>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a', 'i_2', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: una#CHILD-a
full_pronunciation: una#CHILDa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CHILD to the selectional of the nominalizer whose values are {'i_2', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'a_2'}
    selectional: {'BOOK', 'CHILD', 'BALL', 'PIBLING', 'GRANDPARENT', 'CAR', 'CLOWN', 'OFFSPRING'}
    selection_strength: True
    weight: 13.899999999999997
    linear: (<__main__.NominalizerTerminal object at 0x10fc36a90>,)
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 30.300000000000125
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 30.70000000000011
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_2
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 10.9
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 17.999999999999993
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 20.10000000000001
line done
line done

---------------------

input line #175
input roots: [<__main__.Root object at 0x10fc22c88>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 31.30000000000011..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 61.70000000000047..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 30.900000000000126..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 31.000000000000128..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: MILKCOW in its selectional

now working with the word 'MILKCOW-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'MILKCOW_1'}
     what if we combine triggers with the otherwise identical vi MILKCOW_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'MILKCOW_1', 'MILKCOW_2', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67470>, '-', <__main__.AgrTerminal object at 0x10fc477f0>, '#', <__main__.Root object at 0x10fc67358>, '-', <__main__.NominalizerTerminal object at 0x10fc67198>, '-', <__main__.SemanticTerminal object at 0x10fc67c50>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MILKCOW terminal with values set()
we picked MILKCOW_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: una#MILKCOW-a
full_pronunciation: una#MILKCOWe
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 31.000000000000128
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 31.30000000000011
VocabularyItem:
    pronunciation: MILKCOW
    label: MILKCOW
    values: set()
    diacritic: MILKCOW_3
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 10.400000000000006
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 12.9
line done
line done

---------------------

input line #176
input roots: [<__main__.Root object at 0x10fc385c0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 61.80000000000047..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 23.400000000000077..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 31.30000000000011..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 61.900000000000475..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 31.400000000000112..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 31.000000000000128..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 62.000000000000476..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 62.10000000000048..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 22.600000000000055..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 31.500000000000114..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: TOWER in its selectional

now working with the word 'TOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'TOWER_1', 'e_3', 'null_10'}
     what if we combine triggers with the otherwise identical vi TOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'TOWER_1', 'TOWER_3', 'e_3', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc3d898>, '-', <__main__.AgrTerminal object at 0x10fc67780>, '#', <__main__.Root object at 0x10fc45588>, '-', <__main__.NominalizerTerminal object at 0x10fc45518>, '-', <__main__.SemanticTerminal object at 0x10fc455f8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out TOWER terminal with values set()
we picked TOWER_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e', 'e_1', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: la#TOWER-e
full_pronunciation: la#TOWERe
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: TOWER to the selectional of the nominalizer whose values are {'e_1', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1', 'a_2'}
    selectional: {'FROG', 'BALL', 'CHILD', 'TOWER', 'PIBLING', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 15.799999999999992
    linear: (<__main__.NominalizerTerminal object at 0x10fc2aa20>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 62.10000000000048
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 31.500000000000114
VocabularyItem:
    pronunciation: TOWER
    label: TOWER
    values: set()
    diacritic: TOWER_3
    triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))}
    weight: 9.9
     what if we combine triggers with the otherwise identical vi TOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 18.499999999999993
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 12.9
line done
line done

---------------------

input line #177
input roots: [<__main__.Root object at 0x10fc18748>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 32.100000000000115..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 62.70000000000048..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 31.10000000000013..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 31.20000000000013..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_2', 'a_1', 'PIBLING_1', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc43198>, '-', <__main__.AgrTerminal object at 0x10fc3dba8>, '#', <__main__.Root object at 0x10fc436a0>, '-', <__main__.NominalizerTerminal object at 0x10fc433c8>, '-', <__main__.SemanticTerminal object at 0x10fc43b00>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_5: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: una#PIBLING-a
full_pronunciation: una#PIBLINGo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 31.20000000000013
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 32.100000000000115
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_5
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 18.999999999999993
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 17.799999999999997
line done
line done

---------------------

input line #178
input roots: [<__main__.Root object at 0x10fc42710>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 62.80000000000048..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 23.500000000000078..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 32.100000000000136..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 62.90000000000048..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 32.20000000000014..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 31.20000000000013..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 63.00000000000048..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 63.100000000000485..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 22.700000000000056..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 32.30000000000014..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'PIBLING_1', 'o_1', 'PIBLING_5'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a6d8>, '-', <__main__.AgrTerminal object at 0x10fc43278>, '#', <__main__.Root object at 0x10fc6ae10>, '-', <__main__.NominalizerTerminal object at 0x10fc6a978>, '-', <__main__.SemanticTerminal object at 0x10fc6a358>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_7: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'a_2'}
we picked null_16 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: lo#PIBLING-o
full_pronunciation: la#PIBLINGa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 63.100000000000485
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 32.000000000000114
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_7
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1', 'a_2'}
    diacritic: null_16
    triggers: set()
    weight: 11.5
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 20.80000000000001
line done
line done

---------------------

input line #179
input roots: [<__main__.Root object at 0x10fc6a710>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 32.000000000000114..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 63.100000000000485..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 31.300000000000132..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 31.400000000000134..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1', 'e_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: CAR in its selectional

now working with the word 'CAR-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'null_27', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'null_27', 'a_1', 'CAR_1'}
     what if we combine triggers with the otherwise identical vi CAR_2 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'null_16', 'CAR_1', 'null_27', 'CAR_3'}
done processing input, time to test
we selected the nominalizer with values: {'e_1'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a2e8>, '#', <__main__.Root object at 0x10fc582e8>, '-', <__main__.NominalizerTerminal object at 0x10fc36710>, '-', <__main__.SemanticTerminal object at 0x10fc36550>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'e_1', '-definite', '+atomic'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out CAR terminal with values set()
we picked CAR_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1', 'null'}
we picked null_6 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: una#CAR-a
full_pronunciation: un#CARo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 31.400000000000134
VocabularyItem:
    pronunciation: CAR
    label: CAR
    values: set()
    diacritic: CAR_2
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 12.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_6
    triggers: set()
    weight: 10.200000000000001
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 17.799999999999997
line done
line done

---------------------

input line #180
input roots: [<__main__.Root object at 0x10fc6a390>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 63.200000000000486..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 23.60000000000008..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 32.100000000000115..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 63.30000000000049..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 32.20000000000012..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 31.400000000000134..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 63.40000000000049..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 63.50000000000049..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 22.800000000000058..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 32.30000000000012..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'GRANDPARENT_1'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'GRANDPARENT_1', 'null_11', 'null_10', 'GRANDPARENT_3'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc2da90>, '-', <__main__.AgrTerminal object at 0x10fc583c8>, '#', <__main__.Root object at 0x10fc506a0>, '-', <__main__.NominalizerTerminal object at 0x10fc50ac8>, '-', <__main__.SemanticTerminal object at 0x10fc2df28>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_6: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'a_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#GRANDPARENT-a
full_pronunciation: la#GRANDPARENTa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: GRANDPARENT to the selectional of the nominalizer whose values are {'e_1', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1', 'a_2'}
    selectional: {'FROG', 'BALL', 'CHILD', 'TOWER', 'PIBLING', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 16.09999999999999
    linear: (<__main__.NominalizerTerminal object at 0x10fc2aa20>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 63.50000000000049
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 32.30000000000012
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_6
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 10.200000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 18.89999999999999
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 20.900000000000013
line done
line done

---------------------

input line #181
input roots: [<__main__.Root object at 0x10fc58c18>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 64.10000000000048..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 32.90000000000012..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 23.70000000000008..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 64.20000000000047..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 32.40000000000014..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 23.800000000000082..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 64.30000000000047..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: BALL in its selectional

now working with the word 'BALL-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'BALL_1', 'null_6'}
     what if we combine triggers with the otherwise identical vi BALL_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'BALL_1', 'BALL_3', 'null_26', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc2d518>, '#', <__main__.Root object at 0x10fc3e2b0>, '-', <__main__.NominalizerTerminal object at 0x10fc3eb00>, '-', <__main__.SemanticTerminal object at 0x10fc2f128>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out BALL terminal with values set()
we picked BALL_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: le#BALL-e
full_pronunciation: l#BALLi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 64.30000000000047
VocabularyItem:
    pronunciation: BALL
    label: BALL
    values: set()
    diacritic: BALL_2
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 10.4
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 19.39999999999999
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 15.999999999999996
line done
line done

---------------------

input line #182
input roots: [<__main__.Root object at 0x10fc50f98>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 32.50000000000014..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 64.30000000000047..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 31.500000000000135..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 31.600000000000136..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FOOT in its selectional

now working with the word 'FOOT-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FOOT_1', 'null_8', 'e_3', 'null_19'}
     what if we combine triggers with the otherwise identical vi FOOT_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FOOT_1', 'e_3', 'FOOT_2', 'null_19'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc58160>, '-', <__main__.AgrTerminal object at 0x10fc505f8>, '#', <__main__.Root object at 0x10fc36630>, '-', <__main__.NominalizerTerminal object at 0x10fc582e8>, '-', <__main__.SemanticTerminal object at 0x10fc58e10>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FOOT terminal with values set()
we picked FOOT_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'a_2'}
we picked null_24 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: uno#FOOT-e
full_pronunciation: una#FOOTe
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 31.600000000000136
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 32.90000000000012
VocabularyItem:
    pronunciation: FOOT
    label: FOOT
    values: set()
    diacritic: FOOT_3
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2', 'a_2'}
    diacritic: null_24
    triggers: set()
    weight: 10.6
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 13.5
line done
line done

---------------------

input line #183
input roots: [<__main__.Root object at 0x10fc58a58>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 64.40000000000046..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 32.90000000000012..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 23.900000000000084..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 64.50000000000045..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 32.60000000000014..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 24.000000000000085..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 64.60000000000045..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'GRANDPARENT_1', 'null_6'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_3 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'GRANDPARENT_7', 'null_26', 'GRANDPARENT_1', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a7b8>, '#', <__main__.Root object at 0x10fc6a240>, '-', <__main__.NominalizerTerminal object at 0x10fc6a198>, '-', <__main__.SemanticTerminal object at 0x10fc6a2b0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_6: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: le#GRANDPARENT-e
full_pronunciation: l#GRANDPARENTi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 64.60000000000045
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_6
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 10.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 19.29999999999999
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 15.899999999999997
line done
line done

---------------------

input line #184
input roots: [<__main__.Root object at 0x10fc6a4e0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 33.00000000000012..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 64.60000000000045..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 31.600000000000136..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 31.700000000000138..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: MILKCOW in its selectional

now working with the word 'MILKCOW-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'MILKCOW_1'}
     what if we combine triggers with the otherwise identical vi MILKCOW_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'MILKCOW_1', 'MILKCOW_2', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc43278>, '-', <__main__.AgrTerminal object at 0x10fc6ae80>, '#', <__main__.Root object at 0x10fc43208>, '-', <__main__.NominalizerTerminal object at 0x10fc43c88>, '-', <__main__.SemanticTerminal object at 0x10fc43eb8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MILKCOW terminal with values set()
we picked MILKCOW_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: una#MILKCOW-a
full_pronunciation: uno#MILKCOWe
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 31.700000000000138
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 32.60000000000014
VocabularyItem:
    pronunciation: MILKCOW
    label: MILKCOW
    values: set()
    diacritic: MILKCOW_3
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 19.19999999999999
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 13.4
line done
line done

---------------------

input line #185
input roots: [<__main__.Root object at 0x10fc6a2e8>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 64.70000000000044..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 33.10000000000012..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 22.90000000000006..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 64.80000000000044..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 32.60000000000014..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 23.00000000000006..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 64.90000000000043..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: CLOWN in its selectional

now working with the word 'CLOWN-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'CLOWN_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi CLOWN_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CLOWN_2', 'null_15', 'i_1', 'null_14', 'CLOWN_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc45940>, '-', <__main__.AgrTerminal object at 0x10fc6aef0>, '#', <__main__.Root object at 0x10fc45400>, '-', <__main__.NominalizerTerminal object at 0x10fc45860>, '-', <__main__.SemanticTerminal object at 0x10fc45358>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic', 'o_2'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CLOWN terminal with values set()
we picked CLOWN_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i', 'e_1', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#CLOWN-i
full_pronunciation: le#CLOWNi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 64.90000000000043
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 24.000000000000085
VocabularyItem:
    pronunciation: CLOWN
    label: CLOWN
    values: set()
    diacritic: CLOWN_4
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.3
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 19.099999999999987
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 15.899999999999997
line done
line done

---------------------

input line #186
input roots: [<__main__.Root object at 0x10fc42400>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 33.200000000000124..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 64.90000000000043..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 31.700000000000138..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 31.80000000000014..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1', 'e_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: FROG in its selectional

now working with the word 'FROG-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'null_27', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_1', 'null_16', 'null_27', 'a_1'}
     what if we combine triggers with the otherwise identical vi FROG_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_2', 'a_1', 'null_16', 'null_27', 'FROG_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67080>, '-', <__main__.AgrTerminal object at 0x10fc3dda0>, '#', <__main__.Root object at 0x10fc67c88>, '-', <__main__.NominalizerTerminal object at 0x10fc67390>, '-', <__main__.SemanticTerminal object at 0x10fc67d30>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FROG terminal with values set()
we picked FROG_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: una#FROG-a
full_pronunciation: una#FROGa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: FROG to the selectional of the nominalizer whose values are {'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'a_2'}
    selectional: {'FROG', 'CHILD', 'BALL', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 32.700000000000216
    linear: (<__main__.NominalizerTerminal object at 0x10fc05f28>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'CHILD', 'BALL', 'FROG', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_6, triggers = set(), weight = 10.200000000000001..already existed

create_vi: tried nominalizer: null_7, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.499999999999998..already existed

create_vi: tried nominalizer: null_26, triggers = {('e', frozenset({'-atomic'}))}, weight = 11.599999999999998..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'PIBLING', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_14, triggers = set(), weight = 12.200000000000001..already existed

create_vi: tried nominalizer: null_15, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.799999999999997..already existed
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 31.80000000000014
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 33.200000000000124
VocabularyItem:
    pronunciation: FROG
    label: FROG
    values: set()
    diacritic: FROG_2
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 9.9
     what if we combine triggers with the otherwise identical vi FROG_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 18.999999999999986
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 21.600000000000016
line done
line done

---------------------

input line #187
input roots: [<__main__.Root object at 0x10fc43710>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 33.800000000000125..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 65.00000000000043..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 32.40000000000014..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 32.50000000000014..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_2', 'a_1', 'PIBLING_1', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc3d828>, '#', <__main__.Root object at 0x10fc084e0>, '-', <__main__.NominalizerTerminal object at 0x10fc05470>, '-', <__main__.SemanticTerminal object at 0x10fc05e48>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite', '+atomic'}
we picked uno_1: no super match (neither decl nor L1-gender)
now spelling out PIBLING terminal with values set()
we picked PIBLING_5: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: una#PIBLING-a
full_pronunciation: uno#PIBLINGo
vis_used:
Failure
VocabularyItem:
    pronunciation: uno
    label: definite
    values: {'-definite', '+atomic'}
    diacritic: uno_1
    triggers: set()
    weight: 9.400000000000002
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_5
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 19.499999999999986
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 17.699999999999996
line done
line done

---------------------

input line #188
input roots: [<__main__.Root object at 0x10fc67780>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 65.10000000000042..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 24.000000000000085..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 33.90000000000013..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 65.20000000000041..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 34.00000000000013..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 32.60000000000014..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 65.30000000000041..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 65.4000000000004..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 23.100000000000062..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 34.10000000000013..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: TOWER in its selectional

now working with the word 'TOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'TOWER_1', 'e_3', 'null_10'}
     what if we combine triggers with the otherwise identical vi TOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'TOWER_1', 'TOWER_3', 'e_3', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'e_1'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67908>, '#', <__main__.Root object at 0x10fc3e828>, '-', <__main__.NominalizerTerminal object at 0x10fc22a90>, '-', <__main__.SemanticTerminal object at 0x10fc22c50>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', 'e_1', '+atomic'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out TOWER terminal with values set()
we picked TOWER_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'e_1', 'null'}
we picked null_6 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: la#TOWER-e
full_pronunciation: l#TOWERe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 65.4000000000004
VocabularyItem:
    pronunciation: TOWER
    label: TOWER
    values: set()
    diacritic: TOWER_4
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'})), ('e', frozenset({'+atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_6
    triggers: set()
    weight: 10.200000000000001
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 13.4
line done
line done

---------------------

input line #189
input roots: [<__main__.Root object at 0x10fc357b8>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 65.4000000000004..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 24.100000000000087..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 34.20000000000013..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 65.5000000000004..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 34.30000000000013..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 32.700000000000145..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 65.60000000000039..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 65.70000000000039..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 23.200000000000063..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 34.400000000000134..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'GRANDPARENT_1'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'GRANDPARENT_1', 'null_11', 'null_10', 'GRANDPARENT_3'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc05320>, '-', <__main__.AgrTerminal object at 0x10fc18320>, '#', <__main__.Root object at 0x10fc385c0>, '-', <__main__.NominalizerTerminal object at 0x10fc10780>, '-', <__main__.SemanticTerminal object at 0x10fbffcf8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'i_2', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'i_2', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: la#GRANDPARENT-a
full_pronunciation: lo#GRANDPARENTo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 65.70000000000039
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 32.60000000000014
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_2
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 19.399999999999984
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 17.599999999999994
line done
line done

---------------------

input line #190
input roots: [<__main__.Root object at 0x10fc355c0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 65.70000000000039..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 34.500000000000135..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 24.200000000000088..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 65.80000000000038..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 32.60000000000014..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 24.30000000000009..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 65.90000000000038..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: MILKCOW in its selectional

now working with the word 'MILKCOW-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'null_17'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'MILKCOW_1', 'null_17'}
     what if we combine triggers with the otherwise identical vi MILKCOW_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'MILKCOW_3', 'MILKCOW_1', 'null_17'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67668>, '#', <__main__.Root object at 0x10fc67eb8>, '-', <__main__.NominalizerTerminal object at 0x10fc67dd8>, '-', <__main__.SemanticTerminal object at 0x10fc67ef0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out MILKCOW terminal with values set()
we picked MILKCOW_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: le#MILKCOW-e
full_pronunciation: l#MILKCOWe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 65.90000000000038
VocabularyItem:
    pronunciation: MILKCOW
    label: MILKCOW
    values: set()
    diacritic: MILKCOW_3
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 9.600000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 10.300000000000006
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 13.099999999999998
line done
line done

---------------------

input line #191
input roots: [<__main__.Root object at 0x10fc677b8>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 65.90000000000038..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 34.600000000000136..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 23.300000000000065..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 66.00000000000037..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 32.700000000000145..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 23.400000000000066..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 66.10000000000036..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: FLOWER in its selectional

now working with the word 'FLOWER-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'FLOWER_1', 'i_1'}
     what if we combine triggers with the otherwise identical vi FLOWER_3 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'FLOWER_2', 'null_13', 'i_1', 'FLOWER_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc671d0>, '#', <__main__.Root object at 0x10fc45518>, '-', <__main__.NominalizerTerminal object at 0x10fc45588>, '-', <__main__.SemanticTerminal object at 0x10fc45e80>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out FLOWER terminal with values set()
we picked FLOWER_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#FLOWER-i
full_pronunciation: l#FLOWERi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 66.10000000000036
VocabularyItem:
    pronunciation: FLOWER
    label: FLOWER
    values: set()
    diacritic: FLOWER_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 19.299999999999983
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 15.899999999999997
line done
line done

---------------------

input line #192
input roots: [<__main__.Root object at 0x10fc455f8>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 32.800000000000146..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 66.10000000000036..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 32.800000000000146..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 32.90000000000015..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'PIBLING_1', 'o_1', 'PIBLING_5'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc438d0>, '-', <__main__.AgrTerminal object at 0x10fc428d0>, '#', <__main__.Root object at 0x10fc3bf98>, '-', <__main__.NominalizerTerminal object at 0x10fc43f60>, '-', <__main__.SemanticTerminal object at 0x10fc433c8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i_2', 'a_2'}
we picked null_15: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: uno#PIBLING-o
full_pronunciation: una#PIBLINGa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 32.90000000000015
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 34.600000000000136
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_1
    triggers: set()
    weight: 11.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_15
    triggers: {('i', frozenset({'-atomic'}))}
    weight: 10.799999999999997
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 22.30000000000002
line done
line done

---------------------

input line #193
input roots: [<__main__.Root object at 0x10fc43b00>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 66.20000000000036..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 34.600000000000136..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 24.40000000000009..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 66.30000000000035..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 32.90000000000015..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 24.500000000000092..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 66.40000000000035..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: BALL in its selectional

now working with the word 'BALL-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'null_17'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'BALL_1', 'null_17'}
     what if we combine triggers with the otherwise identical vi BALL_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'BALL_1', 'BALL_3', 'null_17'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6ae80>, '#', <__main__.Root object at 0x10fc6af28>, '-', <__main__.NominalizerTerminal object at 0x10fc6a0b8>, '-', <__main__.SemanticTerminal object at 0x10fc6a6a0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out BALL terminal with values set()
we picked BALL_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: le#BALL-e
full_pronunciation: l#BALLe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 66.40000000000035
VocabularyItem:
    pronunciation: BALL
    label: BALL
    values: set()
    diacritic: BALL_3
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 11.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 9.500000000000004
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 13.099999999999998
line done
line done

---------------------

input line #194
input roots: [<__main__.Root object at 0x10fc6a940>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 66.40000000000035..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 24.600000000000094..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 33.00000000000015..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 66.50000000000034..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 33.10000000000015..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 32.90000000000015..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 66.60000000000034..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 66.70000000000033..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 23.500000000000068..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 33.20000000000015..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: BOOK in its selectional

now working with the word 'BOOK-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'BOOK_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi BOOK_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'BOOK_1', 'BOOK_3'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc36630>, '-', <__main__.AgrTerminal object at 0x10fc6a978>, '#', <__main__.Root object at 0x10fc58400>, '-', <__main__.NominalizerTerminal object at 0x10fc58ac8>, '-', <__main__.SemanticTerminal object at 0x10fc2da90>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BOOK terminal with values set()
we picked BOOK_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o_2'}
we picked null_9: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: lo#BOOK-o
full_pronunciation: lo#BOOKo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: BOOK to the selectional of the nominalizer whose values are {'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'o_2'}
    selectional: {'MOUSE', 'CHILD', 'BOOK', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 34.60000000000024
    linear: (<__main__.NominalizerTerminal object at 0x10fc08908>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_21, triggers = {('o', frozenset({'+atomic'}))}, weight = 10.1..already existed

create_vi: made nominalizer: null_38, triggers = {('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}, weight = 10.0
....made the new vi: VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1', 'o_2'}
    diacritic: null_38
    triggers: {('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 10.0

create_vi: tried nominalizer: null_36, triggers = {('o', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}, weight = 10.1..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'CLOWN', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_18, triggers = {('o', frozenset({'+atomic'}))}, weight = 10.2..already existed

create_vi: made nominalizer: null_39, triggers = {('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}, weight = 10.0
....made the new vi: VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2', 'o_2'}
    diacritic: null_39
    triggers: {('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 66.70000000000033
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 33.20000000000015
VocabularyItem:
    pronunciation: BOOK
    label: BOOK
    values: set()
    diacritic: BOOK_1
    triggers: set()
    weight: 10.4
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_9
    triggers: {('o', frozenset({'+atomic'}))}
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 17.699999999999996
line done
line done

---------------------

input line #195
input roots: [<__main__.Root object at 0x10fc2f7f0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 34.70000000000014..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 67.30000000000032..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 33.00000000000015..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 33.10000000000015..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'CHILD_1', 'a_1'}
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CHILD_1', 'a_1', 'CHILD_2', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50b38>, '-', <__main__.AgrTerminal object at 0x10fc58b70>, '#', <__main__.Root object at 0x10fc50f98>, '-', <__main__.NominalizerTerminal object at 0x10fc50a90>, '-', <__main__.SemanticTerminal object at 0x10fc50a20>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: una#CHILD-a
full_pronunciation: uno#CHILDa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 33.10000000000015
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 33.70000000000015
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_2
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 11.4
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 19.19999999999998
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 22.30000000000002
line done
line done

---------------------

input line #196
input roots: [<__main__.Root object at 0x10fc36710>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 67.40000000000032..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 24.700000000000095..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 33.70000000000015..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 67.50000000000031..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 33.80000000000015..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 33.10000000000015..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 67.6000000000003..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 67.7000000000003..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 23.60000000000007..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 33.900000000000155..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CASTLE in its selectional

now working with the word 'CASTLE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CASTLE_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CASTLE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'CASTLE_2', 'o_1', 'CASTLE_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50a90>, '-', <__main__.AgrTerminal object at 0x10fc419b0>, '#', <__main__.Root object at 0x10fc584e0>, '-', <__main__.NominalizerTerminal object at 0x10fc50630>, '-', <__main__.SemanticTerminal object at 0x10fc50b38>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CASTLE terminal with values set()
we picked CASTLE_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: lo#CASTLE-o
full_pronunciation: lo#CASTLEo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CASTLE to the selectional of the nominalizer whose values are {'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'o_2'}
    selectional: {'MOUSE', 'CHILD', 'BOOK', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 35.20000000000025
    linear: (<__main__.NominalizerTerminal object at 0x10fc08908>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_6, triggers = set(), weight = 10.200000000000001..already existed

create_vi: tried nominalizer: null_7, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.599999999999998..already existed

create_vi: tried nominalizer: null_26, triggers = {('e', frozenset({'-atomic'}))}, weight = 11.699999999999998..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'CLOWN', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_14, triggers = set(), weight = 12.3..already existed

create_vi: tried nominalizer: null_15, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.799999999999997..already existed
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 67.7000000000003
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 33.900000000000155
VocabularyItem:
    pronunciation: CASTLE
    label: CASTLE
    values: set()
    diacritic: CASTLE_2
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 10.3
     what if we combine triggers with the otherwise identical vi CASTLE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 19.09999999999998
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 18.299999999999997
line done
line done

---------------------

input line #197
input roots: [<__main__.Root object at 0x10fc50940>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 68.3000000000003..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 34.80000000000014..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 23.70000000000007..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 68.40000000000029..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 34.500000000000156..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 23.80000000000007..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 68.50000000000028..already existed
  we're in a functional word...
  - nominalizer's values are now {'a_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'a_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_24', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_24', 'i_1', 'null_28'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'GRANDPARENT_1', 'null_24', 'i_1', 'null_28'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_3 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_28', 'null_24', 'i_1', 'GRANDPARENT_4', 'GRANDPARENT_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc2f048>, '-', <__main__.AgrTerminal object at 0x10fc58198>, '#', <__main__.Root object at 0x10fc6a400>, '-', <__main__.NominalizerTerminal object at 0x10fc6a828>, '-', <__main__.SemanticTerminal object at 0x10fc36160>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_5: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'e_1', 'null'}
we picked null_6 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#GRANDPARENT-i
full_pronunciation: le#GRANDPARENTi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 68.50000000000028
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 24.700000000000095
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_5
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_6
    triggers: set()
    weight: 10.200000000000001
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 15.899999999999997
line done
line done

---------------------

input line #198
input roots: [<__main__.Root object at 0x10fc36240>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 34.60000000000016..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 68.50000000000028..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 33.20000000000015..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 33.30000000000015..already existed
  we're in a functional word...
  - nominalizer's values are now {'e_1', 'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'o_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_20'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_20', 'null_21'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_20', 'null_21', 'CHILD_1'}
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_20', 'CHILD_1', 'o_1', 'null_21', 'CHILD_3'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a6a0>, '-', <__main__.AgrTerminal object at 0x10fc2f7f0>, '#', <__main__.Root object at 0x10fc6aa90>, '-', <__main__.NominalizerTerminal object at 0x10fc6aa20>, '-', <__main__.SemanticTerminal object at 0x10fc6ae48>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_9: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: uno#CHILD-o
full_pronunciation: una#CHILDo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 33.30000000000015
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 34.80000000000014
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_9
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.5
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 19.59999999999998
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 18.9
line done
line done

---------------------

input line #199
input roots: [<__main__.Root object at 0x10fc6ad30>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 68.60000000000028..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 34.80000000000014..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 23.900000000000073..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 68.70000000000027..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 34.70000000000016..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 24.000000000000075..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 68.80000000000027..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: CASTLE in its selectional

now working with the word 'CASTLE-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CASTLE_1', 'null_12', 'null_13', 'i_1'}
     what if we combine triggers with the otherwise identical vi CASTLE_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1', 'CASTLE_1', 'CASTLE_3'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc42630>, '-', <__main__.AgrTerminal object at 0x10fc6a358>, '#', <__main__.Root object at 0x10fc42f28>, '-', <__main__.NominalizerTerminal object at 0x10fc42550>, '-', <__main__.SemanticTerminal object at 0x10fc42b00>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'o_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CASTLE terminal with values set()
we picked CASTLE_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'o_2'}
we picked null_14 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: li#CASTLE-i
full_pronunciation: li#CASTLEi
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CASTLE to the selectional of the nominalizer whose values are {'i_2', 'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'o_2'}
    selectional: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'GRANDPARENT', 'CASTLE', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 16.199999999999996
    linear: (<__main__.NominalizerTerminal object at 0x10fc22eb8>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 68.80000000000027
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 24.000000000000075
VocabularyItem:
    pronunciation: CASTLE
    label: CASTLE
    values: set()
    diacritic: CASTLE_2
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 10.8
     what if we combine triggers with the otherwise identical vi CASTLE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 12.3
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 15.899999999999997
line done
line done

---------------------

input line #200
input roots: [<__main__.Root object at 0x10fc36550>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 69.40000000000026..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 24.700000000000095..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 34.90000000000014..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 69.50000000000026..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 35.00000000000014..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 33.30000000000015..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 69.60000000000025..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 69.70000000000024..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 24.600000000000076..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 35.10000000000014..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'GRANDPARENT_1'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'GRANDPARENT_1', 'null_11', 'null_10', 'GRANDPARENT_3'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc3def0>, '-', <__main__.AgrTerminal object at 0x10fc28128>, '#', <__main__.Root object at 0x10fc3d828>, '-', <__main__.NominalizerTerminal object at 0x10fc3d710>, '-', <__main__.SemanticTerminal object at 0x10fc3d748>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_9: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#GRANDPARENT-a
full_pronunciation: la#GRANDPARENTa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: GRANDPARENT to the selectional of the nominalizer whose values are {'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'a_2'}
    selectional: {'FROG', 'CHILD', 'BALL', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 35.00000000000025
    linear: (<__main__.NominalizerTerminal object at 0x10fc05f28>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'CHILD', 'BALL', 'FROG', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_6, triggers = set(), weight = 10.200000000000001..already existed

create_vi: tried nominalizer: null_7, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.699999999999998..already existed

create_vi: tried nominalizer: null_26, triggers = {('e', frozenset({'-atomic'}))}, weight = 11.799999999999997..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'PIBLING', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_14, triggers = set(), weight = 12.9..already existed

create_vi: tried nominalizer: null_15, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.899999999999997..already existed
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 69.70000000000024
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 35.10000000000014
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_9
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 19.49999999999998
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 22.30000000000002
line done
line done

---------------------

input line #201
input roots: [<__main__.Root object at 0x10fc3d358>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 70.30000000000024..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 35.700000000000145..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 24.800000000000097..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 70.40000000000023..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 34.80000000000016..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 24.900000000000098..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 70.50000000000023..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'o_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'o_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_20'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_20', 'null_31'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_20', 'null_31', 'GRANDPARENT_1'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_3 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_20', 'GRANDPARENT_7', 'GRANDPARENT_1', 'null_31'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67128>, '#', <__main__.Root object at 0x10fc676d8>, '-', <__main__.NominalizerTerminal object at 0x10fc67cf8>, '-', <__main__.SemanticTerminal object at 0x10fc67c50>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked li_1: no super match (neither decl nor L1-gender)
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_9: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: le#GRANDPARENT-e
full_pronunciation: li#GRANDPARENTe
vis_used:
Failure
VocabularyItem:
    pronunciation: li
    label: definite
    values: {'+definite', '-atomic'}
    diacritic: li_1
    triggers: set()
    weight: 10.200000000000001
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_9
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.5
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 9.400000000000004
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 13.099999999999998
line done
line done

---------------------

input line #202
input roots: [<__main__.Root object at 0x10fc58f28>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 70.60000000000022..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 25.0000000000001..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 35.800000000000146..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 70.70000000000022..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 35.90000000000015..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 33.400000000000155..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 70.80000000000021..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 70.9000000000002..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 24.700000000000077..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 36.00000000000015..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'OFFSPRING_1', 'null_11', 'null_10', 'OFFSPRING_5'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc47160>, '-', <__main__.AgrTerminal object at 0x10fc05470>, '#', <__main__.Root object at 0x10fc3e080>, '-', <__main__.NominalizerTerminal object at 0x10fc3eac8>, '-', <__main__.SemanticTerminal object at 0x10fc185c0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'a_2'}
we picked null_11: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#OFFSPRING-a
full_pronunciation: la#OFFSPRINGa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: OFFSPRING to the selectional of the nominalizer whose values are {'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'a_2'}
    selectional: {'FROG', 'CHILD', 'BALL', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 35.70000000000026
    linear: (<__main__.NominalizerTerminal object at 0x10fc05f28>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'CHILD', 'BALL', 'FROG', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_27, triggers = {('a', frozenset({'+atomic'}))}, weight = 10.1..already existed

create_vi: made nominalizer: null_40, triggers = {('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}, weight = 10.0
....made the new vi: VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1', 'a_2'}
    diacritic: null_40
    triggers: {('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 10.0

create_vi: tried nominalizer: null_34, triggers = {('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}, weight = 10.1..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'PIBLING', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_25, triggers = {('a', frozenset({'+atomic'}))}, weight = 10.2..already existed

create_vi: made nominalizer: null_41, triggers = {('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}, weight = 10.0
....made the new vi: VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2', 'a_2'}
    diacritic: null_41
    triggers: {('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 70.9000000000002
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 36.00000000000015
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_1
    triggers: set()
    weight: 10.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_11
    triggers: {('a', frozenset({'+atomic'}))}
    weight: 10.200000000000001
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 22.90000000000002
line done
line done

---------------------

input line #203
input roots: [<__main__.Root object at 0x10fc470f0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: set()
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 71.5000000000002..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 25.1000000000001..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 36.60000000000015..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 71.6000000000002..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 36.70000000000015..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 33.500000000000156..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 71.70000000000019..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 71.80000000000018..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 24.80000000000008..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 36.80000000000015..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: FROG in its selectional

now working with the word 'FROG-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi FROG_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_2', 'a_1', 'FROG_1', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4bd68>, '-', <__main__.AgrTerminal object at 0x10fc47f28>, '#', <__main__.Root object at 0x10fc47cf8>, '-', <__main__.NominalizerTerminal object at 0x10fc185c0>, '-', <__main__.SemanticTerminal object at 0x10fc3e828>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FROG terminal with values set()
we picked FROG_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'a_2'}
we picked null_11: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#FROG-a
full_pronunciation: la#FROGa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: FROG to the selectional of the nominalizer whose values are {'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'a_2'}
    selectional: {'FROG', 'CHILD', 'BALL', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 36.30000000000027
    linear: (<__main__.NominalizerTerminal object at 0x10fc05f28>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'CHILD', 'BALL', 'FROG', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_27, triggers = {('a', frozenset({'+atomic'}))}, weight = 10.2..already existed

create_vi: tried nominalizer: null_40, triggers = {('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}, weight = 10.1..already existed

create_vi: tried nominalizer: null_34, triggers = {('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}, weight = 10.2..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'PIBLING', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_25, triggers = {('a', frozenset({'+atomic'}))}, weight = 10.299999999999999..already existed

create_vi: tried nominalizer: null_41, triggers = {('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}, weight = 10.1..already existed
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 71.80000000000018
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 36.80000000000015
VocabularyItem:
    pronunciation: FROG
    label: FROG
    values: set()
    diacritic: FROG_1
    triggers: set()
    weight: 10.200000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_11
    triggers: {('a', frozenset({'+atomic'}))}
    weight: 10.700000000000001
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 23.50000000000002
line done
line done

---------------------

input line #204
input roots: [<__main__.Root object at 0x10fc47c18>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 72.40000000000018..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 37.400000000000155..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 24.90000000000008..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 72.50000000000017..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 34.90000000000016..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 25.00000000000008..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 72.60000000000016..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_12', 'null_13', 'i_1'}
     what if we combine triggers with the otherwise identical vi PIBLING_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_5 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'PIBLING_7', 'PIBLING_1', 'null_13', 'i_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc676a0>, '-', <__main__.AgrTerminal object at 0x10fc22f60>, '#', <__main__.Root object at 0x10fc677b8>, '-', <__main__.NominalizerTerminal object at 0x10fc67080>, '-', <__main__.SemanticTerminal object at 0x10fc673c8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'e_1', 'null'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: li#PIBLING-i
full_pronunciation: le#PIBLINGe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 72.60000000000016
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 25.1000000000001
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_3
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 10.3
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 19.99999999999998
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 12.999999999999998
line done
line done

---------------------

input line #205
input roots: [<__main__.Root object at 0x10fc67668>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 72.60000000000016..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 25.1000000000001..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 37.500000000000156..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 72.70000000000016..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 37.60000000000016..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 33.60000000000016..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 72.80000000000015..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 72.90000000000015..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 25.100000000000083..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 37.70000000000016..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: MILKCOW in its selectional

now working with the word 'MILKCOW-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'MILKCOW_1'}
     what if we combine triggers with the otherwise identical vi MILKCOW_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'MILKCOW_1', 'MILKCOW_2', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc454a8>, '-', <__main__.AgrTerminal object at 0x10fc05e48>, '#', <__main__.Root object at 0x10fc45f60>, '-', <__main__.NominalizerTerminal object at 0x10fc455f8>, '-', <__main__.SemanticTerminal object at 0x10fc45518>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'i_2', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MILKCOW terminal with values set()
we picked MILKCOW_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a', 'i_2', 'a_2'}
we picked null_24 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#MILKCOW-a
full_pronunciation: la#MILKCOWa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: MILKCOW to the selectional of the nominalizer whose values are {'i_2', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'a_2'}
    selectional: {'BOOK', 'CHILD', 'BALL', 'PIBLING', 'GRANDPARENT', 'CAR', 'CLOWN', 'OFFSPRING'}
    selection_strength: True
    weight: 16.199999999999996
    linear: (<__main__.NominalizerTerminal object at 0x10fc36a90>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 72.90000000000015
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 37.70000000000016
VocabularyItem:
    pronunciation: MILKCOW
    label: MILKCOW
    values: set()
    diacritic: MILKCOW_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2', 'a_2'}
    diacritic: null_24
    triggers: set()
    weight: 10.5
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 24.100000000000023
line done
line done

---------------------

input line #206
input roots: [<__main__.Root object at 0x10fc3dfd0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 73.50000000000014..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 25.200000000000102..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 35.00000000000016..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 73.60000000000014..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 35.100000000000165..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 33.70000000000016..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 73.70000000000013..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 73.80000000000013..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 25.200000000000085..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 35.200000000000166..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'GRANDPARENT_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'GRANDPARENT_1', 'GRANDPARENT_2'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc438d0>, '-', <__main__.AgrTerminal object at 0x10fc42a20>, '#', <__main__.Root object at 0x10fc439e8>, '-', <__main__.NominalizerTerminal object at 0x10fc43940>, '-', <__main__.SemanticTerminal object at 0x10fc43438>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'e_1', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: lo#GRANDPARENT-o
full_pronunciation: lo#GRANDPARENTo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: GRANDPARENT to the selectional of the nominalizer whose values are {'e_1', 'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1', 'o_2'}
    selectional: {'BOOK', 'CHILD', 'PIBLING', 'GRANDPARENT', 'CLOWN', 'OFFSPRING'}
    selection_strength: True
    weight: 14.399999999999997
    linear: (<__main__.NominalizerTerminal object at 0x10fc3d400>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 73.80000000000013
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 35.200000000000166
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_2
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 9.600000000000001
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 19.899999999999977
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 18.9
line done
line done

---------------------

input line #207
input roots: [<__main__.Root object at 0x10fc43780>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 35.80000000000017..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 74.40000000000012..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 33.80000000000016..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 33.90000000000016..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: BOOK in its selectional

now working with the word 'BOOK-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'BOOK_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi BOOK_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'BOOK_1', 'BOOK_3'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6ab70>, '-', <__main__.AgrTerminal object at 0x10fc36160>, '#', <__main__.Root object at 0x10fc6a550>, '-', <__main__.NominalizerTerminal object at 0x10fc6af98>, '-', <__main__.SemanticTerminal object at 0x10fc6a668>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BOOK terminal with values set()
we picked BOOK_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'i_2', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: uno#BOOK-o
full_pronunciation: uno#BOOKo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: BOOK to the selectional of the nominalizer whose values are {'i_2', 'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'o_2'}
    selectional: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'GRANDPARENT', 'CASTLE', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 16.5
    linear: (<__main__.NominalizerTerminal object at 0x10fc22eb8>,)
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 33.90000000000016
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 35.80000000000017
VocabularyItem:
    pronunciation: BOOK
    label: BOOK
    values: set()
    diacritic: BOOK_4
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 11.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 9.300000000000004
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 19.5
line done
line done

---------------------

input line #208
input roots: [<__main__.Root object at 0x10fc6aa20>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 74.50000000000011..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 25.300000000000104..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 36.40000000000017..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 74.60000000000011..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 36.50000000000017..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 34.50000000000016..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 74.7000000000001..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 74.8000000000001..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 25.300000000000086..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 36.60000000000017..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'GRANDPARENT_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'GRANDPARENT_1', 'GRANDPARENT_2'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc589e8>, '-', <__main__.AgrTerminal object at 0x10fc6a4a8>, '#', <__main__.Root object at 0x10fc58cc0>, '-', <__main__.NominalizerTerminal object at 0x10fc58e10>, '-', <__main__.SemanticTerminal object at 0x10fc580b8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_6: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2', 'a'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: lo#GRANDPARENT-o
full_pronunciation: lo#GRANDPARENTa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 74.8000000000001
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 36.60000000000017
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_6
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 10.600000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 9.800000000000004
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 24.600000000000023
line done
line done

---------------------

input line #209
input roots: [<__main__.Root object at 0x10fc6a128>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 74.8000000000001..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 25.400000000000105..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 38.30000000000016..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 74.90000000000009..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 38.40000000000016..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 34.600000000000165..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 75.00000000000009..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 75.10000000000008..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 25.400000000000087..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 38.50000000000016..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: BALL in its selectional

now working with the word 'BALL-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'BALL_1', 'a_1'}
     what if we combine triggers with the otherwise identical vi BALL_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'BALL_1', 'BALL_2', 'null_10', 'null_11'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc41400>, '-', <__main__.AgrTerminal object at 0x10fc67320>, '#', <__main__.Root object at 0x10fc4bef0>, '-', <__main__.NominalizerTerminal object at 0x10fc4bfd0>, '-', <__main__.SemanticTerminal object at 0x10fc4bf98>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BALL terminal with values set()
we picked BALL_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#BALL-a
full_pronunciation: la#BALLa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: BALL to the selectional of the nominalizer whose values are {'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'a_2'}
    selectional: {'FROG', 'CHILD', 'BALL', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 37.40000000000028
    linear: (<__main__.NominalizerTerminal object at 0x10fc05f28>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'CHILD', 'BALL', 'FROG', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_6, triggers = set(), weight = 10.3..already existed

create_vi: tried nominalizer: null_7, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.799999999999997..already existed

create_vi: tried nominalizer: null_26, triggers = {('e', frozenset({'-atomic'}))}, weight = 11.899999999999997..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'PIBLING', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_14, triggers = set(), weight = 13.0..already existed

create_vi: tried nominalizer: null_15, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.999999999999996..already existed
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 75.10000000000008
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 38.50000000000016
VocabularyItem:
    pronunciation: BALL
    label: BALL
    values: set()
    diacritic: BALL_2
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 10.3
     what if we combine triggers with the otherwise identical vi BALL_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.399999999999977
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 24.600000000000023
line done
line done

---------------------

input line #210
input roots: [<__main__.Root object at 0x10fc2df28>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 75.70000000000007..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 39.100000000000165..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 25.500000000000107..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 75.80000000000007..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 36.60000000000017..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 25.600000000000108..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 75.90000000000006..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: KEY in its selectional

now working with the word 'KEY-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'null_32', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'KEY_1', 'null_32', 'i_1'}
     what if we combine triggers with the otherwise identical vi KEY_3 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'KEY_1', 'null_16', 'null_32', 'i_1', 'KEY_2'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50390>, '#', <__main__.Root object at 0x10fc6f518>, '-', <__main__.NominalizerTerminal object at 0x10fc6f668>, '-', <__main__.SemanticTerminal object at 0x10fc6fa58>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out KEY terminal with values set()
we picked KEY_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: le#KEY-i
full_pronunciation: l#KEYi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 75.90000000000006
VocabularyItem:
    pronunciation: KEY
    label: KEY
    values: set()
    diacritic: KEY_3
    triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.899999999999977
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 16.6
line done
line done

---------------------

input line #211
input roots: [<__main__.Root object at 0x10fc4bbe0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 39.200000000000166..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 75.90000000000006..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 34.700000000000166..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 34.80000000000017..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: KEY in its selectional

now working with the word 'KEY-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'KEY_1', 'null_10'}
     what if we combine triggers with the otherwise identical vi KEY_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'KEY_3', 'KEY_1', 'e_3', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc58f98>, '-', <__main__.AgrTerminal object at 0x10fc4bf98>, '#', <__main__.Root object at 0x10fc583c8>, '-', <__main__.NominalizerTerminal object at 0x10fc58160>, '-', <__main__.SemanticTerminal object at 0x10fc587b8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out KEY terminal with values set()
we picked KEY_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: una#KEY-e
full_pronunciation: uno#KEYa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 34.80000000000017
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 36.60000000000017
VocabularyItem:
    pronunciation: KEY
    label: KEY
    values: set()
    diacritic: KEY_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.799999999999976
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 25.100000000000023
line done
line done

---------------------

input line #212
input roots: [<__main__.Root object at 0x10fc58278>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 39.30000000000017..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 76.00000000000006..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 34.80000000000017..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 34.90000000000017..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'CHILD_1', 'a_1'}
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CHILD_1', 'a_1', 'CHILD_2', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a470>, '-', <__main__.AgrTerminal object at 0x10fc586d8>, '#', <__main__.Root object at 0x10fc6a278>, '-', <__main__.NominalizerTerminal object at 0x10fc6ac88>, '-', <__main__.SemanticTerminal object at 0x10fc6a518>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_5: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a', 'i_2', 'a_2'}
we picked null_24 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: una#CHILD-a
full_pronunciation: una#CHILDa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CHILD to the selectional of the nominalizer whose values are {'i_2', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'a_2'}
    selectional: {'BOOK', 'CHILD', 'BALL', 'PIBLING', 'GRANDPARENT', 'CAR', 'CLOWN', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 16.799999999999997
    linear: (<__main__.NominalizerTerminal object at 0x10fc36a90>,)
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 34.90000000000017
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 39.30000000000017
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_5
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 10.5
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2', 'a_2'}
    diacritic: null_24
    triggers: set()
    weight: 11.0
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 25.100000000000023
line done
line done

---------------------

input line #213
input roots: [<__main__.Root object at 0x10fc4bfd0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 76.10000000000005..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 39.90000000000017..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 25.50000000000009..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 76.20000000000005..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 36.60000000000017..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 25.60000000000009..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 76.30000000000004..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: CASTLE in its selectional

now working with the word 'CASTLE-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'CASTLE_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi CASTLE_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_15', 'i_1', 'null_14', 'CASTLE_1', 'CASTLE_3'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc43eb8>, '-', <__main__.AgrTerminal object at 0x10fc6a208>, '#', <__main__.Root object at 0x10fc43b00>, '-', <__main__.NominalizerTerminal object at 0x10fc43198>, '-', <__main__.SemanticTerminal object at 0x10fc43780>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CASTLE terminal with values set()
we picked CASTLE_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i_2'}
we picked null_14: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: li#CASTLE-i
full_pronunciation: li#CASTLEe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 76.30000000000004
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 25.60000000000009
VocabularyItem:
    pronunciation: CASTLE
    label: CASTLE
    values: set()
    diacritic: CASTLE_1
    triggers: set()
    weight: 10.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 13.0
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 12.899999999999999
line done
line done

---------------------

input line #214
input roots: [<__main__.Root object at 0x10fc6af28>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 40.00000000000017..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 76.30000000000004..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 35.50000000000017..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 35.60000000000017..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: FROG in its selectional

now working with the word 'FROG-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi FROG_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_2', 'a_1', 'FROG_1', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc45080>, '-', <__main__.AgrTerminal object at 0x10fc589e8>, '#', <__main__.Root object at 0x10fc45860>, '-', <__main__.NominalizerTerminal object at 0x10fc45588>, '-', <__main__.SemanticTerminal object at 0x10fc45438>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FROG terminal with values set()
we picked FROG_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'a_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: una#FROG-a
full_pronunciation: una#FROGa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: FROG to the selectional of the nominalizer whose values are {'e_1', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1', 'a_2'}
    selectional: {'FROG', 'BALL', 'CHILD', 'TOWER', 'PIBLING', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 19.2
    linear: (<__main__.NominalizerTerminal object at 0x10fc2aa20>,)
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 35.60000000000017
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 40.00000000000017
VocabularyItem:
    pronunciation: FROG
    label: FROG
    values: set()
    diacritic: FROG_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.699999999999974
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 25.700000000000024
line done
line done

---------------------

input line #215
input roots: [<__main__.Root object at 0x10fc42128>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 76.40000000000003..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 25.70000000000011..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 36.70000000000017..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 76.50000000000003..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 36.800000000000175..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 36.20000000000017..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 76.60000000000002..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 76.70000000000002..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 25.60000000000009..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 36.900000000000176..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FOOT in its selectional

now working with the word 'FOOT-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FOOT_1', 'null_8', 'e_3', 'null_19'}
     what if we combine triggers with the otherwise identical vi FOOT_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FOOT_1', 'e_3', 'FOOT_2', 'null_19'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc42b00>, '#', <__main__.Root object at 0x10fc671d0>, '-', <__main__.NominalizerTerminal object at 0x10fc67358>, '-', <__main__.SemanticTerminal object at 0x10fc67860>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '+atomic', 'i_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out FOOT terminal with values set()
we picked FOOT_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i_2'}
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: lo#FOOT-e
full_pronunciation: l#FOOTa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 76.70000000000002
VocabularyItem:
    pronunciation: FOOT
    label: FOOT
    values: set()
    diacritic: FOOT_1
    triggers: set()
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.199999999999974
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 26.200000000000024
line done
line done

---------------------

input line #216
input roots: [<__main__.Root object at 0x10fc367f0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 40.60000000000017..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 76.70000000000002..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 36.300000000000175..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 36.400000000000176..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'CHILD_1', 'a_1'}
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CHILD_1', 'a_1', 'CHILD_2', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67240>, '#', <__main__.Root object at 0x10fbff828>, '-', <__main__.NominalizerTerminal object at 0x10fc05630>, '-', <__main__.SemanticTerminal object at 0x10fc385c0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite', '+atomic'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out CHILD terminal with values set()
we picked CHILD_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values set()
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: una#CHILD-a
full_pronunciation: un#CHILDe
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 36.400000000000176
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_1
    triggers: set()
    weight: 9.600000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.099999999999973
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 13.5
line done
line done

---------------------

input line #217
input roots: [<__main__.Root object at 0x10fc67ef0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 76.80000000000001..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 25.80000000000011..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 37.00000000000018..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 76.9..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 37.10000000000018..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 36.400000000000176..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 77.0..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 77.1..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 25.70000000000009..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 37.20000000000018..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FLOWER in its selectional

now working with the word 'FLOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19', 'FLOWER_1'}
     what if we combine triggers with the otherwise identical vi FLOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FLOWER_3', 'e_3', 'null_19', 'FLOWER_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6f940>, '-', <__main__.AgrTerminal object at 0x10fc05e48>, '#', <__main__.Root object at 0x10fc6f2b0>, '-', <__main__.NominalizerTerminal object at 0x10fc6f6a0>, '-', <__main__.SemanticTerminal object at 0x10fc6f860>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'i_2', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FLOWER terminal with values set()
we picked FLOWER_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i_2', 'o_2'}
we picked null_14: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: lo#FLOWER-e
full_pronunciation: lo#FLOWERa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 77.1
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 37.20000000000018
VocabularyItem:
    pronunciation: FLOWER
    label: FLOWER
    values: set()
    diacritic: FLOWER_1
    triggers: set()
    weight: 9.600000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 12.9
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 26.200000000000024
line done
line done

---------------------

input line #218
input roots: [<__main__.Root object at 0x10fc676d8>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 77.1..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 40.70000000000017..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 25.900000000000112..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 77.19999999999999..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 37.20000000000018..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 26.000000000000114..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 77.29999999999998..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'GRANDPARENT_1', 'null_6'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_3 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'GRANDPARENT_7', 'null_26', 'GRANDPARENT_1', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc184e0>, '#', <__main__.Root object at 0x10fc67ba8>, '-', <__main__.NominalizerTerminal object at 0x10fc67d68>, '-', <__main__.SemanticTerminal object at 0x10fc672b0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: le#GRANDPARENT-e
full_pronunciation: l#GRANDPARENTi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 77.29999999999998
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_4
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.4
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.99999999999997
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 16.6
line done
line done

---------------------

input line #219
input roots: [<__main__.Root object at 0x10fc08550>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 77.29999999999998..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 26.100000000000115..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 37.30000000000018..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 77.39999999999998..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 37.40000000000018..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 36.50000000000018..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 77.49999999999997..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 77.59999999999997..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 25.800000000000093..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 37.500000000000185..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CHILD_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'CHILD_1', 'null_9', 'o_1', 'CHILD_3'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc3dd30>, '-', <__main__.AgrTerminal object at 0x10fc676a0>, '#', <__main__.Root object at 0x10fc452b0>, '-', <__main__.NominalizerTerminal object at 0x10fc457f0>, '-', <__main__.SemanticTerminal object at 0x10fc20ef0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_7: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: lo#CHILD-o
full_pronunciation: lo#CHILDa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 77.59999999999997
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 37.500000000000185
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_7
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 9.700000000000005
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 26.100000000000023
line done
line done

---------------------

input line #220
input roots: [<__main__.Root object at 0x10fc3dba8>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 77.59999999999997..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 26.200000000000117..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 37.500000000000185..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 77.69999999999996..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 37.600000000000186..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 36.60000000000018..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 77.79999999999995..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 77.89999999999995..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 25.900000000000095..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 37.70000000000019..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: MOUSE in its selectional

now working with the word 'MOUSE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'MOUSE_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi MOUSE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'MOUSE_2', 'MOUSE_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc28128>, '-', <__main__.AgrTerminal object at 0x10fc3dfd0>, '#', <__main__.Root object at 0x10fc438d0>, '-', <__main__.NominalizerTerminal object at 0x10fc43f60>, '-', <__main__.SemanticTerminal object at 0x10fc43278>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'i_2', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MOUSE terminal with values set()
we picked MOUSE_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: lo#MOUSE-o
full_pronunciation: la#MOUSEe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 77.89999999999995
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 40.70000000000017
VocabularyItem:
    pronunciation: MOUSE
    label: MOUSE
    values: set()
    diacritic: MOUSE_3
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.89999999999997
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 13.5
line done
line done

---------------------

input line #221
input roots: [<__main__.Root object at 0x10fc45f60>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 37.80000000000019..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 77.89999999999995..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 36.70000000000018..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 36.80000000000018..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CHILD_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'CHILD_1', 'null_9', 'o_1', 'CHILD_3'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6aef0>, '-', <__main__.AgrTerminal object at 0x10fc433c8>, '#', <__main__.Root object at 0x10fc6ae48>, '-', <__main__.NominalizerTerminal object at 0x10fc6a7b8>, '-', <__main__.SemanticTerminal object at 0x10fc6a2e8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: uno#CHILD-o
full_pronunciation: uno#CHILDa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 36.80000000000018
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 37.80000000000019
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_4
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.79999999999997
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 26.00000000000002
line done
line done

---------------------

input line #222
input roots: [<__main__.Root object at 0x10fc3bf28>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 37.80000000000019..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 77.99999999999994..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 36.80000000000018..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 36.90000000000018..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CASTLE in its selectional

now working with the word 'CASTLE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CASTLE_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CASTLE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'CASTLE_2', 'o_1', 'CASTLE_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc586d8>, '-', <__main__.AgrTerminal object at 0x10fc6a748>, '#', <__main__.Root object at 0x10fc58470>, '-', <__main__.NominalizerTerminal object at 0x10fc58198>, '-', <__main__.SemanticTerminal object at 0x10fc58860>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CASTLE terminal with values set()
we picked CASTLE_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'a_2', 'o'}
we picked null_6 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: uno#CASTLE-o
full_pronunciation: una#CASTLEo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 36.90000000000018
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 40.60000000000017
VocabularyItem:
    pronunciation: CASTLE
    label: CASTLE
    values: set()
    diacritic: CASTLE_4
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_6
    triggers: set()
    weight: 10.3
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 20.500000000000007
line done
line done

---------------------

input line #223
input roots: [<__main__.Root object at 0x10fc6a358>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 78.09999999999994..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 40.60000000000017..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 26.000000000000096..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 78.19999999999993..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 37.90000000000019..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 26.100000000000097..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 78.29999999999993..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'CHILD_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi CHILD_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CHILD_1', 'null_15', 'CHILD_4', 'i_1', 'null_14'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6ab70>, '#', <__main__.Root object at 0x10fc50b38>, '-', <__main__.NominalizerTerminal object at 0x10fc50f98>, '-', <__main__.SemanticTerminal object at 0x10fc505c0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked li_1: no super match (neither decl nor L1-gender)
now spelling out CHILD terminal with values set()
we picked CHILD_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: li#CHILD-i
full_pronunciation: li#CHILDi
vis_used:
Successful derivation!
VocabularyItem:
    pronunciation: li
    label: definite
    values: {'+definite', '-atomic'}
    diacritic: li_1
    triggers: set()
    weight: 10.100000000000001
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_3
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 9.600000000000001
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.699999999999967
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 16.6
line done
line done

---------------------

input line #224
input roots: [<__main__.Root object at 0x10fc50240>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 78.39999999999992..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 40.70000000000017..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 26.300000000000118..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 78.49999999999991..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 38.00000000000019..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 26.40000000000012..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 78.59999999999991..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: CAR in its selectional

now working with the word 'CAR-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'null_17'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'CAR_1', 'null_17'}
     what if we combine triggers with the otherwise identical vi CAR_3 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'CAR_2', 'null_16', 'null_17', 'CAR_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6f898>, '-', <__main__.AgrTerminal object at 0x10fc4beb8>, '#', <__main__.Root object at 0x10fc6f208>, '-', <__main__.NominalizerTerminal object at 0x10fc6f358>, '-', <__main__.SemanticTerminal object at 0x10fc6f978>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'o_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CAR terminal with values set()
we picked CAR_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: le#CAR-e
full_pronunciation: li#CARe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 78.59999999999991
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 26.100000000000097
VocabularyItem:
    pronunciation: CAR
    label: CAR
    values: set()
    diacritic: CAR_3
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.199999999999967
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 12.999999999999998
line done
line done

---------------------

input line #225
input roots: [<__main__.Root object at 0x10fc42908>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 40.800000000000175..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 78.59999999999991..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 36.90000000000018..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 37.000000000000185..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1', 'e_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: KEY in its selectional

now working with the word 'KEY-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'e_3', 'null_22'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'e_3', 'KEY_1', 'null_22'}
     what if we combine triggers with the otherwise identical vi KEY_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'KEY_3', 'KEY_1', 'null_16', 'null_22', 'e_3'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6f940>, '#', <__main__.Root object at 0x10fc4bac8>, '-', <__main__.NominalizerTerminal object at 0x10fc4ba58>, '-', <__main__.SemanticTerminal object at 0x10fc4b0b8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite', '+atomic'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out KEY terminal with values set()
we picked KEY_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: una#KEY-e
full_pronunciation: un#KEYo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 37.000000000000185
VocabularyItem:
    pronunciation: KEY
    label: KEY
    values: set()
    diacritic: KEY_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.099999999999966
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 20.400000000000006
line done
line done

---------------------

input line #226
input roots: [<__main__.Root object at 0x10fc4be10>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 78.6999999999999..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 26.50000000000012..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 38.10000000000019..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 78.7999999999999..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 38.200000000000195..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 37.000000000000185..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 78.89999999999989..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 78.99999999999989..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 26.100000000000097..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 38.300000000000196..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CLOWN in its selectional

now working with the word 'CLOWN-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CLOWN_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CLOWN_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'CLOWN_3', 'o_1', 'CLOWN_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc58160>, '-', <__main__.AgrTerminal object at 0x10fc4bf28>, '#', <__main__.Root object at 0x10fc586d8>, '-', <__main__.NominalizerTerminal object at 0x10fc58860>, '-', <__main__.SemanticTerminal object at 0x10fc58470>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CLOWN terminal with values set()
we picked CLOWN_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: lo#CLOWN-o
full_pronunciation: lo#CLOWNa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 78.99999999999989
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 38.300000000000196
VocabularyItem:
    pronunciation: CLOWN
    label: CLOWN
    values: set()
    diacritic: CLOWN_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.999999999999964
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 25.90000000000002
line done
line done

---------------------

input line #227
input roots: [<__main__.Root object at 0x10fc58278>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 38.300000000000196..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 78.99999999999989..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 37.100000000000186..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 37.20000000000019..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CLOWN in its selectional

now working with the word 'CLOWN-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CLOWN_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CLOWN_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'CLOWN_3', 'o_1', 'CLOWN_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a588>, '-', <__main__.AgrTerminal object at 0x10fc58f28>, '#', <__main__.Root object at 0x10fc6ae48>, '-', <__main__.NominalizerTerminal object at 0x10fc6a080>, '-', <__main__.SemanticTerminal object at 0x10fc6a7f0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CLOWN terminal with values set()
we picked CLOWN_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'i_2', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: uno#CLOWN-o
full_pronunciation: una#CLOWNo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 37.20000000000019
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 40.800000000000175
VocabularyItem:
    pronunciation: CLOWN
    label: CLOWN
    values: set()
    diacritic: CLOWN_4
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.200000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.899999999999963
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 20.500000000000007
line done
line done

---------------------

input line #228
input roots: [<__main__.Root object at 0x10fc6a8d0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 79.09999999999988..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 26.600000000000122..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 40.800000000000175..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 79.19999999999987..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 40.900000000000176..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 37.20000000000019..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 79.29999999999987..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 79.39999999999986..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 26.2000000000001..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 41.00000000000018..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1', 'e_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: FROG in its selectional

now working with the word 'FROG-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'null_27', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_1', 'null_16', 'null_27', 'a_1'}
     what if we combine triggers with the otherwise identical vi FROG_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_2', 'a_1', 'null_16', 'null_27', 'FROG_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a6a0>, '#', <__main__.Root object at 0x10fc43780>, '-', <__main__.NominalizerTerminal object at 0x10fc43b00>, '-', <__main__.SemanticTerminal object at 0x10fc433c8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', 'e_1', '+atomic'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out FROG terminal with values set()
we picked FROG_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1', 'null'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: la#FROG-a
full_pronunciation: l#FROGa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 79.39999999999986
VocabularyItem:
    pronunciation: FROG
    label: FROG
    values: set()
    diacritic: FROG_3
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.79999999999996
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 25.90000000000002
line done
line done

---------------------

input line #229
input roots: [<__main__.Root object at 0x10fc4beb8>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 79.39999999999986..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 26.700000000000124..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 41.10000000000018..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 79.49999999999986..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 41.20000000000018..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 37.30000000000019..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 79.59999999999985..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 79.69999999999985..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 26.3000000000001..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 41.30000000000018..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1', 'e_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: CAR in its selectional

now working with the word 'CAR-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'null_27', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'null_27', 'a_1', 'CAR_1'}
     what if we combine triggers with the otherwise identical vi CAR_2 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'null_16', 'CAR_1', 'null_27', 'CAR_3'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc458d0>, '-', <__main__.AgrTerminal object at 0x10fc42128>, '#', <__main__.Root object at 0x10fc457f0>, '-', <__main__.NominalizerTerminal object at 0x10fc45940>, '-', <__main__.SemanticTerminal object at 0x10fc45860>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CAR terminal with values set()
we picked CAR_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#CAR-a
full_pronunciation: lo#CARa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 79.69999999999985
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 38.300000000000196
VocabularyItem:
    pronunciation: CAR
    label: CAR
    values: set()
    diacritic: CAR_3
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.69999999999996
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 25.90000000000002
line done
line done

---------------------

input line #230
input roots: [<__main__.Root object at 0x10fc455f8>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 41.40000000000018..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 79.69999999999985..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 37.40000000000019..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 37.50000000000019..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: MILKCOW in its selectional

now working with the word 'MILKCOW-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'MILKCOW_1'}
     what if we combine triggers with the otherwise identical vi MILKCOW_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'MILKCOW_1', 'MILKCOW_2', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6fa90>, '-', <__main__.AgrTerminal object at 0x10fc3d198>, '#', <__main__.Root object at 0x10fc6f748>, '-', <__main__.NominalizerTerminal object at 0x10fc6f898>, '-', <__main__.SemanticTerminal object at 0x10fc6f358>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MILKCOW terminal with values set()
we picked MILKCOW_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'a_2'}
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: una#MILKCOW-a
full_pronunciation: una#MILKCOWo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 37.50000000000019
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 41.40000000000018
VocabularyItem:
    pronunciation: MILKCOW
    label: MILKCOW
    values: set()
    diacritic: MILKCOW_1
    triggers: set()
    weight: 10.200000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.59999999999996
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 20.400000000000006
line done
line done

---------------------

input line #231
input roots: [<__main__.Root object at 0x10fc6f198>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 79.79999999999984..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 26.800000000000125..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 41.40000000000018..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 79.89999999999984..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 41.500000000000185..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 37.50000000000019..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 79.99999999999983..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 80.09999999999982..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 26.4000000000001..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 41.600000000000186..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1', 'e_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: TOWER in its selectional

now working with the word 'TOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'e_3', 'null_22'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'TOWER_1', 'null_16', 'e_3', 'null_22'}
     what if we combine triggers with the otherwise identical vi TOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'TOWER_1', 'TOWER_3', 'null_16', 'null_22', 'e_3'}
done processing input, time to test
we selected the nominalizer with values: {'e_1'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67e10>, '#', <__main__.Root object at 0x10fc67198>, '-', <__main__.NominalizerTerminal object at 0x10fc672e8>, '-', <__main__.SemanticTerminal object at 0x10fc67080>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', 'e_1', '+atomic'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out TOWER terminal with values set()
we picked TOWER_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1'}
we picked null_26: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: la#TOWER-e
full_pronunciation: l#TOWERe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 80.09999999999982
VocabularyItem:
    pronunciation: TOWER
    label: TOWER
    values: set()
    diacritic: TOWER_1
    triggers: set()
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_26
    triggers: {('e', frozenset({'-atomic'}))}
    weight: 11.899999999999997
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 13.6
line done
line done

---------------------

input line #232
input roots: [<__main__.Root object at 0x10fc42198>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 80.09999999999982..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 41.70000000000019..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 26.500000000000103..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 80.19999999999982..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 38.300000000000196..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 26.600000000000104..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 80.29999999999981..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'GRANDPARENT_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_3 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_15', 'GRANDPARENT_4', 'i_1', 'null_14', 'GRANDPARENT_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc671d0>, '#', <__main__.Root object at 0x10fc185c0>, '-', <__main__.NominalizerTerminal object at 0x10fc18358>, '-', <__main__.SemanticTerminal object at 0x10fc47588>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: li#GRANDPARENT-i
full_pronunciation: l#GRANDPARENTi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 80.29999999999981
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_2
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 10.100000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.499999999999957
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 17.200000000000003
line done
line done

---------------------

input line #233
input roots: [<__main__.Root object at 0x10fc226d8>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 80.29999999999981..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 41.80000000000019..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 26.700000000000106..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 80.3999999999998..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 38.4000000000002..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 26.800000000000107..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 80.4999999999998..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: FLOWER in its selectional

now working with the word 'FLOWER-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'FLOWER_1', 'i_1'}
     what if we combine triggers with the otherwise identical vi FLOWER_3 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'FLOWER_2', 'null_13', 'i_1', 'FLOWER_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67198>, '-', <__main__.AgrTerminal object at 0x10fc22c88>, '#', <__main__.Root object at 0x10fc67160>, '-', <__main__.NominalizerTerminal object at 0x10fc670b8>, '-', <__main__.SemanticTerminal object at 0x10fc67080>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'a_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FLOWER terminal with values set()
we picked FLOWER_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'a_2'}
we picked null_14 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: li#FLOWER-i
full_pronunciation: li#FLOWERi
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: FLOWER to the selectional of the nominalizer whose values are {'i_2', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'a_2'}
    selectional: {'BOOK', 'CHILD', 'BALL', 'PIBLING', 'GRANDPARENT', 'CAR', 'CLOWN', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 17.0
    linear: (<__main__.NominalizerTerminal object at 0x10fc36a90>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 80.4999999999998
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 26.800000000000107
VocabularyItem:
    pronunciation: FLOWER
    label: FLOWER
    values: set()
    diacritic: FLOWER_3
    triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))}
    weight: 9.9
     what if we combine triggers with the otherwise identical vi FLOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 12.8
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 17.200000000000003
line done
line done

---------------------

input line #234
input roots: [<__main__.Root object at 0x10fc185c0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 81.0999999999998..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 41.90000000000019..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 27.40000000000011..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 81.19999999999979..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 38.5000000000002..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 27.50000000000011..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 81.29999999999978..already existed
  we're in a functional word...
  - nominalizer's values are now {'a_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'a_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_24', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_24', 'i_1', 'null_28'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'GRANDPARENT_1', 'null_24', 'i_1', 'null_28'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_3 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_28', 'null_24', 'i_1', 'GRANDPARENT_4', 'GRANDPARENT_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc455f8>, '-', <__main__.AgrTerminal object at 0x10fc67d30>, '#', <__main__.Root object at 0x10fc45438>, '-', <__main__.NominalizerTerminal object at 0x10fc450f0>, '-', <__main__.SemanticTerminal object at 0x10fc452b0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_5: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'e_1', 'null'}
we picked null_6 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#GRANDPARENT-i
full_pronunciation: le#GRANDPARENTi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 81.29999999999978
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 26.800000000000125
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_5
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_6
    triggers: set()
    weight: 10.200000000000001
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 17.800000000000004
line done
line done

---------------------

input line #235
input roots: [<__main__.Root object at 0x10fc3dd30>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 42.00000000000019..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 81.29999999999978..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 37.60000000000019..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 37.700000000000195..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'GRANDPARENT_1'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'GRANDPARENT_1', 'null_11', 'null_10', 'GRANDPARENT_3'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc45518>, '#', <__main__.Root object at 0x10fc43940>, '-', <__main__.NominalizerTerminal object at 0x10fc439e8>, '-', <__main__.SemanticTerminal object at 0x10fc43860>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite', 'i_2', '+atomic'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_7: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2'}
we picked null_14 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: una#GRANDPARENT-a
full_pronunciation: un#GRANDPARENTo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 37.700000000000195
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_7
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 13.3
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 20.300000000000004
line done
line done

---------------------

input line #236
input roots: [<__main__.Root object at 0x10fc43630>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 81.39999999999978..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 42.10000000000019..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 27.60000000000011..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 81.49999999999977..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 38.6000000000002..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 27.700000000000113..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 81.59999999999977..already existed
  we're in a functional word...
  - nominalizer's values are now {'a_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'a_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_24', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_24', 'i_1', 'null_28'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_24', 'CHILD_1', 'i_1', 'null_28'}
     what if we combine triggers with the otherwise identical vi CHILD_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CHILD_1', 'null_28', 'null_24', 'CHILD_4', 'i_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a780>, '-', <__main__.AgrTerminal object at 0x10fc42b00>, '#', <__main__.Root object at 0x10fc6af28>, '-', <__main__.NominalizerTerminal object at 0x10fc6a438>, '-', <__main__.SemanticTerminal object at 0x10fc6ae10>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'a_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: li#CHILD-i
full_pronunciation: li#CHILDe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 81.59999999999977
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 27.700000000000113
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_2
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 11.3
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.399999999999956
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 12.899999999999999
line done
line done

---------------------

input line #237
input roots: [<__main__.Root object at 0x10fc08550>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 81.59999999999977..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 42.200000000000195..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 26.800000000000125..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 81.69999999999976..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 38.7000000000002..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 26.900000000000126..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 81.79999999999976..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: MILKCOW in its selectional

now working with the word 'MILKCOW-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'MILKCOW_1', 'null_6'}
     what if we combine triggers with the otherwise identical vi MILKCOW_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'MILKCOW_3', 'MILKCOW_1', 'null_26', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc584a8>, '-', <__main__.AgrTerminal object at 0x10fc6a0b8>, '#', <__main__.Root object at 0x10fc58400>, '-', <__main__.NominalizerTerminal object at 0x10fc58128>, '-', <__main__.SemanticTerminal object at 0x10fc584e0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic', 'a_2'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MILKCOW terminal with values set()
we picked MILKCOW_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1', 'a_2'}
we picked null_22: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: le#MILKCOW-e
full_pronunciation: le#MILKCOWe
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: MILKCOW to the selectional of the nominalizer whose values are {'e_1', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1', 'a_2'}
    selectional: {'FROG', 'BALL', 'CHILD', 'TOWER', 'PIBLING', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 19.90000000000001
    linear: (<__main__.NominalizerTerminal object at 0x10fc2aa20>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 81.79999999999976
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 26.900000000000126
VocabularyItem:
    pronunciation: MILKCOW
    label: MILKCOW
    values: set()
    diacritic: MILKCOW_1
    triggers: set()
    weight: 10.100000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1', 'a_2'}
    diacritic: null_22
    triggers: {('e', frozenset({'+atomic'}))}
    weight: 10.5
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 12.899999999999999
line done
line done

---------------------

input line #238
input roots: [<__main__.Root object at 0x10fc6a3c8>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 38.8000000000002..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 82.39999999999975..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 37.700000000000195..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 37.800000000000196..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CASTLE in its selectional

now working with the word 'CASTLE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CASTLE_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CASTLE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'CASTLE_2', 'o_1', 'CASTLE_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6f860>, '-', <__main__.AgrTerminal object at 0x10fc6ab70>, '#', <__main__.Root object at 0x10fc6f048>, '-', <__main__.NominalizerTerminal object at 0x10fc6fb00>, '-', <__main__.SemanticTerminal object at 0x10fc6f8d0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CASTLE terminal with values set()
we picked CASTLE_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: uno#CASTLE-o
full_pronunciation: una#CASTLEe
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 37.800000000000196
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 42.200000000000195
VocabularyItem:
    pronunciation: CASTLE
    label: CASTLE
    values: set()
    diacritic: CASTLE_3
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.299999999999955
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 13.5
line done
line done

---------------------

input line #239
input roots: [<__main__.Root object at 0x10fc42048>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 82.49999999999974..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 27.500000000000128..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 38.900000000000205..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 82.59999999999974..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 39.000000000000206..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 37.800000000000196..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 82.69999999999973..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 82.79999999999973..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 27.700000000000113..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 39.10000000000021..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CASTLE in its selectional

now working with the word 'CASTLE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CASTLE_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CASTLE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'CASTLE_2', 'o_1', 'CASTLE_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4ba58>, '-', <__main__.AgrTerminal object at 0x10fc6ff98>, '#', <__main__.Root object at 0x10fc86550>, '-', <__main__.NominalizerTerminal object at 0x10fc865f8>, '-', <__main__.SemanticTerminal object at 0x10fc866a0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CASTLE terminal with values set()
we picked CASTLE_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: lo#CASTLE-o
full_pronunciation: la#CASTLEo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 82.79999999999973
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 42.10000000000019
VocabularyItem:
    pronunciation: CASTLE
    label: CASTLE
    values: set()
    diacritic: CASTLE_4
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.199999999999953
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 20.400000000000006
line done
line done

---------------------

input line #240
input roots: [<__main__.Root object at 0x10fc6f0f0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 82.79999999999973..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 27.60000000000013..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 39.20000000000021..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 82.89999999999972..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 39.30000000000021..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 37.9000000000002..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 82.99999999999972..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 83.09999999999971..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 27.800000000000114..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 39.40000000000021..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FOOT in its selectional

now working with the word 'FOOT-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FOOT_1', 'null_8', 'e_3', 'null_19'}
     what if we combine triggers with the otherwise identical vi FOOT_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FOOT_1', 'e_3', 'FOOT_2', 'null_19'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc45518>, '#', <__main__.Root object at 0x10fc3d470>, '-', <__main__.NominalizerTerminal object at 0x10fc207b8>, '-', <__main__.SemanticTerminal object at 0x10fc45e80>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '+atomic', 'i_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out FOOT terminal with values set()
we picked FOOT_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: lo#FOOT-e
full_pronunciation: l#FOOTo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 83.09999999999971
VocabularyItem:
    pronunciation: FOOT
    label: FOOT
    values: set()
    diacritic: FOOT_3
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.09999999999995
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 20.300000000000004
line done
line done

---------------------

input line #241
input roots: [<__main__.Root object at 0x10fc45860>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 42.10000000000019..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 83.09999999999971..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 38.0000000000002..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 38.1000000000002..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'GRANDPARENT_1'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'GRANDPARENT_1', 'null_11', 'null_10', 'GRANDPARENT_3'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc43630>, '-', <__main__.AgrTerminal object at 0x10fc14668>, '#', <__main__.Root object at 0x10fc43208>, '-', <__main__.NominalizerTerminal object at 0x10fc43710>, '-', <__main__.SemanticTerminal object at 0x10fc439e8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: una#GRANDPARENT-a
full_pronunciation: una#GRANDPARENTe
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 38.1000000000002
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 42.10000000000019
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_4
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.3
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 19.99999999999995
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 13.5
line done
line done

---------------------

input line #242
input roots: [<__main__.Root object at 0x10fc427b8>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 83.1999999999997..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 42.10000000000019..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 27.70000000000013..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 83.2999999999997..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 39.50000000000021..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 27.800000000000132..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 83.3999999999997..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: TOWER in its selectional

now working with the word 'TOWER-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'null_32', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'TOWER_1', 'null_16', 'null_32', 'i_1'}
     what if we combine triggers with the otherwise identical vi TOWER_3 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'TOWER_1', 'null_16', 'null_32', 'i_1', 'TOWER_2'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6f710>, '#', <__main__.Root object at 0x10fc6f550>, '-', <__main__.NominalizerTerminal object at 0x10fc6f080>, '-', <__main__.SemanticTerminal object at 0x10fc6f940>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out TOWER terminal with values set()
we picked TOWER_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: le#TOWER-i
full_pronunciation: l#TOWERe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 83.3999999999997
VocabularyItem:
    pronunciation: TOWER
    label: TOWER
    values: set()
    diacritic: TOWER_3
    triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))}
    weight: 10.4
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 19.89999999999995
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 13.399999999999999
line done
line done

---------------------

input line #243
input roots: [<__main__.Root object at 0x10fc6f7b8>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 83.3999999999997..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 27.900000000000134..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 42.200000000000195..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 83.49999999999969..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 42.300000000000196..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 38.1000000000002..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 83.59999999999968..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 83.69999999999968..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 27.900000000000116..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 42.4000000000002..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'OFFSPRING_1', 'null_11', 'null_10', 'OFFSPRING_5'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4bcc0>, '-', <__main__.AgrTerminal object at 0x10fc43940>, '#', <__main__.Root object at 0x10fc4b940>, '-', <__main__.NominalizerTerminal object at 0x10fc4b390>, '-', <__main__.SemanticTerminal object at 0x10fc4b5c0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: la#OFFSPRING-a
full_pronunciation: la#OFFSPRINGo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 83.69999999999968
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 42.4000000000002
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_3
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 19.799999999999947
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 20.200000000000003
line done
line done

---------------------

input line #244
input roots: [<__main__.Root object at 0x10fc4b0f0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 83.69999999999968..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 42.4000000000002..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 28.000000000000135..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 83.79999999999967..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 39.600000000000215..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 28.100000000000136..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 83.89999999999966..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'GRANDPARENT_1', 'null_6'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_3 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'GRANDPARENT_7', 'null_26', 'GRANDPARENT_1', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b668>, '#', <__main__.Root object at 0x10fc67eb8>, '-', <__main__.NominalizerTerminal object at 0x10fc67cc0>, '-', <__main__.SemanticTerminal object at 0x10fc67cf8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_6: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: le#GRANDPARENT-e
full_pronunciation: l#GRANDPARENTi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 83.89999999999966
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_6
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 10.500000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 10.200000000000006
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 17.900000000000006
line done
line done

---------------------

input line #245
input roots: [<__main__.Root object at 0x10fc6f518>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 39.700000000000216..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 83.89999999999966..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 38.2000000000002..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 38.3000000000002..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CHILD_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'CHILD_1', 'null_9', 'o_1', 'CHILD_3'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc41cf8>, '-', <__main__.AgrTerminal object at 0x10fc67da0>, '#', <__main__.Root object at 0x10fc3ecf8>, '-', <__main__.NominalizerTerminal object at 0x10fc3eac8>, '-', <__main__.SemanticTerminal object at 0x10fc41c50>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_9: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: uno#CHILD-o
full_pronunciation: uno#CHILDo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CHILD to the selectional of the nominalizer whose values are {'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'o_2'}
    selectional: {'MOUSE', 'CHILD', 'BOOK', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 41.90000000000035
    linear: (<__main__.NominalizerTerminal object at 0x10fc08908>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_20, triggers = set(), weight = 11.1..already existed

create_vi: tried nominalizer: null_30, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.0..already existed

create_vi: tried nominalizer: null_31, triggers = {('e', frozenset({'-atomic'}))}, weight = 10.2..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_12, triggers = set(), weight = 10.7..already existed

create_vi: tried nominalizer: null_13, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.1..already existed
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 38.3000000000002
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 39.700000000000216
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_9
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.4
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 9.600000000000005
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 20.200000000000003
line done
line done

---------------------

input line #246
input roots: [<__main__.Root object at 0x10fc41080>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 40.30000000000022..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 83.99999999999966..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 38.900000000000205..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 39.000000000000206..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CHILD_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'CHILD_1', 'null_9', 'o_1', 'CHILD_3'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67b00>, '#', <__main__.Root object at 0x10fc6a048>, '-', <__main__.NominalizerTerminal object at 0x10fc6a400>, '-', <__main__.SemanticTerminal object at 0x10fc6ae80>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite', 'i_2', '+atomic'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out CHILD terminal with values set()
we picked CHILD_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: uno#CHILD-o
full_pronunciation: un#CHILDa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 39.000000000000206
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_2
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 11.200000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 19.699999999999946
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 26.200000000000024
line done
line done

---------------------

input line #247
input roots: [<__main__.Root object at 0x10fc6ac88>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 84.09999999999965..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 42.5000000000002..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 28.000000000000117..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 84.19999999999965..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 40.40000000000022..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 28.10000000000012..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 84.29999999999964..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: MOUSE in its selectional

now working with the word 'MOUSE-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'MOUSE_1', 'null_12', 'null_13', 'i_1'}
     what if we combine triggers with the otherwise identical vi MOUSE_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'MOUSE_3', 'null_12', 'null_13', 'i_1', 'MOUSE_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6ad30>, '-', <__main__.AgrTerminal object at 0x10fc6aba8>, '#', <__main__.Root object at 0x10fc6a8d0>, '-', <__main__.NominalizerTerminal object at 0x10fc6a198>, '-', <__main__.SemanticTerminal object at 0x10fc505f8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MOUSE terminal with values set()
we picked MOUSE_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'i_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#MOUSE-i
full_pronunciation: li#MOUSEi
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: MOUSE to the selectional of the nominalizer whose values are {'i_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2'}
    selectional: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'OFFSPRING'}
    selection_strength: True
    weight: 11.999999999999993
    linear: (<__main__.NominalizerTerminal object at 0x10fc0ecc0>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'a_2'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'a_2'}

create_vi: tried nominalizer: null_10, triggers = set(), weight = 10.200000000000006..already existed

create_vi: tried nominalizer: null_11, triggers = {('a', frozenset({'+atomic'}))}, weight = 11.3..already existed

create_vi: tried nominalizer: null_29, triggers = {('e', frozenset({'+atomic'}))}, weight = 9.9..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'o_2'} as values: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'o_2'}

create_vi: tried nominalizer: null_8, triggers = set(), weight = 10.200000000000005..already existed

create_vi: tried nominalizer: null_9, triggers = {('o', frozenset({'+atomic'}))}, weight = 10.3..already existed

create_vi: tried nominalizer: null_19, triggers = {('e', frozenset({'+atomic'}))}, weight = 9.9..already existed
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 84.29999999999964
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 28.10000000000012
VocabularyItem:
    pronunciation: MOUSE
    label: MOUSE
    values: set()
    diacritic: MOUSE_3
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.8
     what if we combine triggers with the otherwise identical vi MOUSE_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 19.599999999999945
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 17.900000000000006
line done
line done

---------------------

input line #248
input roots: [<__main__.Root object at 0x10fc6a828>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 84.89999999999964..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 28.200000000000138..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 42.6000000000002..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 84.99999999999963..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 42.7000000000002..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 39.000000000000206..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 85.09999999999962..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 85.19999999999962..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 28.70000000000012..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 42.8000000000002..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: MILKCOW in its selectional

now working with the word 'MILKCOW-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'MILKCOW_1'}
     what if we combine triggers with the otherwise identical vi MILKCOW_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'MILKCOW_1', 'MILKCOW_2', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc3eac8>, '-', <__main__.AgrTerminal object at 0x10fc6aac8>, '#', <__main__.Root object at 0x10fc41cf8>, '-', <__main__.NominalizerTerminal object at 0x10fc41c50>, '-', <__main__.SemanticTerminal object at 0x10fc419b0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MILKCOW terminal with values set()
we picked MILKCOW_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: la#MILKCOW-a
full_pronunciation: la#MILKCOWe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 85.19999999999962
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 42.8000000000002
VocabularyItem:
    pronunciation: MILKCOW
    label: MILKCOW
    values: set()
    diacritic: MILKCOW_3
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 9.500000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.099999999999945
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 13.4
line done
line done

---------------------

input line #249
input roots: [<__main__.Root object at 0x10fc6a6d8>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 85.19999999999962..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 42.8000000000002..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 28.80000000000012..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 85.29999999999961..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 40.50000000000022..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 28.900000000000123..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 85.39999999999961..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: FOOT in its selectional

now working with the word 'FOOT-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FOOT_1', 'null_12', 'null_13', 'i_1'}
     what if we combine triggers with the otherwise identical vi FOOT_2 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'FOOT_3', 'FOOT_1', 'null_13', 'i_1'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a9b0>, '#', <__main__.Root object at 0x10fc672e8>, '-', <__main__.NominalizerTerminal object at 0x10fc67860>, '-', <__main__.SemanticTerminal object at 0x10fc67f28>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out FOOT terminal with values set()
we picked FOOT_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#FOOT-i
full_pronunciation: l#FOOTi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 85.39999999999961
VocabularyItem:
    pronunciation: FOOT
    label: FOOT
    values: set()
    diacritic: FOOT_4
    triggers: {('null', frozenset()), ('e', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 10.5
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 19.999999999999943
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 18.500000000000007
line done
line done

---------------------

input line #250
input roots: [<__main__.Root object at 0x10fc67ba8>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 85.39999999999961..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 28.30000000000014..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 40.60000000000022..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 85.4999999999996..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 40.70000000000022..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 39.10000000000021..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 85.5999999999996..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 85.69999999999959..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 29.000000000000124..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 40.800000000000225..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'GRANDPARENT_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'GRANDPARENT_1', 'GRANDPARENT_2'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b470>, '-', <__main__.AgrTerminal object at 0x10fc3cf28>, '#', <__main__.Root object at 0x10fc4b2b0>, '-', <__main__.NominalizerTerminal object at 0x10fc4bb70>, '-', <__main__.SemanticTerminal object at 0x10fc4b5f8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'i_2', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_7: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'a_2'}
we picked null_14 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: lo#GRANDPARENT-o
full_pronunciation: la#GRANDPARENTe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 85.69999999999959
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 42.8000000000002
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_7
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 13.200000000000001
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 13.3
line done
line done

---------------------

input line #251
input roots: [<__main__.Root object at 0x10fc3e080>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 42.8000000000002..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 85.69999999999959..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 39.20000000000021..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 39.30000000000021..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: MILKCOW in its selectional

now working with the word 'MILKCOW-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'MILKCOW_1'}
     what if we combine triggers with the otherwise identical vi MILKCOW_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'MILKCOW_1', 'MILKCOW_2', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc43eb8>, '-', <__main__.AgrTerminal object at 0x10fc4bcc0>, '#', <__main__.Root object at 0x10fc42908>, '-', <__main__.NominalizerTerminal object at 0x10fc43b00>, '-', <__main__.SemanticTerminal object at 0x10fc43f60>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MILKCOW terminal with values set()
we picked MILKCOW_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: una#MILKCOW-a
full_pronunciation: uno#MILKCOWa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 39.30000000000021
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 40.800000000000225
VocabularyItem:
    pronunciation: MILKCOW
    label: MILKCOW
    values: set()
    diacritic: MILKCOW_3
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 9.400000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 10.200000000000005
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 26.300000000000026
line done
line done

---------------------

input line #252
input roots: [<__main__.Root object at 0x10fc43630>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 85.79999999999959..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 42.900000000000205..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 28.40000000000014..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 85.89999999999958..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 40.800000000000225..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 28.500000000000142..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 85.99999999999957..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: TOWER in its selectional

now working with the word 'TOWER-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_6', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_6', 'null_7', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'TOWER_1', 'null_6', 'null_7', 'i_1'}
     what if we combine triggers with the otherwise identical vi TOWER_3 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'TOWER_1', 'null_7', 'i_1', 'TOWER_2', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b4e0>, '#', <__main__.Root object at 0x10fc6feb8>, '-', <__main__.NominalizerTerminal object at 0x10fc6f9b0>, '-', <__main__.SemanticTerminal object at 0x10fc6f2e8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out TOWER terminal with values set()
we picked TOWER_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'a_2'}
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: le#TOWER-i
full_pronunciation: l#TOWERe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 85.99999999999957
VocabularyItem:
    pronunciation: TOWER
    label: TOWER
    values: set()
    diacritic: TOWER_1
    triggers: set()
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 19.89999999999994
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 13.399999999999999
line done
line done

---------------------

input line #253
input roots: [<__main__.Root object at 0x10fc6f3c8>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 85.99999999999957..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 43.000000000000206..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 28.600000000000144..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 86.09999999999957..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 40.900000000000226..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 28.700000000000145..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 86.19999999999956..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: CAR in its selectional

now working with the word 'CAR-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'null_17'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'CAR_1', 'null_17'}
     what if we combine triggers with the otherwise identical vi CAR_3 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'CAR_2', 'null_16', 'null_17', 'CAR_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc3d128>, '-', <__main__.AgrTerminal object at 0x10fc6f7b8>, '#', <__main__.Root object at 0x10fc20b38>, '-', <__main__.NominalizerTerminal object at 0x10fc20ef0>, '-', <__main__.SemanticTerminal object at 0x10fc3dda0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic', 'o_2'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CAR terminal with values set()
we picked CAR_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e', 'e_1', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: le#CAR-e
full_pronunciation: le#CARe
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CAR to the selectional of the nominalizer whose values are {'e_1', 'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1', 'o_2'}
    selectional: {'BOOK', 'CHILD', 'PIBLING', 'GRANDPARENT', 'CLOWN', 'OFFSPRING'}
    selection_strength: True
    weight: 15.099999999999996
    linear: (<__main__.NominalizerTerminal object at 0x10fc3d400>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 86.19999999999956
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 28.700000000000145
VocabularyItem:
    pronunciation: CAR
    label: CAR
    values: set()
    diacritic: CAR_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 19.79999999999994
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 13.399999999999999
line done
line done

---------------------

input line #254
input roots: [<__main__.Root object at 0x10fc3d828>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 41.00000000000023..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 86.79999999999956..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 39.30000000000021..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 39.40000000000021..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CASTLE in its selectional

now working with the word 'CASTLE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CASTLE_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CASTLE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'CASTLE_2', 'o_1', 'CASTLE_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50860>, '-', <__main__.AgrTerminal object at 0x10fc3def0>, '#', <__main__.Root object at 0x10fc504a8>, '-', <__main__.NominalizerTerminal object at 0x10fc50160>, '-', <__main__.SemanticTerminal object at 0x10fc50c18>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CASTLE terminal with values set()
we picked CASTLE_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: uno#CASTLE-o
full_pronunciation: una#CASTLEo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 39.40000000000021
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 43.000000000000206
VocabularyItem:
    pronunciation: CASTLE
    label: CASTLE
    values: set()
    diacritic: CASTLE_4
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.29999999999994
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 21.000000000000007
line done
line done

---------------------

input line #255
input roots: [<__main__.Root object at 0x10fc43710>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 86.89999999999955..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 29.300000000000146..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 43.000000000000206..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 86.99999999999955..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 43.10000000000021..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 39.40000000000021..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 87.09999999999954..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 87.19999999999953..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 29.100000000000126..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 43.20000000000021..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: FROG in its selectional

now working with the word 'FROG-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi FROG_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_2', 'a_1', 'FROG_1', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6ff98>, '-', <__main__.AgrTerminal object at 0x10fc454a8>, '#', <__main__.Root object at 0x10fc6fb00>, '-', <__main__.NominalizerTerminal object at 0x10fc6f048>, '-', <__main__.SemanticTerminal object at 0x10fc6f198>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'i_2', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FROG terminal with values set()
we picked FROG_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a', 'i_2', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#FROG-a
full_pronunciation: la#FROGa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: FROG to the selectional of the nominalizer whose values are {'i_2', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'a_2'}
    selectional: {'BOOK', 'CHILD', 'BALL', 'PIBLING', 'FLOWER', 'GRANDPARENT', 'CAR', 'CLOWN', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 17.800000000000004
    linear: (<__main__.NominalizerTerminal object at 0x10fc36a90>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 87.19999999999953
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 43.20000000000021
VocabularyItem:
    pronunciation: FROG
    label: FROG
    values: set()
    diacritic: FROG_2
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 10.4
     what if we combine triggers with the otherwise identical vi FROG_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.19999999999994
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 26.300000000000026
line done
line done

---------------------

input line #256
input roots: [<__main__.Root object at 0x10fc3d710>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 87.79999999999953..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 43.80000000000021..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 29.200000000000127..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 87.89999999999952..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 41.10000000000023..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 29.30000000000013..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 87.99999999999952..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: FOOT in its selectional

now working with the word 'FOOT-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FOOT_1', 'null_12', 'null_13', 'i_1'}
     what if we combine triggers with the otherwise identical vi FOOT_2 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'FOOT_3', 'FOOT_1', 'null_13', 'i_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6f518>, '#', <__main__.Root object at 0x10fc42208>, '-', <__main__.NominalizerTerminal object at 0x10fc428d0>, '-', <__main__.SemanticTerminal object at 0x10fc42198>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out FOOT terminal with values set()
we picked FOOT_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#FOOT-i
full_pronunciation: l#FOOTi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 87.99999999999952
VocabularyItem:
    pronunciation: FOOT
    label: FOOT
    values: set()
    diacritic: FOOT_3
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 10.100000000000005
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 18.60000000000001
line done
line done

---------------------

input line #257
input roots: [<__main__.Root object at 0x10fc42710>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 87.99999999999952..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 43.90000000000021..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 29.400000000000148..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 88.09999999999951..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 41.20000000000023..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 29.50000000000015..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 88.1999999999995..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: TOWER in its selectional

now working with the word 'TOWER-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_6', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_6', 'null_7', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'TOWER_1', 'null_6', 'null_7', 'i_1'}
     what if we combine triggers with the otherwise identical vi TOWER_3 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'TOWER_1', 'null_7', 'i_1', 'TOWER_2', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67320>, '-', <__main__.AgrTerminal object at 0x10fc6f400>, '#', <__main__.Root object at 0x10fc67668>, '-', <__main__.NominalizerTerminal object at 0x10fc67240>, '-', <__main__.SemanticTerminal object at 0x10fc67cc0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic', 'o_2'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out TOWER terminal with values set()
we picked TOWER_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: le#TOWER-i
full_pronunciation: le#TOWERi
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: TOWER to the selectional of the nominalizer whose values are {'e_1', 'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1', 'o_2'}
    selectional: {'BOOK', 'CHILD', 'PIBLING', 'GRANDPARENT', 'CAR', 'CLOWN', 'OFFSPRING'}
    selection_strength: True
    weight: 15.199999999999996
    linear: (<__main__.NominalizerTerminal object at 0x10fc3d400>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 88.1999999999995
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 29.50000000000015
VocabularyItem:
    pronunciation: TOWER
    label: TOWER
    values: set()
    diacritic: TOWER_3
    triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))}
    weight: 10.3
     what if we combine triggers with the otherwise identical vi TOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 10.000000000000005
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 18.60000000000001
line done
line done

---------------------

input line #258
input roots: [<__main__.Root object at 0x10fc3ce48>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 88.7999999999995..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 30.10000000000015..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 41.30000000000023..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 88.8999999999995..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 41.40000000000023..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 39.50000000000021..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 88.99999999999949..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 89.09999999999948..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 29.40000000000013..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 41.500000000000234..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FLOWER in its selectional

now working with the word 'FLOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19', 'FLOWER_1'}
     what if we combine triggers with the otherwise identical vi FLOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FLOWER_3', 'e_3', 'null_19', 'FLOWER_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc41320>, '-', <__main__.AgrTerminal object at 0x10fc67b00>, '#', <__main__.Root object at 0x10fc3e898>, '-', <__main__.NominalizerTerminal object at 0x10fc3eb00>, '-', <__main__.SemanticTerminal object at 0x10fc3e080>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FLOWER terminal with values set()
we picked FLOWER_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: lo#FLOWER-e
full_pronunciation: lo#FLOWERe
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: FLOWER to the selectional of the nominalizer whose values are {'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'o_2'}
    selectional: {'MOUSE', 'CHILD', 'BOOK', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 43.900000000000375
    linear: (<__main__.NominalizerTerminal object at 0x10fc08908>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_6, triggers = set(), weight = 10.200000000000001..already existed

create_vi: tried nominalizer: null_7, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.899999999999997..already existed

create_vi: tried nominalizer: null_26, triggers = {('e', frozenset({'-atomic'}))}, weight = 11.899999999999997..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_14, triggers = set(), weight = 13.200000000000001..already existed

create_vi: tried nominalizer: null_15, triggers = {('i', frozenset({'-atomic'}))}, weight = 11.099999999999996..already existed
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 89.09999999999948
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 41.500000000000234
VocabularyItem:
    pronunciation: FLOWER
    label: FLOWER
    values: set()
    diacritic: FLOWER_3
    triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))}
    weight: 10.4
     what if we combine triggers with the otherwise identical vi FLOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.69999999999994
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 13.3
line done
line done

---------------------

input line #259
input roots: [<__main__.Root object at 0x10fc3e320>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 89.69999999999948..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 44.00000000000021..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 30.200000000000152..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 89.79999999999947..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 42.100000000000236..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 30.300000000000153..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 89.89999999999947..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: CHILD in its selectional

now working with the word 'CHILD-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6', 'CHILD_1'}
     what if we combine triggers with the otherwise identical vi CHILD_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'CHILD_1', 'CHILD_7', 'null_26', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b080>, '-', <__main__.AgrTerminal object at 0x10fc2f0b8>, '#', <__main__.Root object at 0x10fc4ba20>, '-', <__main__.NominalizerTerminal object at 0x10fc4b860>, '-', <__main__.SemanticTerminal object at 0x10fc4b0f0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic', 'o_2'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'o_2'}
we picked null_6 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: le#CHILD-e
full_pronunciation: le#CHILDi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 89.89999999999947
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 30.300000000000153
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_3
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 10.100000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_6
    triggers: set()
    weight: 10.200000000000001
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 19.10000000000001
line done
line done

---------------------

input line #260
input roots: [<__main__.Root object at 0x10fc41748>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 89.89999999999947..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 30.300000000000153..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 42.20000000000024..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 89.99999999999946..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 42.30000000000024..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 39.600000000000215..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 90.09999999999945..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 90.19999999999945..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 29.50000000000013..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 42.40000000000024..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'OFFSPRING_3', 'o_1', 'OFFSPRING_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a5f8>, '-', <__main__.AgrTerminal object at 0x10fc4bac8>, '#', <__main__.Root object at 0x10fc6a668>, '-', <__main__.NominalizerTerminal object at 0x10fc6ab00>, '-', <__main__.SemanticTerminal object at 0x10fc6a3c8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: lo#OFFSPRING-o
full_pronunciation: la#OFFSPRINGo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 90.19999999999945
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 44.00000000000021
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.19999999999994
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 21.000000000000007
line done
line done

---------------------

input line #261
input roots: [<__main__.Root object at 0x10fc6ab70>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 90.19999999999945..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 44.00000000000021..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 30.400000000000155..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 90.29999999999944..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 42.50000000000024..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 30.500000000000156..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 90.39999999999944..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: KEY in its selectional

now working with the word 'KEY-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_6', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_6', 'null_7', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'KEY_1', 'null_6', 'null_7', 'i_1'}
     what if we combine triggers with the otherwise identical vi KEY_3 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'KEY_1', 'null_7', 'i_1', 'KEY_2', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'e_1'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50438>, '-', <__main__.AgrTerminal object at 0x10fc6ab38>, '#', <__main__.Root object at 0x10fc36240>, '-', <__main__.NominalizerTerminal object at 0x10fc36160>, '-', <__main__.SemanticTerminal object at 0x10fc50400>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out KEY terminal with values set()
we picked KEY_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1', 'null'}
we picked null_6 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: le#KEY-i
full_pronunciation: le#KEYe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 90.39999999999944
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 30.500000000000156
VocabularyItem:
    pronunciation: KEY
    label: KEY
    values: set()
    diacritic: KEY_3
    triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))}
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_6
    triggers: set()
    weight: 10.100000000000001
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 13.999999999999998
line done
line done

---------------------

input line #262
input roots: [<__main__.Root object at 0x10fc503c8>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 90.39999999999944..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 44.100000000000215..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 30.500000000000156..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 90.49999999999943..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 42.60000000000024..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 30.600000000000158..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 90.59999999999943..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: CAR in its selectional

now working with the word 'CAR-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'null_17'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'CAR_1', 'null_17'}
     what if we combine triggers with the otherwise identical vi CAR_3 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'CAR_2', 'null_16', 'null_17', 'CAR_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50be0>, '#', <__main__.Root object at 0x10fc6a978>, '-', <__main__.NominalizerTerminal object at 0x10fc50160>, '-', <__main__.SemanticTerminal object at 0x10fc50860>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked li_1: no super match (neither decl nor L1-gender)
now spelling out CAR terminal with values set()
we picked CAR_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: le#CAR-e
full_pronunciation: li#CARe
vis_used:
Failure
VocabularyItem:
    pronunciation: li
    label: definite
    values: {'+definite', '-atomic'}
    diacritic: li_1
    triggers: set()
    weight: 10.600000000000001
VocabularyItem:
    pronunciation: CAR
    label: CAR
    values: set()
    diacritic: CAR_3
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 10.200000000000006
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 13.999999999999998
line done
line done

---------------------

input line #263
input roots: [<__main__.Root object at 0x10fc509e8>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 42.700000000000244..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 90.69999999999942..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 39.700000000000216..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 39.80000000000022..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CLOWN in its selectional

now working with the word 'CLOWN-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CLOWN_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CLOWN_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'CLOWN_3', 'o_1', 'CLOWN_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b7b8>, '-', <__main__.AgrTerminal object at 0x10fc6a128>, '#', <__main__.Root object at 0x10fc4b3c8>, '-', <__main__.NominalizerTerminal object at 0x10fc4bfd0>, '-', <__main__.SemanticTerminal object at 0x10fc4b358>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CLOWN terminal with values set()
we picked CLOWN_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: uno#CLOWN-o
full_pronunciation: una#CLOWNo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 39.80000000000022
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 44.100000000000215
VocabularyItem:
    pronunciation: CLOWN
    label: CLOWN
    values: set()
    diacritic: CLOWN_4
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.100000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 10.100000000000007
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 21.000000000000007
line done
line done

---------------------

input line #264
input roots: [<__main__.Root object at 0x10fc6aa20>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 90.79999999999941..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 44.100000000000215..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 29.600000000000133..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 90.89999999999941..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 42.800000000000246..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 29.700000000000134..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 90.9999999999994..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'PIBLING_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi PIBLING_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_5 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_7', 'null_15', 'PIBLING_1', 'i_1', 'null_14'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4bcc0>, '#', <__main__.Root object at 0x10fc4b5c0>, '-', <__main__.NominalizerTerminal object at 0x10fc4b0b8>, '-', <__main__.SemanticTerminal object at 0x10fc4bd68>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out PIBLING terminal with values set()
we picked PIBLING_5: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: li#PIBLING-i
full_pronunciation: l#PIBLINGe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 90.9999999999994
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_5
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.099999999999937
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 13.899999999999999
line done
line done

---------------------

input line #265
input roots: [<__main__.Root object at 0x10fc4b390>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 90.9999999999994..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 44.200000000000216..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 30.70000000000016..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 91.0999999999994..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 42.90000000000025..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 30.80000000000016..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 91.19999999999939..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: FROG in its selectional

now working with the word 'FROG-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6', 'FROG_1'}
     what if we combine triggers with the otherwise identical vi FROG_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'FROG_1', 'null_26', 'FROG_3', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67550>, '-', <__main__.AgrTerminal object at 0x10fc6a668>, '#', <__main__.Root object at 0x10fc670f0>, '-', <__main__.NominalizerTerminal object at 0x10fc67fd0>, '-', <__main__.SemanticTerminal object at 0x10fc67b00>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'a_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FROG terminal with values set()
we picked FROG_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'i_2', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: le#FROG-e
full_pronunciation: li#FROGe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 91.19999999999939
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 29.700000000000134
VocabularyItem:
    pronunciation: FROG
    label: FROG
    values: set()
    diacritic: FROG_3
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.999999999999936
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 13.899999999999999
line done
line done

---------------------

input line #266
input roots: [<__main__.Root object at 0x10fc411d0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 91.19999999999939..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 44.30000000000022..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 30.900000000000162..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 91.29999999999939..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 43.00000000000025..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 31.000000000000163..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 91.39999999999938..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: TOWER in its selectional

now working with the word 'TOWER-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_6', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_6', 'null_7', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'TOWER_1', 'null_6', 'null_7', 'i_1'}
     what if we combine triggers with the otherwise identical vi TOWER_3 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'TOWER_1', 'null_7', 'i_1', 'TOWER_2', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67cc0>, '#', <__main__.Root object at 0x10fc43780>, '-', <__main__.NominalizerTerminal object at 0x10fbffcf8>, '-', <__main__.SemanticTerminal object at 0x10fc3ce48>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked le_1: no super match (neither decl nor L1-gender)
now spelling out TOWER terminal with values set()
we picked TOWER_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: le#TOWER-i
full_pronunciation: le#TOWERi
vis_used:
Successful derivation!
VocabularyItem:
    pronunciation: le
    label: definite
    values: {'+definite', '-atomic'}
    diacritic: le_1
    triggers: set()
    weight: 10.600000000000001
VocabularyItem:
    pronunciation: TOWER
    label: TOWER
    values: set()
    diacritic: TOWER_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.4
     what if we combine triggers with the otherwise identical vi TOWER_3 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 10.500000000000005
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 19.30000000000001
line done
line done

---------------------

input line #267
input roots: [<__main__.Root object at 0x10fc67ef0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 91.49999999999937..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 44.40000000000022..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 29.700000000000134..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 91.59999999999937..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 43.10000000000025..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 29.800000000000136..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 91.69999999999936..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: CLOWN in its selectional

now working with the word 'CLOWN-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'CLOWN_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi CLOWN_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CLOWN_2', 'null_15', 'i_1', 'null_14', 'CLOWN_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6f128>, '-', <__main__.AgrTerminal object at 0x10fc67198>, '#', <__main__.Root object at 0x10fc6f2e8>, '-', <__main__.NominalizerTerminal object at 0x10fc6f898>, '-', <__main__.SemanticTerminal object at 0x10fc6fba8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'o_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CLOWN terminal with values set()
we picked CLOWN_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: li#CLOWN-i
full_pronunciation: li#CLOWNe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 91.69999999999936
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 29.800000000000136
VocabularyItem:
    pronunciation: CLOWN
    label: CLOWN
    values: set()
    diacritic: CLOWN_3
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 10.5
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.899999999999935
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 13.799999999999999
line done
line done

---------------------

input line #268
input roots: [<__main__.Root object at 0x10fc43198>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 43.20000000000025..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 91.69999999999936..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 39.80000000000022..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 39.90000000000022..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1', 'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_18', 'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_18', 'o_1', 'null_12'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'PIBLING_1', 'o_1', 'null_18', 'PIBLING_5'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc3d550>, '-', <__main__.AgrTerminal object at 0x10fc6f278>, '#', <__main__.Root object at 0x10fc45f98>, '-', <__main__.NominalizerTerminal object at 0x10fc207b8>, '-', <__main__.SemanticTerminal object at 0x10fc3dda0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_5: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: uno#PIBLING-o
full_pronunciation: uno#PIBLINGo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: PIBLING to the selectional of the nominalizer whose values are {'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'o_2'}
    selectional: {'MOUSE', 'CHILD', 'BOOK', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 45.6000000000004
    linear: (<__main__.NominalizerTerminal object at 0x10fc08908>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_20, triggers = set(), weight = 11.2..already existed

create_vi: tried nominalizer: null_30, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.1..already existed

create_vi: tried nominalizer: null_31, triggers = {('e', frozenset({'-atomic'}))}, weight = 10.299999999999999..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_12, triggers = set(), weight = 10.799999999999999..already existed

create_vi: tried nominalizer: null_13, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.2..already existed
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 39.90000000000022
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 43.20000000000025
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_5
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 9.600000000000001
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 11.000000000000005
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 21.000000000000007
line done
line done

---------------------

input line #269
input roots: [<__main__.Root object at 0x10fc6fa90>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 91.79999999999936..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 44.50000000000022..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 29.800000000000136..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 91.89999999999935..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 43.80000000000025..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 29.900000000000137..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 91.99999999999935..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: MOUSE in its selectional

now working with the word 'MOUSE-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'MOUSE_1', 'null_12', 'null_13', 'i_1'}
     what if we combine triggers with the otherwise identical vi MOUSE_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'MOUSE_3', 'null_12', 'null_13', 'i_1', 'MOUSE_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc45940>, '-', <__main__.AgrTerminal object at 0x10fc458d0>, '#', <__main__.Root object at 0x10fc3d748>, '-', <__main__.NominalizerTerminal object at 0x10fc3def0>, '-', <__main__.SemanticTerminal object at 0x10fc207b8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MOUSE terminal with values set()
we picked MOUSE_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'e_1', 'null'}
we picked null_6 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#MOUSE-i
full_pronunciation: le#MOUSEi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 91.99999999999935
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 31.000000000000163
VocabularyItem:
    pronunciation: MOUSE
    label: MOUSE
    values: set()
    diacritic: MOUSE_4
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 10.4
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_6
    triggers: set()
    weight: 10.000000000000002
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 20.000000000000014
line done
line done

---------------------

input line #270
input roots: [<__main__.Root object at 0x10fc45e80>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 43.900000000000254..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 91.99999999999935..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 40.50000000000022..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 40.60000000000022..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'OFFSPRING_3', 'o_1', 'OFFSPRING_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6f668>, '-', <__main__.AgrTerminal object at 0x10fc453c8>, '#', <__main__.Root object at 0x10fc42b00>, '-', <__main__.NominalizerTerminal object at 0x10fc3bf28>, '-', <__main__.SemanticTerminal object at 0x10fc6feb8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_5: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: uno#OFFSPRING-o
full_pronunciation: una#OFFSPRINGa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 40.60000000000022
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 44.50000000000022
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_5
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 10.3
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.799999999999933
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 26.800000000000026
line done
line done

---------------------

input line #271
input roots: [<__main__.Root object at 0x10fc6f0b8>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 44.000000000000256..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 92.09999999999934..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 40.60000000000022..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 40.70000000000022..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FOOT in its selectional

now working with the word 'FOOT-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FOOT_1', 'null_8', 'e_3', 'null_19'}
     what if we combine triggers with the otherwise identical vi FOOT_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FOOT_1', 'e_3', 'FOOT_2', 'null_19'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc677b8>, '-', <__main__.AgrTerminal object at 0x10fc6f048>, '#', <__main__.Root object at 0x10fc67cc0>, '-', <__main__.NominalizerTerminal object at 0x10fc67ef0>, '-', <__main__.SemanticTerminal object at 0x10fc67198>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FOOT terminal with values set()
we picked FOOT_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: uno#FOOT-e
full_pronunciation: una#FOOTa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 40.70000000000022
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 44.40000000000022
VocabularyItem:
    pronunciation: FOOT
    label: FOOT
    values: set()
    diacritic: FOOT_3
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.600000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.699999999999932
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 26.700000000000024
line done
line done

---------------------

input line #272
input roots: [<__main__.Root object at 0x10fc428d0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 92.19999999999933..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 31.000000000000163..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 44.40000000000022..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 92.29999999999933..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 44.50000000000022..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 40.70000000000022..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 92.39999999999932..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 92.49999999999932..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 30.00000000000014..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 44.60000000000022..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'OFFSPRING_1', 'null_11', 'null_10', 'OFFSPRING_5'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc41cf8>, '-', <__main__.AgrTerminal object at 0x10fc67470>, '#', <__main__.Root object at 0x10fc41eb8>, '-', <__main__.NominalizerTerminal object at 0x10fc41320>, '-', <__main__.SemanticTerminal object at 0x10fc41b00>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_8: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: la#OFFSPRING-a
full_pronunciation: lo#OFFSPRINGo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 92.49999999999932
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 44.000000000000256
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_8
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 11.500000000000005
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 21.60000000000001
line done
line done

---------------------

input line #273
input roots: [<__main__.Root object at 0x10fc67b00>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 92.49999999999932..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 31.100000000000165..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 44.000000000000256..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 92.59999999999931..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 44.10000000000026..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 40.800000000000225..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 92.6999999999993..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 92.7999999999993..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 30.10000000000014..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 44.20000000000026..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CHILD_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'CHILD_1', 'null_9', 'o_1', 'CHILD_3'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b4e0>, '-', <__main__.AgrTerminal object at 0x10fc672e8>, '#', <__main__.Root object at 0x10fc4b828>, '-', <__main__.NominalizerTerminal object at 0x10fc4b160>, '-', <__main__.SemanticTerminal object at 0x10fc4b6a0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'e_1', 'o_2'}
we picked null_20 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: lo#CHILD-o
full_pronunciation: lo#CHILDo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CHILD to the selectional of the nominalizer whose values are {'e_1', 'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1', 'o_2'}
    selectional: {'BOOK', 'CHILD', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'CLOWN', 'OFFSPRING'}
    selection_strength: True
    weight: 16.299999999999997
    linear: (<__main__.NominalizerTerminal object at 0x10fc3d400>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 92.7999999999993
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 44.20000000000026
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_3
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 10.000000000000002
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1', 'o_2'}
    diacritic: null_20
    triggers: set()
    weight: 11.2
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 21.60000000000001
line done
line done

---------------------

input line #274
input roots: [<__main__.Root object at 0x10fc41748>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 93.3999999999993..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 44.70000000000022..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 31.200000000000166..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 93.49999999999929..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 44.80000000000026..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 31.300000000000168..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 93.59999999999928..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: KEY in its selectional

now working with the word 'KEY-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'null_32', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'KEY_1', 'null_32', 'i_1'}
     what if we combine triggers with the otherwise identical vi KEY_3 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'KEY_1', 'null_16', 'null_32', 'i_1', 'KEY_2'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b4a8>, '#', <__main__.Root object at 0x10fc6a400>, '-', <__main__.NominalizerTerminal object at 0x10fc6a3c8>, '-', <__main__.SemanticTerminal object at 0x10fc6a668>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked li_1: no super match (neither decl nor L1-gender)
now spelling out KEY terminal with values set()
we picked KEY_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: le#KEY-i
full_pronunciation: li#KEYe
vis_used:
Failure
VocabularyItem:
    pronunciation: li
    label: definite
    values: {'+definite', '-atomic'}
    diacritic: li_1
    triggers: set()
    weight: 10.500000000000002
VocabularyItem:
    pronunciation: KEY
    label: KEY
    values: set()
    diacritic: KEY_3
    triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))}
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 11.400000000000006
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 13.7
line done
line done

---------------------

input line #275
input roots: [<__main__.Root object at 0x10fc4b898>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 93.69999999999928..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 31.40000000000017..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 44.800000000000225..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 93.79999999999927..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 44.900000000000226..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 40.900000000000226..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 93.89999999999927..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 93.99999999999926..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 30.20000000000014..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 45.00000000000023..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'OFFSPRING_1', 'null_11', 'null_10', 'OFFSPRING_5'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a5f8>, '#', <__main__.Root object at 0x10fc509e8>, '-', <__main__.NominalizerTerminal object at 0x10fc50c88>, '-', <__main__.SemanticTerminal object at 0x10fc50a20>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '+atomic'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_7: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: la#OFFSPRING-a
full_pronunciation: l#OFFSPRINGe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 93.99999999999926
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_7
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.59999999999993
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 13.9
line done
line done

---------------------

input line #276
input roots: [<__main__.Root object at 0x10fc6a940>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 93.99999999999926..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 45.10000000000023..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 30.300000000000143..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 94.09999999999926..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 44.90000000000026..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 30.400000000000144..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 94.19999999999925..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_12', 'null_13', 'i_1'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_5 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'OFFSPRING_2', 'null_13', 'i_1', 'OFFSPRING_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc36240>, '#', <__main__.Root object at 0x10fc585c0>, '-', <__main__.NominalizerTerminal object at 0x10fc58eb8>, '-', <__main__.SemanticTerminal object at 0x10fc58898>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked le_1: no super match (neither decl nor L1-gender)
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_6: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#OFFSPRING-i
full_pronunciation: le#OFFSPRINGi
vis_used:
Failure
VocabularyItem:
    pronunciation: le
    label: definite
    values: {'+definite', '-atomic'}
    diacritic: le_1
    triggers: set()
    weight: 11.100000000000001
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_6
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.49999999999993
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 20.100000000000016
line done
line done

---------------------

input line #277
input roots: [<__main__.Root object at 0x10fc58f28>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 94.29999999999924..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 45.20000000000023..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 30.500000000000146..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 94.39999999999924..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 45.00000000000026..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 30.600000000000147..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 94.49999999999923..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: MOUSE in its selectional

now working with the word 'MOUSE-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'MOUSE_1', 'null_12', 'null_13', 'i_1'}
     what if we combine triggers with the otherwise identical vi MOUSE_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'MOUSE_3', 'null_12', 'null_13', 'i_1', 'MOUSE_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50390>, '-', <__main__.AgrTerminal object at 0x10fc58860>, '#', <__main__.Root object at 0x10fc6a048>, '-', <__main__.NominalizerTerminal object at 0x10fc6add8>, '-', <__main__.SemanticTerminal object at 0x10fc50ac8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic', 'a_2'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MOUSE terminal with values set()
we picked MOUSE_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'a_2'}
we picked null_6 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: li#MOUSE-i
full_pronunciation: le#MOUSEe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 94.49999999999923
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 31.40000000000017
VocabularyItem:
    pronunciation: MOUSE
    label: MOUSE
    values: set()
    diacritic: MOUSE_2
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 10.3
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_6
    triggers: set()
    weight: 9.900000000000002
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 13.6
line done
line done

---------------------

input line #278
input roots: [<__main__.Root object at 0x10fc581d0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 94.49999999999923..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 45.30000000000023..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 30.70000000000015..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 94.59999999999923..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 45.100000000000264..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 30.80000000000015..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 94.69999999999922..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'OFFSPRING_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_5 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_15', 'OFFSPRING_2', 'i_1', 'null_14', 'OFFSPRING_1'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a470>, '#', <__main__.Root object at 0x10fc4b780>, '-', <__main__.NominalizerTerminal object at 0x10fc4b7b8>, '-', <__main__.SemanticTerminal object at 0x10fc6a748>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_5: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: li#OFFSPRING-i
full_pronunciation: l#OFFSPRINGi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 94.69999999999922
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_5
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 10.200000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.399999999999928
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 20.200000000000017
line done
line done

---------------------

input line #279
input roots: [<__main__.Root object at 0x10fc6ae10>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 94.69999999999922..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 31.40000000000017..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 45.200000000000266..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 94.79999999999922..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 45.30000000000027..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 41.00000000000023..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 94.89999999999921..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 94.9999999999992..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 30.90000000000015..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 45.40000000000027..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'OFFSPRING_3', 'o_1', 'OFFSPRING_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b240>, '-', <__main__.AgrTerminal object at 0x10fc4b4a8>, '#', <__main__.Root object at 0x10fc4bef0>, '-', <__main__.NominalizerTerminal object at 0x10fc4be10>, '-', <__main__.SemanticTerminal object at 0x10fc4bc50>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_8: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: lo#OFFSPRING-o
full_pronunciation: lo#OFFSPRINGo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: OFFSPRING to the selectional of the nominalizer whose values are {'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'o_2'}
    selectional: {'MOUSE', 'CHILD', 'BOOK', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 47.500000000000426
    linear: (<__main__.NominalizerTerminal object at 0x10fc08908>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_20, triggers = set(), weight = 11.799999999999999..already existed

create_vi: tried nominalizer: null_30, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.2..already existed

create_vi: tried nominalizer: null_31, triggers = {('e', frozenset({'-atomic'}))}, weight = 10.399999999999999..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_12, triggers = set(), weight = 10.899999999999999..already existed

create_vi: tried nominalizer: null_13, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.299999999999999..already existed
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 94.9999999999992
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 45.40000000000027
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_8
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 11.300000000000006
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 22.20000000000001
line done
line done

---------------------

input line #280
input roots: [<__main__.Root object at 0x10fc4b160>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 95.5999999999992..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 31.50000000000017..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 46.00000000000027..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 95.69999999999919..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 46.10000000000027..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 41.10000000000023..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 95.79999999999919..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 95.89999999999918..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 31.000000000000153..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 46.20000000000027..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FOOT in its selectional

now working with the word 'FOOT-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FOOT_1', 'null_8', 'e_3', 'null_19'}
     what if we combine triggers with the otherwise identical vi FOOT_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FOOT_1', 'e_3', 'FOOT_2', 'null_19'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67240>, '-', <__main__.AgrTerminal object at 0x10fc4beb8>, '#', <__main__.Root object at 0x10fc67278>, '-', <__main__.NominalizerTerminal object at 0x10fc67470>, '-', <__main__.SemanticTerminal object at 0x10fc67e10>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FOOT terminal with values set()
we picked FOOT_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o_2'}
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: lo#FOOT-e
full_pronunciation: lo#FOOTa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 95.89999999999918
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 46.20000000000027
VocabularyItem:
    pronunciation: FOOT
    label: FOOT
    values: set()
    diacritic: FOOT_1
    triggers: set()
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.299999999999926
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 26.800000000000026
line done
line done

---------------------

input line #281
input roots: [<__main__.Root object at 0x10fc4bba8>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 45.40000000000023..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 95.89999999999918..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 41.20000000000023..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 41.30000000000023..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1', 'e_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: BALL in its selectional

now working with the word 'BALL-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'null_27', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'null_27', 'BALL_1', 'a_1'}
     what if we combine triggers with the otherwise identical vi BALL_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'null_16', 'BALL_1', 'null_27', 'BALL_2'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc43208>, '-', <__main__.AgrTerminal object at 0x10fc67860>, '#', <__main__.Root object at 0x10fc43eb8>, '-', <__main__.NominalizerTerminal object at 0x10fc433c8>, '-', <__main__.SemanticTerminal object at 0x10fc43278>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BALL terminal with values set()
we picked BALL_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'a_2'}
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: una#BALL-a
full_pronunciation: una#BALLo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 41.30000000000023
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 45.40000000000023
VocabularyItem:
    pronunciation: BALL
    label: BALL
    values: set()
    diacritic: BALL_1
    triggers: set()
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.199999999999925
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 22.70000000000001
line done
line done

---------------------

input line #282
input roots: [<__main__.Root object at 0x10fc67cc0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 46.20000000000027..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 95.99999999999918..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 41.30000000000023..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 41.40000000000023..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'GRANDPARENT_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'GRANDPARENT_1', 'GRANDPARENT_2'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6f3c8>, '-', <__main__.AgrTerminal object at 0x10fc43198>, '#', <__main__.Root object at 0x10fc6fda0>, '-', <__main__.NominalizerTerminal object at 0x10fc6f080>, '-', <__main__.SemanticTerminal object at 0x10fc6f668>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_6: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2', 'a'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: uno#GRANDPARENT-o
full_pronunciation: uno#GRANDPARENTa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 41.40000000000023
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 46.20000000000027
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_6
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 10.400000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 11.800000000000006
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 26.800000000000026
line done
line done

---------------------

input line #283
input roots: [<__main__.Root object at 0x10fc6f0b8>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 96.09999999999917..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 31.600000000000172..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 46.20000000000027..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 96.19999999999916..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 46.300000000000274..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 41.40000000000023..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 96.29999999999916..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 96.39999999999915..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 31.100000000000154..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 46.400000000000276..already existed
  we're in a functional word...
  - nominalizer's values are now {'i_2', 'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: BOOK in its selectional

now working with the word 'BOOK-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_18', 'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_18', 'o_1', 'BOOK_1', 'null_12'}
     what if we combine triggers with the otherwise identical vi BOOK_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'o_1', 'BOOK_1', 'BOOK_3', 'null_18'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6ff60>, '#', <__main__.Root object at 0x10fc20b38>, '-', <__main__.NominalizerTerminal object at 0x10fc20ef0>, '-', <__main__.SemanticTerminal object at 0x10fc3d748>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '+atomic', 'i_2'}
we picked la_1: no super match (neither decl nor L1-gender)
now spelling out BOOK terminal with values set()
we picked BOOK_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'i_2'}
we picked null_14 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: lo#BOOK-o
full_pronunciation: la#BOOKo
vis_used:
Failure
VocabularyItem:
    pronunciation: la
    label: definite
    values: {'+definite', '+atomic'}
    diacritic: la_1
    triggers: set()
    weight: 10.200000000000001
VocabularyItem:
    pronunciation: BOOK
    label: BOOK
    values: set()
    diacritic: BOOK_3
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 10.3
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 13.200000000000001
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 22.80000000000001
line done
line done

---------------------

input line #284
input roots: [<__main__.Root object at 0x10fc3d898>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 45.40000000000023..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 96.49999999999915..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 41.500000000000234..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 41.600000000000236..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: BALL in its selectional

now working with the word 'BALL-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'BALL_1', 'a_1'}
     what if we combine triggers with the otherwise identical vi BALL_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'BALL_1', 'BALL_2', 'null_10', 'null_11'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc3d550>, '-', <__main__.AgrTerminal object at 0x10fc45f98>, '#', <__main__.Root object at 0x10fc6f860>, '-', <__main__.NominalizerTerminal object at 0x10fc6f1d0>, '-', <__main__.SemanticTerminal object at 0x10fc3dba8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BALL terminal with values set()
we picked BALL_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: una#BALL-a
full_pronunciation: uno#BALLa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 41.600000000000236
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 46.400000000000276
VocabularyItem:
    pronunciation: BALL
    label: BALL
    values: set()
    diacritic: BALL_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.099999999999923
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 26.800000000000026
line done
line done

---------------------

input line #285
input roots: [<__main__.Root object at 0x10fc3d358>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 96.59999999999914..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 31.700000000000173..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 46.400000000000276..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 96.69999999999914..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 46.50000000000028..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 41.600000000000236..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 96.79999999999913..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 96.89999999999912..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 31.200000000000156..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 46.60000000000028..already existed
  we're in a functional word...
  - nominalizer's values are now {'i_2', 'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: CLOWN in its selectional

now working with the word 'CLOWN-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_18', 'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_18', 'o_1', 'CLOWN_1', 'null_12'}
     what if we combine triggers with the otherwise identical vi CLOWN_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'CLOWN_3', 'o_1', 'null_18', 'CLOWN_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc3bf28>, '-', <__main__.AgrTerminal object at 0x10fc6f128>, '#', <__main__.Root object at 0x10fc42710>, '-', <__main__.NominalizerTerminal object at 0x10fc42cc0>, '-', <__main__.SemanticTerminal object at 0x10fbffcf8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'i_2', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CLOWN terminal with values set()
we picked CLOWN_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'i_2', 'a_2'}
we picked null_24 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: lo#CLOWN-o
full_pronunciation: la#CLOWNo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 96.89999999999912
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 45.40000000000023
VocabularyItem:
    pronunciation: CLOWN
    label: CLOWN
    values: set()
    diacritic: CLOWN_3
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 10.4
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2', 'a_2'}
    diacritic: null_24
    triggers: set()
    weight: 11.5
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 22.80000000000001
line done
line done

---------------------

input line #286
input roots: [<__main__.Root object at 0x10fc6f3c8>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 96.89999999999912..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 45.40000000000023..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 31.300000000000157..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 96.99999999999912..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 46.70000000000028..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 31.40000000000016..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 97.09999999999911..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: FOOT in its selectional

now working with the word 'FOOT-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FOOT_1', 'null_12', 'null_13', 'i_1'}
     what if we combine triggers with the otherwise identical vi FOOT_2 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'FOOT_3', 'FOOT_1', 'null_13', 'i_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc42128>, '#', <__main__.Root object at 0x10fc67cc0>, '-', <__main__.NominalizerTerminal object at 0x10fc67668>, '-', <__main__.SemanticTerminal object at 0x10fc67358>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked li_1: no super match (neither decl nor L1-gender)
now spelling out FOOT terminal with values set()
we picked FOOT_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#FOOT-i
full_pronunciation: li#FOOTi
vis_used:
Successful derivation!
VocabularyItem:
    pronunciation: li
    label: definite
    values: {'+definite', '-atomic'}
    diacritic: li_1
    triggers: set()
    weight: 10.400000000000002
VocabularyItem:
    pronunciation: FOOT
    label: FOOT
    values: set()
    diacritic: FOOT_3
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.500000000000002
     what if we combine triggers with the otherwise identical vi FOOT_2 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 19.999999999999922
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 20.200000000000017
line done
line done

---------------------

input line #287
input roots: [<__main__.Root object at 0x10fc43780>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 97.19999999999911..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 45.500000000000234..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 31.800000000000175..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 97.2999999999991..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 46.80000000000028..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 31.900000000000176..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 97.3999999999991..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'null_17'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'GRANDPARENT_1', 'null_17'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_3 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'GRANDPARENT_7', 'null_17', 'GRANDPARENT_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc412b0>, '-', <__main__.AgrTerminal object at 0x10fc67ef0>, '#', <__main__.Root object at 0x10fc41940>, '-', <__main__.NominalizerTerminal object at 0x10fc416d8>, '-', <__main__.SemanticTerminal object at 0x10fc41b00>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic', 'a_2'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_9: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e', 'e_1', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: le#GRANDPARENT-e
full_pronunciation: le#GRANDPARENTe
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: GRANDPARENT to the selectional of the nominalizer whose values are {'e_1', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1', 'a_2'}
    selectional: {'FROG', 'BALL', 'CHILD', 'TOWER', 'PIBLING', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 20.70000000000002
    linear: (<__main__.NominalizerTerminal object at 0x10fc2aa20>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 97.3999999999991
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 31.900000000000176
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_9
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.4
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.499999999999922
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 13.6
line done
line done

---------------------

input line #288
input roots: [<__main__.Root object at 0x10fc67e48>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 46.90000000000028..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 97.99999999999909..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 41.70000000000024..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 41.80000000000024..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FOOT in its selectional

now working with the word 'FOOT-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FOOT_1', 'null_8', 'e_3', 'null_19'}
     what if we combine triggers with the otherwise identical vi FOOT_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FOOT_1', 'e_3', 'FOOT_2', 'null_19'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4bc50>, '-', <__main__.AgrTerminal object at 0x10fc419b0>, '#', <__main__.Root object at 0x10fc4bda0>, '-', <__main__.NominalizerTerminal object at 0x10fc4b5f8>, '-', <__main__.SemanticTerminal object at 0x10fc4b4a8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FOOT terminal with values set()
we picked FOOT_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1', 'a_2'}
we picked null_27: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: uno#FOOT-e
full_pronunciation: una#FOOTa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 41.80000000000024
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 45.500000000000234
VocabularyItem:
    pronunciation: FOOT
    label: FOOT
    values: set()
    diacritic: FOOT_1
    triggers: set()
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1', 'a_2'}
    diacritic: null_27
    triggers: {('a', frozenset({'+atomic'}))}
    weight: 10.2
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 26.700000000000024
line done
line done

---------------------

input line #289
input roots: [<__main__.Root object at 0x10fc45518>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 98.09999999999908..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 45.500000000000234..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 31.50000000000016..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 98.19999999999908..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 47.000000000000284..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 31.60000000000016..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 98.29999999999907..already existed
  we're in a functional word...
  - nominalizer's values are now {'a_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'a_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_24', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_24', 'i_1', 'null_28'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_24', 'i_1', 'null_28'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_5 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_28', 'OFFSPRING_2', 'null_24', 'i_1', 'OFFSPRING_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4bb00>, '#', <__main__.Root object at 0x10fc6a4a8>, '-', <__main__.NominalizerTerminal object at 0x10fc6a5f8>, '-', <__main__.SemanticTerminal object at 0x10fc4ba90>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o_2'}
we picked null_8: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: li#OFFSPRING-i
full_pronunciation: l#OFFSPRINGi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 98.29999999999907
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_1
    triggers: set()
    weight: 11.200000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 11.700000000000006
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 20.80000000000002
line done
line done

---------------------

input line #290
input roots: [<__main__.Root object at 0x10fc4b128>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 47.100000000000286..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 98.29999999999907..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 41.80000000000024..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 41.90000000000024..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: MOUSE in its selectional

now working with the word 'MOUSE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'MOUSE_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi MOUSE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'MOUSE_2', 'MOUSE_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50390>, '-', <__main__.AgrTerminal object at 0x10fc6ab00>, '#', <__main__.Root object at 0x10fc05e48>, '-', <__main__.NominalizerTerminal object at 0x10fc50828>, '-', <__main__.SemanticTerminal object at 0x10fc50400>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MOUSE terminal with values set()
we picked MOUSE_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1', 'a_2'}
we picked null_7: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: uno#MOUSE-o
full_pronunciation: una#MOUSEa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 41.90000000000024
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 45.500000000000234
VocabularyItem:
    pronunciation: MOUSE
    label: MOUSE
    values: set()
    diacritic: MOUSE_1
    triggers: set()
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_7
    triggers: {('i', frozenset({'-atomic'}))}
    weight: 10.899999999999997
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 26.600000000000023
line done
line done

---------------------

input line #291
input roots: [<__main__.Root object at 0x10fc410f0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 45.500000000000234..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 98.39999999999907..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 41.90000000000024..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 42.00000000000024..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'OFFSPRING_1', 'null_11', 'null_10', 'OFFSPRING_5'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc182b0>, '-', <__main__.AgrTerminal object at 0x10fc58160>, '#', <__main__.Root object at 0x10fc2d438>, '-', <__main__.NominalizerTerminal object at 0x10fc2da90>, '-', <__main__.SemanticTerminal object at 0x10fc187b8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_8: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'i_2', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: una#OFFSPRING-a
full_pronunciation: uno#OFFSPRINGo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 42.00000000000024
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 47.100000000000286
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_8
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.4
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.999999999999922
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 22.80000000000001
line done
line done

---------------------

input line #292
input roots: [<__main__.Root object at 0x10fc47080>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 45.600000000000236..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 98.49999999999906..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 42.00000000000024..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 42.10000000000024..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: KEY in its selectional

now working with the word 'KEY-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'KEY_1', 'null_10'}
     what if we combine triggers with the otherwise identical vi KEY_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'KEY_3', 'KEY_1', 'e_3', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc509e8>, '-', <__main__.AgrTerminal object at 0x10fc180f0>, '#', <__main__.Root object at 0x10fc6acf8>, '-', <__main__.NominalizerTerminal object at 0x10fc6a710>, '-', <__main__.SemanticTerminal object at 0x10fc50be0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out KEY terminal with values set()
we picked KEY_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'i_2', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: una#KEY-e
full_pronunciation: una#KEYe
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: KEY to the selectional of the nominalizer whose values are {'i_2', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'a_2'}
    selectional: {'BOOK', 'CHILD', 'BALL', 'FROG', 'PIBLING', 'FLOWER', 'GRANDPARENT', 'CAR', 'CLOWN', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 18.000000000000007
    linear: (<__main__.NominalizerTerminal object at 0x10fc36a90>,)
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 42.10000000000024
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 45.600000000000236
VocabularyItem:
    pronunciation: KEY
    label: KEY
    values: set()
    diacritic: KEY_4
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'})), ('e', frozenset({'+atomic'}))}
    weight: 10.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 10.000000000000007
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 14.1
line done
line done

---------------------

input line #293
input roots: [<__main__.Root object at 0x10fc506a0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 98.59999999999906..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 32.50000000000018..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 46.20000000000024..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 98.69999999999905..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 46.30000000000024..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 42.700000000000244..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 98.79999999999905..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 98.89999999999904..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 31.700000000000163..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 46.40000000000024..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: TOWER in its selectional

now working with the word 'TOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'TOWER_1', 'e_3', 'null_10'}
     what if we combine triggers with the otherwise identical vi TOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'TOWER_1', 'TOWER_3', 'e_3', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b7b8>, '-', <__main__.AgrTerminal object at 0x10fc6a278>, '#', <__main__.Root object at 0x10fc4bac8>, '-', <__main__.NominalizerTerminal object at 0x10fc4b208>, '-', <__main__.SemanticTerminal object at 0x10fc4b780>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out TOWER terminal with values set()
we picked TOWER_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o_2'}
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: la#TOWER-e
full_pronunciation: lo#TOWERe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 98.89999999999904
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 47.000000000000284
VocabularyItem:
    pronunciation: TOWER
    label: TOWER
    values: set()
    diacritic: TOWER_1
    triggers: set()
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.89999999999992
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 14.7
line done
line done

---------------------

input line #294
input roots: [<__main__.Root object at 0x10fc6ae80>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 46.50000000000024..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 98.89999999999904..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 42.800000000000246..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 42.90000000000025..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: KEY in its selectional

now working with the word 'KEY-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'KEY_1', 'null_10'}
     what if we combine triggers with the otherwise identical vi KEY_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'KEY_3', 'KEY_1', 'e_3', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b0f0>, '-', <__main__.AgrTerminal object at 0x10fc4b9e8>, '#', <__main__.Root object at 0x10fc3e898>, '-', <__main__.NominalizerTerminal object at 0x10fc31da0>, '-', <__main__.SemanticTerminal object at 0x10fc2f160>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out KEY terminal with values set()
we picked KEY_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: una#KEY-e
full_pronunciation: uno#KEYe
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 42.90000000000025
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 46.90000000000028
VocabularyItem:
    pronunciation: KEY
    label: KEY
    values: set()
    diacritic: KEY_3
    triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))}
    weight: 9.600000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.79999999999992
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 14.7
line done
line done

---------------------

input line #295
input roots: [<__main__.Root object at 0x10fc50390>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 46.60000000000024..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 98.99999999999903..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 42.90000000000025..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 43.00000000000025..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1', 'e_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: TOWER in its selectional

now working with the word 'TOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'e_3', 'null_22'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'TOWER_1', 'null_16', 'e_3', 'null_22'}
     what if we combine triggers with the otherwise identical vi TOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'TOWER_1', 'TOWER_3', 'null_16', 'null_22', 'e_3'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67470>, '-', <__main__.AgrTerminal object at 0x10fc41c50>, '#', <__main__.Root object at 0x10fc670f0>, '-', <__main__.NominalizerTerminal object at 0x10fc67080>, '-', <__main__.SemanticTerminal object at 0x10fc67eb8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out TOWER terminal with values set()
we picked TOWER_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'i_2', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: una#TOWER-e
full_pronunciation: una#TOWERe
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: TOWER to the selectional of the nominalizer whose values are {'i_2', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'a_2'}
    selectional: {'BOOK', 'CHILD', 'BALL', 'FROG', 'PIBLING', 'FLOWER', 'GRANDPARENT', 'CAR', 'KEY', 'CLOWN', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 18.10000000000001
    linear: (<__main__.NominalizerTerminal object at 0x10fc36a90>,)
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 43.00000000000025
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 46.60000000000024
VocabularyItem:
    pronunciation: TOWER
    label: TOWER
    values: set()
    diacritic: TOWER_4
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'})), ('e', frozenset({'+atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.699999999999918
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 14.7
line done
line done

---------------------

input line #296
input roots: [<__main__.Root object at 0x10fc3e080>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 46.90000000000028..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 99.09999999999903..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 43.60000000000025..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 43.70000000000025..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'PIBLING_1', 'o_1', 'PIBLING_5'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67198>, '#', <__main__.Root object at 0x10fc43b00>, '-', <__main__.NominalizerTerminal object at 0x10fc433c8>, '-', <__main__.SemanticTerminal object at 0x10fc43630>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite', 'i_2', '+atomic'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out PIBLING terminal with values set()
we picked PIBLING_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: uno#PIBLING-o
full_pronunciation: un#PIBLINGa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 43.70000000000025
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.000000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.199999999999918
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 26.600000000000023
line done
line done

---------------------

input line #297
input roots: [<__main__.Root object at 0x10fc43198>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 47.200000000000244..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 99.19999999999902..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 43.70000000000025..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 43.80000000000025..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'CHILD_1', 'a_1'}
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CHILD_1', 'a_1', 'CHILD_2', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6f518>, '-', <__main__.AgrTerminal object at 0x10fc677b8>, '#', <__main__.Root object at 0x10fc6f080>, '-', <__main__.NominalizerTerminal object at 0x10fc6f9b0>, '-', <__main__.SemanticTerminal object at 0x10fc6fa58>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_7: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: una#CHILD-a
full_pronunciation: una#CHILDo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 43.80000000000025
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 47.200000000000244
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_7
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 10.500000000000007
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 22.80000000000001
line done
line done

---------------------

input line #298
input roots: [<__main__.Root object at 0x10fc2f128>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 99.29999999999902..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 47.200000000000244..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 31.800000000000164..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 99.39999999999901..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 47.000000000000284..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 31.900000000000166..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 99.499999999999..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: FOOT in its selectional

now working with the word 'FOOT-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'FOOT_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi FOOT_2 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_15', 'FOOT_3', 'FOOT_1', 'i_1', 'null_14'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc45b70>, '-', <__main__.AgrTerminal object at 0x10fc6f668>, '#', <__main__.Root object at 0x10fc2d668>, '-', <__main__.NominalizerTerminal object at 0x10fc2d6d8>, '-', <__main__.SemanticTerminal object at 0x10fc2d518>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FOOT terminal with values set()
we picked FOOT_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'i_2'}
we picked null_14 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#FOOT-i
full_pronunciation: li#FOOTi
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: FOOT to the selectional of the nominalizer whose values are {'i_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2'}
    selectional: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 12.499999999999991
    linear: (<__main__.NominalizerTerminal object at 0x10fc0ecc0>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'a_2'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'a_2'}

create_vi: tried nominalizer: null_24, triggers = set(), weight = 11.5..already existed

create_vi: tried nominalizer: null_25, triggers = {('a', frozenset({'+atomic'}))}, weight = 10.399999999999999..already existed

create_vi: tried nominalizer: null_33, triggers = {('e', frozenset({'+atomic'}))}, weight = 10.1..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'o_2'} as values: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'o_2'}

create_vi: tried nominalizer: null_12, triggers = set(), weight = 10.999999999999998..already existed

create_vi: tried nominalizer: null_18, triggers = {('o', frozenset({'+atomic'}))}, weight = 10.299999999999999..already existed

create_vi: tried nominalizer: null_23, triggers = {('e', frozenset({'+atomic'}))}, weight = 10.2..already existed
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 99.499999999999
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 31.900000000000166
VocabularyItem:
    pronunciation: FOOT
    label: FOOT
    values: set()
    diacritic: FOOT_4
    triggers: {('null', frozenset()), ('e', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 10.4
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 13.100000000000001
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 20.80000000000002
line done
line done

---------------------

input line #299
input roots: [<__main__.Root object at 0x10fc3d710>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 100.099999999999..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 32.60000000000018..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 47.300000000000246..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 100.199999999999..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 47.40000000000025..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 43.80000000000025..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 100.29999999999899..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 100.39999999999898..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 32.50000000000016..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 47.50000000000025..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: CAR in its selectional

now working with the word 'CAR-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'CAR_1'}
     what if we combine triggers with the otherwise identical vi CAR_2 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'null_10', 'CAR_1', 'null_11', 'CAR_3'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6f7b8>, '-', <__main__.AgrTerminal object at 0x10fc2da90>, '#', <__main__.Root object at 0x10fc6f780>, '-', <__main__.NominalizerTerminal object at 0x10fc6f748>, '-', <__main__.SemanticTerminal object at 0x10fc6fda0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CAR terminal with values set()
we picked CAR_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#CAR-a
full_pronunciation: lo#CARa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 100.39999999999898
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 47.000000000000284
VocabularyItem:
    pronunciation: CAR
    label: CAR
    values: set()
    diacritic: CAR_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.5
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.099999999999916
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 26.700000000000024
line done
line done

---------------------

input line #300
input roots: [<__main__.Root object at 0x10fc454a8>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 100.39999999999898..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 32.70000000000018..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 47.000000000000284..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 100.49999999999898..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 47.100000000000286..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 43.900000000000254..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 100.59999999999897..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 100.69999999999897..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 32.600000000000165..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 47.20000000000029..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'GRANDPARENT_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'GRANDPARENT_1', 'GRANDPARENT_2'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc42a20>, '-', <__main__.AgrTerminal object at 0x10fc6f278>, '#', <__main__.Root object at 0x10fc43b00>, '-', <__main__.NominalizerTerminal object at 0x10fc43198>, '-', <__main__.SemanticTerminal object at 0x10fc43278>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'i_2', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: lo#GRANDPARENT-o
full_pronunciation: la#GRANDPARENTe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 100.69999999999897
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 47.50000000000025
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_4
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.200000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 10.400000000000007
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 15.2
line done
line done

---------------------

input line #301
input roots: [<__main__.Root object at 0x10fc6f550>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 100.69999999999897..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 47.50000000000025..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 32.700000000000166..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 100.79999999999896..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 47.30000000000029..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 32.80000000000017..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 100.89999999999895..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: BOOK in its selectional

now working with the word 'BOOK-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'BOOK_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi BOOK_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_15', 'BOOK_2', 'BOOK_1', 'i_1', 'null_14'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6f198>, '#', <__main__.Root object at 0x10fc67128>, '-', <__main__.NominalizerTerminal object at 0x10fc67c88>, '-', <__main__.SemanticTerminal object at 0x10fc67da0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out BOOK terminal with values set()
we picked BOOK_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: li#BOOK-i
full_pronunciation: l#BOOKe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 100.89999999999895
VocabularyItem:
    pronunciation: BOOK
    label: BOOK
    values: set()
    diacritic: BOOK_3
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 10.200000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.999999999999915
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 14.1
line done
line done

---------------------

input line #302
input roots: [<__main__.Root object at 0x10fc6f940>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 100.89999999999895..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 47.60000000000025..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 32.90000000000017..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 100.99999999999895..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 47.40000000000029..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 33.00000000000017..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 101.09999999999894..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'GRANDPARENT_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_3 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_15', 'GRANDPARENT_4', 'i_1', 'null_14', 'GRANDPARENT_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc677b8>, '#', <__main__.Root object at 0x10fc14668>, '-', <__main__.NominalizerTerminal object at 0x10fc41940>, '-', <__main__.SemanticTerminal object at 0x10fc416d8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_5: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#GRANDPARENT-i
full_pronunciation: l#GRANDPARENTi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 101.09999999999894
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_5
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.899999999999913
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 21.50000000000002
line done
line done

---------------------

input line #303
input roots: [<__main__.Root object at 0x10fc41390>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 101.09999999999894..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 47.70000000000025..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 32.80000000000018..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 101.19999999999894..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 47.50000000000029..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 32.90000000000018..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 101.29999999999893..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: TOWER in its selectional

now working with the word 'TOWER-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'null_32', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'TOWER_1', 'null_16', 'null_32', 'i_1'}
     what if we combine triggers with the otherwise identical vi TOWER_3 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'TOWER_1', 'null_16', 'null_32', 'i_1', 'TOWER_2'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b828>, '-', <__main__.AgrTerminal object at 0x10fc67e10>, '#', <__main__.Root object at 0x10fc4bb00>, '-', <__main__.NominalizerTerminal object at 0x10fc4b668>, '-', <__main__.SemanticTerminal object at 0x10fc4b518>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'a_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out TOWER terminal with values set()
we picked TOWER_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: le#TOWER-i
full_pronunciation: li#TOWERe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 101.29999999999893
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 33.00000000000017
VocabularyItem:
    pronunciation: TOWER
    label: TOWER
    values: set()
    diacritic: TOWER_3
    triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))}
    weight: 10.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.799999999999912
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 14.0
line done
line done

---------------------

input line #304
input roots: [<__main__.Root object at 0x10fc4b5f8>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 47.60000000000029..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 101.29999999999893..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 44.000000000000256..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 44.10000000000026..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: BOOK in its selectional

now working with the word 'BOOK-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'BOOK_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi BOOK_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'BOOK_1', 'BOOK_3'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a7b8>, '-', <__main__.AgrTerminal object at 0x10fc4b7f0>, '#', <__main__.Root object at 0x10fc6ab38>, '-', <__main__.NominalizerTerminal object at 0x10fc6a2e8>, '-', <__main__.SemanticTerminal object at 0x10fc6a588>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BOOK terminal with values set()
we picked BOOK_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: uno#BOOK-o
full_pronunciation: uno#BOOKo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: BOOK to the selectional of the nominalizer whose values are {'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'o_2'}
    selectional: {'MOUSE', 'CHILD', 'BOOK', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 50.80000000000047
    linear: (<__main__.NominalizerTerminal object at 0x10fc08908>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_6, triggers = set(), weight = 9.900000000000002..already existed

create_vi: tried nominalizer: null_7, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.899999999999997..already existed

create_vi: tried nominalizer: null_26, triggers = {('e', frozenset({'-atomic'}))}, weight = 11.999999999999996..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_14, triggers = set(), weight = 13.700000000000001..already existed

create_vi: tried nominalizer: null_15, triggers = {('i', frozenset({'-atomic'}))}, weight = 11.199999999999996..already existed
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 44.10000000000026
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 47.60000000000029
VocabularyItem:
    pronunciation: BOOK
    label: BOOK
    values: set()
    diacritic: BOOK_4
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 11.5
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.69999999999991
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 22.900000000000013
line done
line done

---------------------

input line #305
input roots: [<__main__.Root object at 0x10fc6a8d0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 48.200000000000294..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 101.39999999999893..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 44.70000000000026..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 44.80000000000026..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CHILD_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'CHILD_1', 'null_9', 'o_1', 'CHILD_3'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc58400>, '-', <__main__.AgrTerminal object at 0x10fc4b470>, '#', <__main__.Root object at 0x10fc18748>, '-', <__main__.NominalizerTerminal object at 0x10fc47e48>, '-', <__main__.SemanticTerminal object at 0x10fc36160>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_6: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'i_2', 'a_2'}
we picked null_14 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: uno#CHILD-o
full_pronunciation: una#CHILDo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 44.80000000000026
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 47.70000000000025
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_6
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 10.5
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 13.700000000000001
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 23.500000000000014
line done
line done

---------------------

input line #306
input roots: [<__main__.Root object at 0x10fc581d0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 101.49999999999892..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 33.000000000000185..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 48.300000000000296..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 101.59999999999891..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 48.4000000000003..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 44.80000000000026..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 101.69999999999891..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 101.7999999999989..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 33.00000000000017..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 48.5000000000003..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'OFFSPRING_3', 'o_1', 'OFFSPRING_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc47e48>, '-', <__main__.AgrTerminal object at 0x10fc18240>, '#', <__main__.Root object at 0x10fc58f60>, '-', <__main__.NominalizerTerminal object at 0x10fc58c88>, '-', <__main__.SemanticTerminal object at 0x10fc58400>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_6: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: lo#OFFSPRING-o
full_pronunciation: lo#OFFSPRINGa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 101.7999999999989
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 48.5000000000003
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_6
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.19999999999991
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 26.600000000000023
line done
line done

---------------------

input line #307
input roots: [<__main__.Root object at 0x10fc180f0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 47.70000000000025..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 101.7999999999989..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 44.90000000000026..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 45.00000000000026..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: BALL in its selectional

now working with the word 'BALL-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'BALL_1', 'a_1'}
     what if we combine triggers with the otherwise identical vi BALL_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'BALL_1', 'BALL_2', 'null_10', 'null_11'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a518>, '-', <__main__.AgrTerminal object at 0x10fc47400>, '#', <__main__.Root object at 0x10fc6aac8>, '-', <__main__.NominalizerTerminal object at 0x10fc6a748>, '-', <__main__.SemanticTerminal object at 0x10fc6a3c8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BALL terminal with values set()
we picked BALL_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2', 'a'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: una#BALL-a
full_pronunciation: una#BALLa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: BALL to the selectional of the nominalizer whose values are {'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'a_2'}
    selectional: {'FROG', 'CHILD', 'BALL', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 48.30000000000044
    linear: (<__main__.NominalizerTerminal object at 0x10fc05f28>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'FROG', 'BALL', 'CHILD', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_16, triggers = set(), weight = 11.5..already existed

create_vi: tried nominalizer: null_32, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.2..already existed

create_vi: tried nominalizer: null_17, triggers = {('e', frozenset({'-atomic'}))}, weight = 10.399999999999999..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_24, triggers = set(), weight = 11.6..already existed

create_vi: tried nominalizer: null_28, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.799999999999999..already existed
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 45.00000000000026
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 47.70000000000025
VocabularyItem:
    pronunciation: BALL
    label: BALL
    values: set()
    diacritic: BALL_2
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 10.8
     what if we combine triggers with the otherwise identical vi BALL_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 10.300000000000008
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 26.600000000000023
line done
line done

---------------------

input line #308
input roots: [<__main__.Root object at 0x10fc6ae80>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 101.8999999999989..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 33.100000000000186..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 48.30000000000025..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 101.99999999999889..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 48.400000000000254..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 45.600000000000264..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 102.09999999999889..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 102.19999999999888..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 33.10000000000017..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 48.500000000000256..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'GRANDPARENT_1'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'GRANDPARENT_1', 'null_11', 'null_10', 'GRANDPARENT_3'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4beb8>, '#', <__main__.Root object at 0x10fc4b668>, '-', <__main__.NominalizerTerminal object at 0x10fc4bb00>, '-', <__main__.SemanticTerminal object at 0x10fc4bcc0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '+atomic'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_8: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: la#GRANDPARENT-a
full_pronunciation: l#GRANDPARENTo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 102.19999999999888
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_8
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.09999999999991
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 23.500000000000014
line done
line done

---------------------

input line #309
input roots: [<__main__.Root object at 0x10fc4b5f8>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 48.60000000000026..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 102.19999999999888..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 45.700000000000266..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 45.80000000000027..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'CHILD_1', 'a_1'}
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CHILD_1', 'a_1', 'CHILD_2', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc41cf8>, '-', <__main__.AgrTerminal object at 0x10fc4b518>, '#', <__main__.Root object at 0x10fc412b0>, '-', <__main__.NominalizerTerminal object at 0x10fc416d8>, '-', <__main__.SemanticTerminal object at 0x10fc41a90>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_9: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: una#CHILD-a
full_pronunciation: uno#CHILDo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 45.80000000000027
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 48.4000000000003
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_9
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.999999999999908
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 23.400000000000013
line done
line done

---------------------

input line #310
input roots: [<__main__.Root object at 0x10fc4bf28>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 102.29999999999887..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 48.70000000000026..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 33.20000000000019..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 102.39999999999887..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 48.4000000000003..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 33.30000000000019..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 102.49999999999886..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: CHILD in its selectional

now working with the word 'CHILD-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6', 'CHILD_1'}
     what if we combine triggers with the otherwise identical vi CHILD_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'CHILD_1', 'CHILD_7', 'null_26', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67b00>, '-', <__main__.AgrTerminal object at 0x10fc31278>, '#', <__main__.Root object at 0x10fc3cf28>, '-', <__main__.NominalizerTerminal object at 0x10fc67860>, '-', <__main__.SemanticTerminal object at 0x10fc67cf8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: le#CHILD-e
full_pronunciation: li#CHILDi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 102.49999999999886
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 33.10000000000017
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_2
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 11.100000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.899999999999906
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 21.50000000000002
line done
line done

---------------------

input line #311
input roots: [<__main__.Root object at 0x10fc676a0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 48.80000000000026..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 102.49999999999886..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 45.80000000000027..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 45.90000000000027..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: FROG in its selectional

now working with the word 'FROG-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi FROG_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_2', 'a_1', 'FROG_1', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc3bf28>, '-', <__main__.AgrTerminal object at 0x10fc43c88>, '#', <__main__.Root object at 0x10fc6f9e8>, '-', <__main__.NominalizerTerminal object at 0x10fc6f940>, '-', <__main__.SemanticTerminal object at 0x10fc357b8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FROG terminal with values set()
we picked FROG_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: una#FROG-a
full_pronunciation: una#FROGe
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 45.90000000000027
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 48.80000000000026
VocabularyItem:
    pronunciation: FROG
    label: FROG
    values: set()
    diacritic: FROG_3
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.799999999999905
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 15.1
line done
line done

---------------------

input line #312
input roots: [<__main__.Root object at 0x10fc43278>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 48.80000000000026..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 102.59999999999886..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 45.90000000000027..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 46.00000000000027..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'OFFSPRING_1', 'null_11', 'null_10', 'OFFSPRING_5'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc3dd30>, '-', <__main__.AgrTerminal object at 0x10fc6f550>, '#', <__main__.Root object at 0x10fc457f0>, '-', <__main__.NominalizerTerminal object at 0x10fc45860>, '-', <__main__.SemanticTerminal object at 0x10fc458d0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_8: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: una#OFFSPRING-a
full_pronunciation: uno#OFFSPRINGo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 46.00000000000027
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 48.4000000000003
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_8
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.3
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 11.600000000000007
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 23.30000000000001
line done
line done

---------------------

input line #313
input roots: [<__main__.Root object at 0x10fc42128>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 48.90000000000026..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 102.69999999999885..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 46.00000000000027..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 46.10000000000027..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'OFFSPRING_1', 'null_11', 'null_10', 'OFFSPRING_5'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6f438>, '#', <__main__.Root object at 0x10fc86198>, '-', <__main__.NominalizerTerminal object at 0x10fc861d0>, '-', <__main__.SemanticTerminal object at 0x10fc864e0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite', 'i_2', '+atomic'}
we picked una_1: no super match (neither decl nor L1-gender)
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'i_2'}
we picked null_14 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: una#OFFSPRING-a
full_pronunciation: una#OFFSPRINGo
vis_used:
Failure
VocabularyItem:
    pronunciation: una
    label: definite
    values: {'-definite', '+atomic'}
    diacritic: una_1
    triggers: set()
    weight: 10.900000000000002
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_3
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 13.600000000000001
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 23.20000000000001
line done
line done

---------------------

input line #314
input roots: [<__main__.Root object at 0x10fc86240>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 102.79999999999885..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 33.40000000000019..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 49.00000000000026..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 102.89999999999884..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 49.100000000000264..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 46.20000000000027..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 102.99999999999883..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 103.09999999999883..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 33.10000000000017..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 49.200000000000266..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: MILKCOW in its selectional

now working with the word 'MILKCOW-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'MILKCOW_1'}
     what if we combine triggers with the otherwise identical vi MILKCOW_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'MILKCOW_1', 'MILKCOW_2', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6f978>, '-', <__main__.AgrTerminal object at 0x10fc2d6d8>, '#', <__main__.Root object at 0x10fc6fac8>, '-', <__main__.NominalizerTerminal object at 0x10fc6f6a0>, '-', <__main__.SemanticTerminal object at 0x10fc6f048>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MILKCOW terminal with values set()
we picked MILKCOW_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'a_2', 'a'}
we picked null_6 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#MILKCOW-a
full_pronunciation: la#MILKCOWa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: MILKCOW to the selectional of the nominalizer whose values are {'e_1', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1', 'a_2'}
    selectional: {'FROG', 'BALL', 'CHILD', 'TOWER', 'PIBLING', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 21.700000000000028
    linear: (<__main__.NominalizerTerminal object at 0x10fc2aa20>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 103.09999999999883
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 49.200000000000266
VocabularyItem:
    pronunciation: MILKCOW
    label: MILKCOW
    values: set()
    diacritic: MILKCOW_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.4
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_6
    triggers: set()
    weight: 9.900000000000002
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 27.70000000000003
line done
line done

---------------------

input line #315
input roots: [<__main__.Root object at 0x10fc2da90>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 48.4000000000003..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 103.69999999999882..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 46.300000000000274..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 46.400000000000276..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1', 'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_18', 'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_18', 'o_1', 'GRANDPARENT_1', 'null_12'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'o_1', 'null_18', 'GRANDPARENT_1', 'GRANDPARENT_2'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc3d470>, '#', <__main__.Root object at 0x10fc43b00>, '-', <__main__.NominalizerTerminal object at 0x10fc43128>, '-', <__main__.SemanticTerminal object at 0x10fc43780>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite', 'i_2', '+atomic'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_6: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: uno#GRANDPARENT-o
full_pronunciation: un#GRANDPARENTa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 46.400000000000276
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_6
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 10.300000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.699999999999903
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 28.20000000000003
line done
line done

---------------------

input line #316
input roots: [<__main__.Root object at 0x10fc43f60>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 103.79999999999882..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 33.50000000000019..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 49.80000000000027..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 103.89999999999881..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 49.90000000000027..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 46.400000000000276..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 103.9999999999988..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 104.0999999999988..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 33.20000000000017..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 50.00000000000027..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: KEY in its selectional

now working with the word 'KEY-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'KEY_1', 'null_10'}
     what if we combine triggers with the otherwise identical vi KEY_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'KEY_3', 'KEY_1', 'e_3', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67eb8>, '-', <__main__.AgrTerminal object at 0x10fc207b8>, '#', <__main__.Root object at 0x10fc677b8>, '-', <__main__.NominalizerTerminal object at 0x10fc67358>, '-', <__main__.SemanticTerminal object at 0x10fc67f28>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'i_2', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out KEY terminal with values set()
we picked KEY_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'i_2', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: la#KEY-e
full_pronunciation: lo#KEYe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 104.0999999999988
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 48.4000000000003
VocabularyItem:
    pronunciation: KEY
    label: KEY
    values: set()
    diacritic: KEY_4
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'})), ('e', frozenset({'+atomic'}))}
    weight: 11.3
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.599999999999902
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 15.1
line done
line done

---------------------

input line #317
input roots: [<__main__.Root object at 0x10fc3dba8>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 104.0999999999988..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 33.60000000000019..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 48.4000000000003..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 104.1999999999988..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 48.5000000000003..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 46.50000000000028..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 104.29999999999879..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 104.39999999999878..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 33.300000000000175..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 48.6000000000003..already existed
  we're in a functional word...
  - nominalizer's values are now {'i_2', 'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: CASTLE in its selectional

now working with the word 'CASTLE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_18', 'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_18', 'o_1', 'CASTLE_1', 'null_12'}
     what if we combine triggers with the otherwise identical vi CASTLE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'CASTLE_2', 'o_1', 'null_18', 'CASTLE_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc280b8>, '-', <__main__.AgrTerminal object at 0x10fc67b00>, '#', <__main__.Root object at 0x10fc4b6a0>, '-', <__main__.NominalizerTerminal object at 0x10fc4bba8>, '-', <__main__.SemanticTerminal object at 0x10fc4be10>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'i_2', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CASTLE terminal with values set()
we picked CASTLE_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'a_2'}
we picked null_24 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: lo#CASTLE-o
full_pronunciation: la#CASTLEe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 104.39999999999878
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 50.00000000000027
VocabularyItem:
    pronunciation: CASTLE
    label: CASTLE
    values: set()
    diacritic: CASTLE_3
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2', 'a_2'}
    diacritic: null_24
    triggers: set()
    weight: 11.6
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 15.0
line done
line done

---------------------

input line #318
input roots: [<__main__.Root object at 0x10fc20ef0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 104.39999999999878..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 33.700000000000195..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 50.00000000000027..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 104.49999999999878..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 50.10000000000027..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 46.60000000000028..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 104.59999999999877..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 104.69999999999877..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 33.400000000000176..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 50.20000000000027..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: KEY in its selectional

now working with the word 'KEY-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'KEY_1', 'null_10'}
     what if we combine triggers with the otherwise identical vi KEY_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'KEY_3', 'KEY_1', 'e_3', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b8d0>, '-', <__main__.AgrTerminal object at 0x10fc281d0>, '#', <__main__.Root object at 0x10fc22940>, '-', <__main__.NominalizerTerminal object at 0x10fc4ba90>, '-', <__main__.SemanticTerminal object at 0x10fc4b7f0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out KEY terminal with values set()
we picked KEY_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: la#KEY-e
full_pronunciation: la#KEYe
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: KEY to the selectional of the nominalizer whose values are {'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'a_2'}
    selectional: {'FROG', 'CHILD', 'BALL', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 51.000000000000476
    linear: (<__main__.NominalizerTerminal object at 0x10fc05f28>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'FROG', 'BALL', 'CHILD', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_6, triggers = set(), weight = 10.500000000000002..already existed

create_vi: tried nominalizer: null_7, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.999999999999996..already existed

create_vi: tried nominalizer: null_26, triggers = {('e', frozenset({'-atomic'}))}, weight = 12.099999999999996..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_14, triggers = set(), weight = 13.600000000000001..already existed

create_vi: tried nominalizer: null_15, triggers = {('i', frozenset({'-atomic'}))}, weight = 11.299999999999995..already existed
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 104.69999999999877
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 50.20000000000027
VocabularyItem:
    pronunciation: KEY
    label: KEY
    values: set()
    diacritic: KEY_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.600000000000001
     what if we combine triggers with the otherwise identical vi KEY_3 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.4999999999999
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 15.0
line done
line done

---------------------

input line #319
input roots: [<__main__.Root object at 0x10fc4b780>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 105.29999999999876..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 50.800000000000274..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 33.800000000000196..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 105.39999999999876..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 48.7000000000003..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 33.9000000000002..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 105.49999999999875..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: CAR in its selectional

now working with the word 'CAR-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'CAR_1', 'null_6'}
     what if we combine triggers with the otherwise identical vi CAR_3 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'CAR_2', 'null_26', 'CAR_1', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a748>, '#', <__main__.Root object at 0x10fc50a20>, '-', <__main__.NominalizerTerminal object at 0x10fc6a0b8>, '-', <__main__.SemanticTerminal object at 0x10fc6a128>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out CAR terminal with values set()
we picked CAR_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: le#CAR-e
full_pronunciation: l#CARe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 105.49999999999875
VocabularyItem:
    pronunciation: CAR
    label: CAR
    values: set()
    diacritic: CAR_3
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.9999999999999
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 14.1
line done
line done

---------------------

input line #320
input roots: [<__main__.Root object at 0x10fc6ab00>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 50.900000000000276..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 105.49999999999875..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 46.70000000000028..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 46.80000000000028..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: BALL in its selectional

now working with the word 'BALL-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'BALL_1', 'a_1'}
     what if we combine triggers with the otherwise identical vi BALL_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'BALL_1', 'BALL_2', 'null_10', 'null_11'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc86588>, '-', <__main__.AgrTerminal object at 0x10fc584e0>, '#', <__main__.Root object at 0x10fc86278>, '-', <__main__.NominalizerTerminal object at 0x10fc86208>, '-', <__main__.SemanticTerminal object at 0x10fc86b38>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BALL terminal with values set()
we picked BALL_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'o_2', 'a'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: una#BALL-a
full_pronunciation: uno#BALLa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 46.80000000000028
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 48.7000000000003
VocabularyItem:
    pronunciation: BALL
    label: BALL
    values: set()
    diacritic: BALL_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 11.500000000000007
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 28.20000000000003
line done
line done

---------------------

input line #321
input roots: [<__main__.Root object at 0x10fc6a278>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 105.59999999999874..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 51.00000000000028..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 34.0000000000002..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 105.69999999999874..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 48.7000000000003..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 34.1000000000002..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 105.79999999999873..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: MILKCOW in its selectional

now working with the word 'MILKCOW-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'MILKCOW_1', 'null_6'}
     what if we combine triggers with the otherwise identical vi MILKCOW_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'MILKCOW_3', 'MILKCOW_1', 'null_26', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc86a20>, '#', <__main__.Root object at 0x10fc861d0>, '-', <__main__.NominalizerTerminal object at 0x10fc86278>, '-', <__main__.SemanticTerminal object at 0x10fc86358>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out MILKCOW terminal with values set()
we picked MILKCOW_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'a_2'}
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: le#MILKCOW-e
full_pronunciation: l#MILKCOWi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 105.79999999999873
VocabularyItem:
    pronunciation: MILKCOW
    label: MILKCOW
    values: set()
    diacritic: MILKCOW_1
    triggers: set()
    weight: 10.600000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.8999999999999
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 21.40000000000002
line done
line done

---------------------

input line #322
input roots: [<__main__.Root object at 0x10fc86470>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 105.79999999999873..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 51.10000000000028..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 33.50000000000018..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 105.89999999999873..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 48.8000000000003..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 33.60000000000018..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 105.99999999999872..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'PIBLING_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi PIBLING_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_5 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_7', 'null_15', 'PIBLING_1', 'i_1', 'null_14'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc86da0>, '#', <__main__.Root object at 0x10fc506a0>, '-', <__main__.NominalizerTerminal object at 0x10fc50438>, '-', <__main__.SemanticTerminal object at 0x10fc50860>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out PIBLING terminal with values set()
we picked PIBLING_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values set()
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: li#PIBLING-i
full_pronunciation: l#PIBLINGi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 105.99999999999872
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_1
    triggers: set()
    weight: 11.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.799999999999898
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 21.40000000000002
line done
line done

---------------------

input line #323
input roots: [<__main__.Root object at 0x10fc50a20>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 105.99999999999872..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 51.20000000000028..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 33.70000000000018..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 106.09999999999872..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 48.900000000000304..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 33.80000000000018..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 106.19999999999871..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: CASTLE in its selectional

now working with the word 'CASTLE-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CASTLE_1', 'null_12', 'null_13', 'i_1'}
     what if we combine triggers with the otherwise identical vi CASTLE_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1', 'CASTLE_1', 'CASTLE_3'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b7b8>, '-', <__main__.AgrTerminal object at 0x10fc6ab00>, '#', <__main__.Root object at 0x10fc4b588>, '-', <__main__.NominalizerTerminal object at 0x10fc4b780>, '-', <__main__.SemanticTerminal object at 0x10fc4b048>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'a_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CASTLE terminal with values set()
we picked CASTLE_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'i_2', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#CASTLE-i
full_pronunciation: li#CASTLEi
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CASTLE to the selectional of the nominalizer whose values are {'i_2', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'a_2'}
    selectional: {'BOOK', 'CHILD', 'BALL', 'FROG', 'PIBLING', 'FLOWER', 'GRANDPARENT', 'TOWER', 'CAR', 'KEY', 'CLOWN', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 19.70000000000001
    linear: (<__main__.NominalizerTerminal object at 0x10fc36a90>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 106.19999999999871
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 33.80000000000018
VocabularyItem:
    pronunciation: CASTLE
    label: CASTLE
    values: set()
    diacritic: CASTLE_3
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.700000000000001
     what if we combine triggers with the otherwise identical vi CASTLE_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 10.800000000000008
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 21.40000000000002
line done
line done

---------------------

input line #324
input roots: [<__main__.Root object at 0x10fc6a9b0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 106.7999999999987..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 51.30000000000028..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 34.2000000000002..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 106.8999999999987..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 49.000000000000306..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 34.3000000000002..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 106.99999999999869..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'o_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'o_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_20'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_20', 'null_31'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'e_2', 'null_20', 'null_31'}
     what if we combine triggers with the otherwise identical vi PIBLING_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_5 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_20', 'PIBLING_1', 'PIBLING_3', 'null_31'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4bba8>, '-', <__main__.AgrTerminal object at 0x10fc4bda0>, '#', <__main__.Root object at 0x10fc31278>, '-', <__main__.NominalizerTerminal object at 0x10fc2f048>, '-', <__main__.SemanticTerminal object at 0x10fc4b5c0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic', 'o_2'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_9: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i', 'e_1', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: le#PIBLING-e
full_pronunciation: le#PIBLINGi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 106.99999999999869
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 34.3000000000002
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_9
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.699999999999896
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 21.90000000000002
line done
line done

---------------------

input line #325
input roots: [<__main__.Root object at 0x10fc4be10>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 106.99999999999869..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 34.3000000000002..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 51.40000000000028..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 107.09999999999869..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 51.500000000000284..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 46.80000000000028..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 107.19999999999868..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 107.29999999999868..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 34.40000000000018..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 51.600000000000286..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_2', 'a_1', 'PIBLING_1', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'e_1'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b400>, '#', <__main__.Root object at 0x10fc67240>, '-', <__main__.NominalizerTerminal object at 0x10fc67908>, '-', <__main__.SemanticTerminal object at 0x10fc67cc0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', 'e_1', '+atomic'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out PIBLING terminal with values set()
we picked PIBLING_5: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'e_1', 'null'}
we picked null_6 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: la#PIBLING-a
full_pronunciation: l#PIBLINGo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 107.29999999999868
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_5
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 10.100000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_6
    triggers: set()
    weight: 10.500000000000002
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 23.30000000000001
line done
line done

---------------------

input line #326
input roots: [<__main__.Root object at 0x10fc3eac8>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 107.29999999999868..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 51.70000000000029..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 34.500000000000185..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 107.39999999999867..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 49.10000000000031..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 34.600000000000186..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 107.49999999999866..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: FLOWER in its selectional

now working with the word 'FLOWER-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'FLOWER_1', 'i_1'}
     what if we combine triggers with the otherwise identical vi FLOWER_3 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'FLOWER_2', 'null_13', 'i_1', 'FLOWER_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc43198>, '-', <__main__.AgrTerminal object at 0x10fc3ce48>, '#', <__main__.Root object at 0x10fc438d0>, '-', <__main__.NominalizerTerminal object at 0x10fc436a0>, '-', <__main__.SemanticTerminal object at 0x10fc43208>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'o_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FLOWER terminal with values set()
we picked FLOWER_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i_2', 'o_2'}
we picked null_23: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: li#FLOWER-i
full_pronunciation: li#FLOWERi
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: FLOWER to the selectional of the nominalizer whose values are {'i_2', 'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'o_2'}
    selectional: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'GRANDPARENT', 'CASTLE', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 21.900000000000027
    linear: (<__main__.NominalizerTerminal object at 0x10fc22eb8>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 107.49999999999866
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 34.600000000000186
VocabularyItem:
    pronunciation: FLOWER
    label: FLOWER
    values: set()
    diacritic: FLOWER_1
    triggers: set()
    weight: 9.500000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2', 'o_2'}
    diacritic: null_23
    triggers: {('e', frozenset({'+atomic'}))}
    weight: 10.2
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 21.90000000000002
line done
line done

---------------------

input line #327
input roots: [<__main__.Root object at 0x10fc67780>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 108.09999999999866..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 34.400000000000205..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 49.20000000000031..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 108.19999999999865..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 49.30000000000031..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 46.90000000000028..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 108.29999999999865..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 108.39999999999864..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 35.20000000000019..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 49.40000000000031..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'PIBLING_1', 'o_1', 'PIBLING_5'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6f2e8>, '-', <__main__.AgrTerminal object at 0x10fc3bf28>, '#', <__main__.Root object at 0x10fc6f710>, '-', <__main__.NominalizerTerminal object at 0x10fc6f080>, '-', <__main__.SemanticTerminal object at 0x10fc6f6d8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_6: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: lo#PIBLING-o
full_pronunciation: lo#PIBLINGo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: PIBLING to the selectional of the nominalizer whose values are {'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'o_2'}
    selectional: {'MOUSE', 'CHILD', 'BOOK', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 53.100000000000506
    linear: (<__main__.NominalizerTerminal object at 0x10fc08908>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_6, triggers = set(), weight = 10.500000000000002..already existed

create_vi: tried nominalizer: null_7, triggers = {('i', frozenset({'-atomic'}))}, weight = 11.099999999999996..already existed

create_vi: tried nominalizer: null_26, triggers = {('e', frozenset({'-atomic'}))}, weight = 12.199999999999996..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_14, triggers = set(), weight = 13.700000000000001..already existed

create_vi: tried nominalizer: null_15, triggers = {('i', frozenset({'-atomic'}))}, weight = 11.399999999999995..already existed
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 108.39999999999864
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 49.40000000000031
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_6
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.599999999999895
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 23.30000000000001
line done
line done

---------------------

input line #328
input roots: [<__main__.Root object at 0x10fc2f160>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 108.99999999999864..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 34.500000000000206..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 50.00000000000031..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 109.09999999999863..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 50.100000000000314..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 47.000000000000284..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 109.19999999999862..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 109.29999999999862..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 35.30000000000019..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 50.200000000000315..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: BOOK in its selectional

now working with the word 'BOOK-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'BOOK_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi BOOK_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'BOOK_1', 'BOOK_3'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc960b8>, '-', <__main__.AgrTerminal object at 0x10fc42b00>, '#', <__main__.Root object at 0x10fc962e8>, '-', <__main__.NominalizerTerminal object at 0x10fc96278>, '-', <__main__.SemanticTerminal object at 0x10fc96198>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BOOK terminal with values set()
we picked BOOK_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'a_2'}
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: lo#BOOK-o
full_pronunciation: la#BOOKo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 109.29999999999862
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 51.70000000000029
VocabularyItem:
    pronunciation: BOOK
    label: BOOK
    values: set()
    diacritic: BOOK_1
    triggers: set()
    weight: 10.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.099999999999895
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 23.900000000000013
line done
line done

---------------------

input line #329
input roots: [<__main__.Root object at 0x10fc43128>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 109.29999999999862..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 51.70000000000029..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 34.60000000000021..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 109.39999999999861..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 50.30000000000032..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 34.70000000000021..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 109.49999999999861..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'GRANDPARENT_1', 'null_6'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_3 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'GRANDPARENT_7', 'null_26', 'GRANDPARENT_1', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67d68>, '-', <__main__.AgrTerminal object at 0x10fc3c748>, '#', <__main__.Root object at 0x10fc3e828>, '-', <__main__.NominalizerTerminal object at 0x10fc3e2b0>, '-', <__main__.SemanticTerminal object at 0x10fc67390>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'o_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_9: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'i_2', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: le#GRANDPARENT-e
full_pronunciation: li#GRANDPARENTe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 109.49999999999861
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 35.30000000000019
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_9
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 11.400000000000007
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 14.299999999999999
line done
line done

---------------------

input line #330
input roots: [<__main__.Root object at 0x10fc67080>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 51.80000000000029..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 109.49999999999861..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 47.100000000000286..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 47.20000000000029..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: BALL in its selectional

now working with the word 'BALL-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'BALL_1', 'a_1'}
     what if we combine triggers with the otherwise identical vi BALL_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'BALL_1', 'BALL_2', 'null_10', 'null_11'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc86e10>, '-', <__main__.AgrTerminal object at 0x10fc670f0>, '#', <__main__.Root object at 0x10fc86320>, '-', <__main__.NominalizerTerminal object at 0x10fc86b70>, '-', <__main__.SemanticTerminal object at 0x10fc86080>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BALL terminal with values set()
we picked BALL_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2', 'a'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: una#BALL-a
full_pronunciation: uno#BALLa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 47.20000000000029
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 50.30000000000032
VocabularyItem:
    pronunciation: BALL
    label: BALL
    values: set()
    diacritic: BALL_2
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 11.3
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 11.300000000000008
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 28.300000000000033
line done
line done

---------------------

input line #331
input roots: [<__main__.Root object at 0x10fc86d30>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 51.90000000000029..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 109.5999999999986..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 47.20000000000029..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 47.30000000000029..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: CAR in its selectional

now working with the word 'CAR-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'CAR_1'}
     what if we combine triggers with the otherwise identical vi CAR_2 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'null_10', 'CAR_1', 'null_11', 'CAR_3'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc38470>, '-', <__main__.AgrTerminal object at 0x10fc863c8>, '#', <__main__.Root object at 0x10fc2dd68>, '-', <__main__.NominalizerTerminal object at 0x10fc355c0>, '-', <__main__.SemanticTerminal object at 0x10fc35a90>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CAR terminal with values set()
we picked CAR_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o_2'}
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: una#CAR-a
full_pronunciation: uno#CARe
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 47.30000000000029
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 50.200000000000315
VocabularyItem:
    pronunciation: CAR
    label: CAR
    values: set()
    diacritic: CAR_1
    triggers: set()
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.999999999999893
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 15.5
line done
line done

---------------------

input line #332
input roots: [<__main__.Root object at 0x10fc3e898>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 109.6999999999986..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 52.00000000000029..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 35.30000000000019..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 109.79999999999859..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 50.200000000000315..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 35.40000000000019..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 109.89999999999858..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: FOOT in its selectional

now working with the word 'FOOT-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FOOT_1', 'null_12', 'null_13', 'i_1'}
     what if we combine triggers with the otherwise identical vi FOOT_2 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'FOOT_3', 'FOOT_1', 'null_13', 'i_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc47160>, '-', <__main__.AgrTerminal object at 0x10fc184e0>, '#', <__main__.Root object at 0x10fc470f0>, '-', <__main__.NominalizerTerminal object at 0x10fc47438>, '-', <__main__.SemanticTerminal object at 0x10fc47c18>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'a_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FOOT terminal with values set()
we picked FOOT_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i_2', 'a_2'}
we picked null_24: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: li#FOOT-i
full_pronunciation: li#FOOTi
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: FOOT to the selectional of the nominalizer whose values are {'i_2', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'a_2'}
    selectional: {'BOOK', 'CHILD', 'BALL', 'FROG', 'PIBLING', 'FLOWER', 'GRANDPARENT', 'TOWER', 'CASTLE', 'CAR', 'KEY', 'CLOWN', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 19.80000000000001
    linear: (<__main__.NominalizerTerminal object at 0x10fc36a90>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 109.89999999999858
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 35.40000000000019
VocabularyItem:
    pronunciation: FOOT
    label: FOOT
    values: set()
    diacritic: FOOT_1
    triggers: set()
    weight: 9.600000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2', 'a_2'}
    diacritic: null_24
    triggers: set()
    weight: 11.5
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 22.50000000000002
line done
line done

---------------------

input line #333
input roots: [<__main__.Root object at 0x10fc47fd0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 110.49999999999858..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 34.80000000000021..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 52.10000000000029..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 110.59999999999857..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 52.200000000000294..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 47.30000000000029..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 110.69999999999857..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 110.79999999999856..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 36.00000000000019..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 52.300000000000296..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1', 'e_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: BALL in its selectional

now working with the word 'BALL-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'null_27', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'null_27', 'BALL_1', 'a_1'}
     what if we combine triggers with the otherwise identical vi BALL_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'null_16', 'BALL_1', 'null_27', 'BALL_2'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4bcc0>, '-', <__main__.AgrTerminal object at 0x10fc2df28>, '#', <__main__.Root object at 0x10fc4b588>, '-', <__main__.NominalizerTerminal object at 0x10fc4b7f0>, '-', <__main__.SemanticTerminal object at 0x10fc4b8d0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BALL terminal with values set()
we picked BALL_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'a_2'}
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: la#BALL-a
full_pronunciation: la#BALLa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: BALL to the selectional of the nominalizer whose values are {'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'a_2'}
    selectional: {'FROG', 'CHILD', 'BALL', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 53.30000000000051
    linear: (<__main__.NominalizerTerminal object at 0x10fc05f28>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'FROG', 'BALL', 'CHILD', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_6, triggers = set(), weight = 10.600000000000001..already existed

create_vi: tried nominalizer: null_7, triggers = {('i', frozenset({'-atomic'}))}, weight = 11.199999999999996..already existed

create_vi: tried nominalizer: null_26, triggers = {('e', frozenset({'-atomic'}))}, weight = 12.299999999999995..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_14, triggers = set(), weight = 13.8..already existed

create_vi: tried nominalizer: null_15, triggers = {('i', frozenset({'-atomic'}))}, weight = 11.499999999999995..already existed
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 110.79999999999856
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 52.300000000000296
VocabularyItem:
    pronunciation: BALL
    label: BALL
    values: set()
    diacritic: BALL_1
    triggers: set()
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.899999999999892
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 28.400000000000034
line done
line done

---------------------

input line #334
input roots: [<__main__.Root object at 0x10fc4b3c8>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 111.39999999999856..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 34.90000000000021..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 52.9000000000003..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 111.49999999999855..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 53.0000000000003..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 47.40000000000029..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 111.59999999999854..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 111.69999999999854..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 36.10000000000019..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 53.1000000000003..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: FROG in its selectional

now working with the word 'FROG-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi FROG_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_2', 'a_1', 'FROG_1', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc58898>, '-', <__main__.AgrTerminal object at 0x10fc4b1d0>, '#', <__main__.Root object at 0x10fc58048>, '-', <__main__.NominalizerTerminal object at 0x10fc58f28>, '-', <__main__.SemanticTerminal object at 0x10fc58c18>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FROG terminal with values set()
we picked FROG_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2', 'a'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#FROG-a
full_pronunciation: la#FROGa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: FROG to the selectional of the nominalizer whose values are {'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'a_2'}
    selectional: {'FROG', 'CHILD', 'BALL', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 53.90000000000052
    linear: (<__main__.NominalizerTerminal object at 0x10fc05f28>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'FROG', 'BALL', 'CHILD', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_16, triggers = set(), weight = 11.6..already existed

create_vi: tried nominalizer: null_32, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.299999999999999..already existed

create_vi: tried nominalizer: null_17, triggers = {('e', frozenset({'-atomic'}))}, weight = 10.499999999999998..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_24, triggers = set(), weight = 12.1..already existed

create_vi: tried nominalizer: null_28, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.899999999999999..already existed
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 111.69999999999854
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 53.1000000000003
VocabularyItem:
    pronunciation: FROG
    label: FROG
    values: set()
    diacritic: FROG_2
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 10.9
     what if we combine triggers with the otherwise identical vi FROG_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 11.300000000000008
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 29.000000000000036
line done
line done

---------------------

input line #335
input roots: [<__main__.Root object at 0x10fc58cf8>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 50.30000000000032..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 112.29999999999853..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 47.50000000000029..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 47.60000000000029..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CASTLE in its selectional

now working with the word 'CASTLE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CASTLE_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CASTLE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'CASTLE_2', 'o_1', 'CASTLE_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc36c88>, '-', <__main__.AgrTerminal object at 0x10fc58fd0>, '#', <__main__.Root object at 0x10fc6f940>, '-', <__main__.NominalizerTerminal object at 0x10fc6f3c8>, '-', <__main__.SemanticTerminal object at 0x10fc6f438>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CASTLE terminal with values set()
we picked CASTLE_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'i_2', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: uno#CASTLE-o
full_pronunciation: una#CASTLEo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 47.60000000000029
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 53.6000000000003
VocabularyItem:
    pronunciation: CASTLE
    label: CASTLE
    values: set()
    diacritic: CASTLE_2
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 11.3
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.399999999999892
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 23.900000000000013
line done
line done

---------------------

input line #336
input roots: [<__main__.Root object at 0x10fc58e80>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 112.39999999999853..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 53.6000000000003..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 36.200000000000195..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 112.49999999999852..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 50.40000000000032..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 36.300000000000196..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 112.59999999999852..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: CLOWN in its selectional

now working with the word 'CLOWN-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'CLOWN_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi CLOWN_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CLOWN_2', 'null_15', 'i_1', 'null_14', 'CLOWN_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc58d30>, '#', <__main__.Root object at 0x10fc58860>, '-', <__main__.NominalizerTerminal object at 0x10fc582b0>, '-', <__main__.SemanticTerminal object at 0x10fc58198>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out CLOWN terminal with values set()
we picked CLOWN_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o_2'}
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: li#CLOWN-i
full_pronunciation: l#CLOWNi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 112.59999999999852
VocabularyItem:
    pronunciation: CLOWN
    label: CLOWN
    values: set()
    diacritic: CLOWN_1
    triggers: set()
    weight: 10.3
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.29999999999989
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 23.100000000000023
line done
line done

---------------------

input line #337
input roots: [<__main__.Root object at 0x10fc58438>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 50.50000000000032..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 112.59999999999852..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 47.60000000000029..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 47.700000000000294..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CLOWN in its selectional

now working with the word 'CLOWN-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CLOWN_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CLOWN_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'CLOWN_3', 'o_1', 'CLOWN_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc582e8>, '#', <__main__.Root object at 0x10fc4b860>, '-', <__main__.NominalizerTerminal object at 0x10fc4b208>, '-', <__main__.SemanticTerminal object at 0x10fc4b780>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite', 'i_2', '+atomic'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out CLOWN terminal with values set()
we picked CLOWN_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i_2'}
we picked null_15: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: uno#CLOWN-o
full_pronunciation: un#CLOWNo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 47.700000000000294
VocabularyItem:
    pronunciation: CLOWN
    label: CLOWN
    values: set()
    diacritic: CLOWN_1
    triggers: set()
    weight: 10.200000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_15
    triggers: {('i', frozenset({'-atomic'}))}
    weight: 11.499999999999995
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 23.900000000000013
line done
line done

---------------------

input line #338
input roots: [<__main__.Root object at 0x10fc4b4e0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 112.69999999999851..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 53.7000000000003..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 35.00000000000021..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 112.7999999999985..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 50.60000000000032..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 35.100000000000215..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 112.8999999999985..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: TOWER in its selectional

now working with the word 'TOWER-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_6', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_6', 'null_7', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'TOWER_1', 'null_6', 'null_7', 'i_1'}
     what if we combine triggers with the otherwise identical vi TOWER_3 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'TOWER_1', 'null_7', 'i_1', 'TOWER_2', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc470f0>, '-', <__main__.AgrTerminal object at 0x10fc4b320>, '#', <__main__.Root object at 0x10fc47240>, '-', <__main__.NominalizerTerminal object at 0x10fc47da0>, '-', <__main__.SemanticTerminal object at 0x10fc47c18>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic', 'o_2'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out TOWER terminal with values set()
we picked TOWER_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'o_2'}
we picked null_6 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: le#TOWER-i
full_pronunciation: le#TOWERi
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: TOWER to the selectional of the nominalizer whose values are {'e_1', 'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1', 'o_2'}
    selectional: {'BOOK', 'CHILD', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'CLOWN', 'OFFSPRING'}
    selection_strength: True
    weight: 18.1
    linear: (<__main__.NominalizerTerminal object at 0x10fc3d400>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 112.8999999999985
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 35.100000000000215
VocabularyItem:
    pronunciation: TOWER
    label: TOWER
    values: set()
    diacritic: TOWER_3
    triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))}
    weight: 10.700000000000001
     what if we combine triggers with the otherwise identical vi TOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_6
    triggers: set()
    weight: 10.600000000000001
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 23.100000000000023
line done
line done

---------------------

input line #339
input roots: [<__main__.Root object at 0x10fc4b898>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 113.4999999999985..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 35.700000000000216..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 53.8000000000003..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 113.59999999999849..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 53.900000000000304..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 47.700000000000294..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 113.69999999999848..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 113.79999999999848..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 36.4000000000002..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 54.000000000000306..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: CAR in its selectional

now working with the word 'CAR-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'CAR_1'}
     what if we combine triggers with the otherwise identical vi CAR_2 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'null_10', 'CAR_1', 'null_11', 'CAR_3'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc35a90>, '-', <__main__.AgrTerminal object at 0x10fc4b128>, '#', <__main__.Root object at 0x10fc22be0>, '-', <__main__.NominalizerTerminal object at 0x10fc280b8>, '-', <__main__.SemanticTerminal object at 0x10fc38908>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CAR terminal with values set()
we picked CAR_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2', 'a'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#CAR-a
full_pronunciation: lo#CARa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 113.79999999999848
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 50.60000000000032
VocabularyItem:
    pronunciation: CAR
    label: CAR
    values: set()
    diacritic: CAR_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.4
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 11.200000000000008
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 29.600000000000037
line done
line done

---------------------

input line #340
input roots: [<__main__.Root object at 0x10fc38390>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 50.60000000000032..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 113.79999999999848..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 47.800000000000296..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 47.9000000000003..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CASTLE in its selectional

now working with the word 'CASTLE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CASTLE_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CASTLE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'CASTLE_2', 'o_1', 'CASTLE_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc861d0>, '-', <__main__.AgrTerminal object at 0x10fc355c0>, '#', <__main__.Root object at 0x10fc86438>, '-', <__main__.NominalizerTerminal object at 0x10fc86048>, '-', <__main__.SemanticTerminal object at 0x10fc86358>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CASTLE terminal with values set()
we picked CASTLE_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: uno#CASTLE-o
full_pronunciation: uno#CASTLEa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 47.9000000000003
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 50.60000000000032
VocabularyItem:
    pronunciation: CASTLE
    label: CASTLE
    values: set()
    diacritic: CASTLE_3
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.200000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.19999999999989
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 29.500000000000036
line done
line done

---------------------

input line #341
input roots: [<__main__.Root object at 0x10fc865f8>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 54.10000000000031..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 113.89999999999847..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 47.9000000000003..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 48.0000000000003..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: TOWER in its selectional

now working with the word 'TOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'TOWER_1', 'e_3', 'null_10'}
     what if we combine triggers with the otherwise identical vi TOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'TOWER_1', 'TOWER_3', 'e_3', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc3e2b0>, '-', <__main__.AgrTerminal object at 0x10fc86e10>, '#', <__main__.Root object at 0x10fc67908>, '-', <__main__.NominalizerTerminal object at 0x10fc67e80>, '-', <__main__.SemanticTerminal object at 0x10fc67b00>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out TOWER terminal with values set()
we picked TOWER_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: una#TOWER-e
full_pronunciation: una#TOWERe
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: TOWER to the selectional of the nominalizer whose values are {'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'a_2'}
    selectional: {'FROG', 'CHILD', 'BALL', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 54.90000000000053
    linear: (<__main__.NominalizerTerminal object at 0x10fc05f28>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'FROG', 'BALL', 'CHILD', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_6, triggers = set(), weight = 11.200000000000001..already existed

create_vi: tried nominalizer: null_7, triggers = {('i', frozenset({'-atomic'}))}, weight = 11.299999999999995..already existed

create_vi: tried nominalizer: null_26, triggers = {('e', frozenset({'-atomic'}))}, weight = 12.399999999999995..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_14, triggers = set(), weight = 13.9..already existed

create_vi: tried nominalizer: null_15, triggers = {('i', frozenset({'-atomic'}))}, weight = 11.499999999999995..already existed
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 48.0000000000003
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 54.10000000000031
VocabularyItem:
    pronunciation: TOWER
    label: TOWER
    values: set()
    diacritic: TOWER_4
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'})), ('e', frozenset({'+atomic'}))}
    weight: 10.4
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.099999999999888
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 15.5
line done
line done

---------------------

input line #342
input roots: [<__main__.Root object at 0x10fc862e8>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 113.99999999999847..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 35.80000000000022..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 50.60000000000032..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 114.09999999999846..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 50.70000000000032..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 48.6000000000003..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 114.19999999999845..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 114.29999999999845..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 36.5000000000002..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 50.800000000000324..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CHILD_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'CHILD_1', 'null_9', 'o_1', 'CHILD_3'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6f080>, '-', <__main__.AgrTerminal object at 0x10fc3e080>, '#', <__main__.Root object at 0x10fc6f438>, '-', <__main__.NominalizerTerminal object at 0x10fc6f3c8>, '-', <__main__.SemanticTerminal object at 0x10fc6f6a0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: lo#CHILD-o
full_pronunciation: la#CHILDo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 114.29999999999845
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 54.60000000000031
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_3
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 10.500000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.599999999999888
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 24.000000000000014
line done
line done

---------------------

input line #343
input roots: [<__main__.Root object at 0x10fc672e8>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 114.29999999999845..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 35.90000000000022..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 50.900000000000325..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 114.39999999999844..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 51.00000000000033..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 48.7000000000003..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 114.49999999999844..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 114.59999999999843..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 36.6000000000002..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 51.10000000000033..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FOOT in its selectional

now working with the word 'FOOT-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FOOT_1', 'null_8', 'e_3', 'null_19'}
     what if we combine triggers with the otherwise identical vi FOOT_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FOOT_1', 'e_3', 'FOOT_2', 'null_19'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67668>, '-', <__main__.AgrTerminal object at 0x10fc67cc0>, '#', <__main__.Root object at 0x10fc67358>, '-', <__main__.NominalizerTerminal object at 0x10fc67080>, '-', <__main__.SemanticTerminal object at 0x10fc67e48>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FOOT terminal with values set()
we picked FOOT_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: lo#FOOT-e
full_pronunciation: la#FOOTe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 114.59999999999843
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 54.500000000000306
VocabularyItem:
    pronunciation: FOOT
    label: FOOT
    values: set()
    diacritic: FOOT_3
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.000000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.499999999999886
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 16.1
line done
line done

---------------------

input line #344
input roots: [<__main__.Root object at 0x10fc67470>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 114.59999999999843..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 36.00000000000022..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 54.500000000000306..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 114.69999999999843..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 54.60000000000031..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 48.8000000000003..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 114.79999999999842..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 114.89999999999841..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 36.7000000000002..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 54.70000000000031..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_2', 'a_1', 'PIBLING_1', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc86208>, '-', <__main__.AgrTerminal object at 0x10fc67e10>, '#', <__main__.Root object at 0x10fc86f98>, '-', <__main__.NominalizerTerminal object at 0x10fc86f60>, '-', <__main__.SemanticTerminal object at 0x10fc86be0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_7: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: la#PIBLING-a
full_pronunciation: lo#PIBLINGa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 114.89999999999841
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 51.10000000000033
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_7
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.399999999999885
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 29.500000000000036
line done
line done

---------------------

input line #345
input roots: [<__main__.Root object at 0x10fc86588>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 114.89999999999841..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 36.10000000000022..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 51.10000000000033..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 114.99999999999841..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 51.20000000000033..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 48.900000000000304..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 115.0999999999984..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 115.1999999999984..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 36.8000000000002..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 51.30000000000033..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CHILD_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'CHILD_1', 'null_9', 'o_1', 'CHILD_3'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc207b8>, '-', <__main__.AgrTerminal object at 0x10fc86278>, '#', <__main__.Root object at 0x10fc22be0>, '-', <__main__.NominalizerTerminal object at 0x10fc228d0>, '-', <__main__.SemanticTerminal object at 0x10fc22940>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: lo#CHILD-o
full_pronunciation: lo#CHILDa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 115.1999999999984
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 51.30000000000033
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_2
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 11.000000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.299999999999883
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 29.400000000000034
line done
line done

---------------------

input line #346
input roots: [<__main__.Root object at 0x10fc3bf98>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 115.1999999999984..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 54.80000000000031..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 36.900000000000205..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 115.29999999999839..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 51.30000000000033..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 37.000000000000206..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 115.39999999999839..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'PIBLING_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi PIBLING_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_5 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_7', 'null_15', 'PIBLING_1', 'i_1', 'null_14'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc18320>, '-', <__main__.AgrTerminal object at 0x10fc20b38>, '#', <__main__.Root object at 0x10fc47780>, '-', <__main__.NominalizerTerminal object at 0x10fc47320>, '-', <__main__.SemanticTerminal object at 0x10fc18588>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic', 'a_2'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_7: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i', 'e_1', 'a_2'}
we picked null_6 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#PIBLING-i
full_pronunciation: le#PIBLINGi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 115.39999999999839
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 36.10000000000022
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_7
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.600000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_6
    triggers: set()
    weight: 11.200000000000001
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 23.700000000000024
line done
line done

---------------------

input line #347
input roots: [<__main__.Root object at 0x10fc2d9e8>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 115.39999999999839..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 36.10000000000022..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 51.40000000000033..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 115.49999999999838..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 51.500000000000334..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 49.000000000000306..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 115.59999999999837..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 115.69999999999837..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 37.10000000000021..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 51.600000000000335..already existed
  we're in a functional word...
  - nominalizer's values are now {'i_2', 'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_18', 'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_18', 'o_1', 'null_12'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'OFFSPRING_3', 'o_1', 'null_18', 'OFFSPRING_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b358>, '-', <__main__.AgrTerminal object at 0x10fc35be0>, '#', <__main__.Root object at 0x10fc4b908>, '-', <__main__.NominalizerTerminal object at 0x10fc4bcf8>, '-', <__main__.SemanticTerminal object at 0x10fc4bf28>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o_2'}
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: lo#OFFSPRING-o
full_pronunciation: lo#OFFSPRINGe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 115.69999999999837
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 51.600000000000335
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_1
    triggers: set()
    weight: 11.100000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.199999999999882
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 16.0
line done
line done

---------------------

input line #348
input roots: [<__main__.Root object at 0x10fc4bac8>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 115.69999999999837..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 54.90000000000031..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 37.20000000000021..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 115.79999999999836..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 51.600000000000335..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 37.30000000000021..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 115.89999999999836..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: CLOWN in its selectional

now working with the word 'CLOWN-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CLOWN_1', 'null_12', 'null_13', 'i_1'}
     what if we combine triggers with the otherwise identical vi CLOWN_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CLOWN_2', 'null_12', 'null_13', 'i_1', 'CLOWN_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6f9e8>, '-', <__main__.AgrTerminal object at 0x10fc4ba90>, '#', <__main__.Root object at 0x10fc6f550>, '-', <__main__.NominalizerTerminal object at 0x10fc6f518>, '-', <__main__.SemanticTerminal object at 0x10fc6fa90>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'o_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CLOWN terminal with values set()
we picked CLOWN_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i_2', 'o_2'}
we picked null_18: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: li#CLOWN-i
full_pronunciation: li#CLOWNi
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CLOWN to the selectional of the nominalizer whose values are {'i_2', 'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'o_2'}
    selectional: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'GRANDPARENT', 'CASTLE', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 23.000000000000036
    linear: (<__main__.NominalizerTerminal object at 0x10fc22eb8>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 115.89999999999836
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 37.30000000000021
VocabularyItem:
    pronunciation: CLOWN
    label: CLOWN
    values: set()
    diacritic: CLOWN_1
    triggers: set()
    weight: 10.100000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2', 'o_2'}
    diacritic: null_18
    triggers: {('o', frozenset({'+atomic'}))}
    weight: 10.299999999999999
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 23.700000000000024
line done
line done

---------------------

input line #349
input roots: [<__main__.Root object at 0x10fc4b208>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 55.00000000000031..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 116.49999999999835..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 49.10000000000031..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 49.20000000000031..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: TOWER in its selectional

now working with the word 'TOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'TOWER_1', 'e_3', 'null_10'}
     what if we combine triggers with the otherwise identical vi TOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'TOWER_1', 'TOWER_3', 'e_3', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc58470>, '-', <__main__.AgrTerminal object at 0x10fc6f780>, '#', <__main__.Root object at 0x10fc36320>, '-', <__main__.NominalizerTerminal object at 0x10fc58a58>, '-', <__main__.SemanticTerminal object at 0x10fc583c8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out TOWER terminal with values set()
we picked TOWER_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: una#TOWER-e
full_pronunciation: uno#TOWERe
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 49.20000000000031
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 51.600000000000335
VocabularyItem:
    pronunciation: TOWER
    label: TOWER
    values: set()
    diacritic: TOWER_4
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'})), ('e', frozenset({'+atomic'}))}
    weight: 10.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.09999999999988
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 16.0
line done
line done

---------------------

input line #350
input roots: [<__main__.Root object at 0x10fc58400>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 116.59999999999835..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 55.100000000000314..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 36.20000000000022..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 116.69999999999834..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 51.600000000000335..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 36.300000000000225..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 116.79999999999833..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: FROG in its selectional

now working with the word 'FROG-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'null_17'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_1', 'e_2', 'null_16', 'null_17'}
     what if we combine triggers with the otherwise identical vi FROG_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'FROG_1', 'FROG_3', 'null_17'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc58860>, '-', <__main__.AgrTerminal object at 0x10fc364e0>, '#', <__main__.Root object at 0x10fc58358>, '-', <__main__.NominalizerTerminal object at 0x10fc58470>, '-', <__main__.SemanticTerminal object at 0x10fc58a58>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'o_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FROG terminal with values set()
we picked FROG_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'i_2', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: le#FROG-e
full_pronunciation: li#FROGe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 116.79999999999833
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 37.80000000000021
VocabularyItem:
    pronunciation: FROG
    label: FROG
    values: set()
    diacritic: FROG_3
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 9.600000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.99999999999988
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 14.299999999999999
line done
line done

---------------------

input line #351
input roots: [<__main__.Root object at 0x10fc3db38>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 116.79999999999833..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 55.200000000000315..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 37.80000000000021..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 116.89999999999833..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 51.70000000000034..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 37.90000000000021..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 116.99999999999832..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: BOOK in its selectional

now working with the word 'BOOK-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'BOOK_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi BOOK_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_15', 'BOOK_2', 'BOOK_1', 'i_1', 'null_14'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc58f28>, '#', <__main__.Root object at 0x10fc05470>, '-', <__main__.NominalizerTerminal object at 0x10fc6f1d0>, '-', <__main__.SemanticTerminal object at 0x10fc6fd30>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out BOOK terminal with values set()
we picked BOOK_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o_2'}
we picked null_8: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: li#BOOK-i
full_pronunciation: l#BOOKe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 116.99999999999832
VocabularyItem:
    pronunciation: BOOK
    label: BOOK
    values: set()
    diacritic: BOOK_1
    triggers: set()
    weight: 10.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 11.100000000000009
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 14.2
line done
line done

---------------------

input line #352
input roots: [<__main__.Root object at 0x10fc6f978>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 116.99999999999832..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 36.400000000000226..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 51.80000000000034..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 117.09999999999832..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 51.90000000000034..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 49.20000000000031..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 117.19999999999831..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 117.2999999999983..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 38.00000000000021..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 52.00000000000034..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FOOT in its selectional

now working with the word 'FOOT-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FOOT_1', 'null_8', 'e_3', 'null_19'}
     what if we combine triggers with the otherwise identical vi FOOT_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FOOT_1', 'e_3', 'FOOT_2', 'null_19'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b400>, '-', <__main__.AgrTerminal object at 0x10fc3d828>, '#', <__main__.Root object at 0x10fc4b390>, '-', <__main__.NominalizerTerminal object at 0x10fc4b9e8>, '-', <__main__.SemanticTerminal object at 0x10fc4b668>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'i_2', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FOOT terminal with values set()
we picked FOOT_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'i_2', 'o_2'}
we picked null_12 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: lo#FOOT-e
full_pronunciation: lo#FOOTe
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: FOOT to the selectional of the nominalizer whose values are {'i_2', 'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'o_2'}
    selectional: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'GRANDPARENT', 'CASTLE', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 23.20000000000004
    linear: (<__main__.NominalizerTerminal object at 0x10fc22eb8>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 117.2999999999983
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 52.00000000000034
VocabularyItem:
    pronunciation: FOOT
    label: FOOT
    values: set()
    diacritic: FOOT_2
    triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))}
    weight: 10.3
     what if we combine triggers with the otherwise identical vi FOOT_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2', 'o_2'}
    diacritic: null_12
    triggers: set()
    weight: 10.999999999999998
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 16.0
line done
line done

---------------------

input line #353
input roots: [<__main__.Root object at 0x10fc4bd68>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 117.8999999999983..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 36.50000000000023..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 52.60000000000034..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 117.9999999999983..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 52.700000000000344..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 49.30000000000031..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 118.09999999999829..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 118.19999999999828..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 38.100000000000215..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 52.800000000000345..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CHILD_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'CHILD_1', 'null_9', 'o_1', 'CHILD_3'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc47fd0>, '-', <__main__.AgrTerminal object at 0x10fc4bac8>, '#', <__main__.Root object at 0x10fc18240>, '-', <__main__.NominalizerTerminal object at 0x10fc18320>, '-', <__main__.SemanticTerminal object at 0x10fc18828>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_9: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: lo#CHILD-o
full_pronunciation: la#CHILDo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 118.19999999999828
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 55.200000000000315
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_9
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.899999999999878
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 24.200000000000017
line done
line done

---------------------

input line #354
input roots: [<__main__.Root object at 0x10fc4bef0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 55.200000000000315..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 118.19999999999828..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 49.40000000000031..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 49.50000000000031..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: BALL in its selectional

now working with the word 'BALL-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'BALL_1', 'a_1'}
     what if we combine triggers with the otherwise identical vi BALL_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'BALL_1', 'BALL_2', 'null_10', 'null_11'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc228d0>, '-', <__main__.AgrTerminal object at 0x10fc355c0>, '#', <__main__.Root object at 0x10fc3bf98>, '-', <__main__.NominalizerTerminal object at 0x10fc2f048>, '-', <__main__.SemanticTerminal object at 0x10fc20b38>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BALL terminal with values set()
we picked BALL_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: una#BALL-a
full_pronunciation: uno#BALLo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 49.50000000000031
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 52.800000000000345
VocabularyItem:
    pronunciation: BALL
    label: BALL
    values: set()
    diacritic: BALL_3
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 10.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 11.000000000000009
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 24.100000000000016
line done
line done

---------------------

input line #355
input roots: [<__main__.Root object at 0x10fc280b8>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 52.800000000000345..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 118.29999999999828..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 49.50000000000031..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 49.600000000000314..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'PIBLING_1', 'o_1', 'PIBLING_5'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc860f0>, '-', <__main__.AgrTerminal object at 0x10fc22f60>, '#', <__main__.Root object at 0x10fc864e0>, '-', <__main__.NominalizerTerminal object at 0x10fc86400>, '-', <__main__.SemanticTerminal object at 0x10fc86ef0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1', 'o_2'}
we picked null_31: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: uno#PIBLING-o
full_pronunciation: uno#PIBLINGa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 49.600000000000314
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 52.800000000000345
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_1
    triggers: set()
    weight: 11.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1', 'o_2'}
    diacritic: null_31
    triggers: {('e', frozenset({'-atomic'}))}
    weight: 10.399999999999999
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 29.400000000000034
line done
line done

---------------------

input line #356
input roots: [<__main__.Root object at 0x10fc86c18>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 118.39999999999827..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 36.60000000000023..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 55.30000000000032..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 118.49999999999827..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 55.40000000000032..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 49.600000000000314..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 118.59999999999826..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 118.69999999999825..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 38.200000000000216..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 55.50000000000032..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: TOWER in its selectional

now working with the word 'TOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'TOWER_1', 'e_3', 'null_10'}
     what if we combine triggers with the otherwise identical vi TOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'TOWER_1', 'TOWER_3', 'e_3', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67240>, '-', <__main__.AgrTerminal object at 0x10fc86d68>, '#', <__main__.Root object at 0x10fc67fd0>, '-', <__main__.NominalizerTerminal object at 0x10fc67d68>, '-', <__main__.SemanticTerminal object at 0x10fc670b8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'i_2', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out TOWER terminal with values set()
we picked TOWER_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'o_2'}
we picked null_14 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: la#TOWER-e
full_pronunciation: lo#TOWERe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 118.69999999999825
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 52.700000000000344
VocabularyItem:
    pronunciation: TOWER
    label: TOWER
    values: set()
    diacritic: TOWER_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 13.9
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 16.6
line done
line done

---------------------

input line #357
input roots: [<__main__.Root object at 0x10fc10dd8>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 118.69999999999825..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 55.60000000000032..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 36.70000000000023..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 118.79999999999825..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 52.700000000000344..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 36.80000000000023..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 118.89999999999824..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'null_17'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'e_2', 'null_16', 'null_17'}
     what if we combine triggers with the otherwise identical vi PIBLING_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_5 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'PIBLING_1', 'null_17', 'PIBLING_3'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67cc0>, '#', <__main__.Root object at 0x10fc45358>, '-', <__main__.NominalizerTerminal object at 0x10fc45e80>, '-', <__main__.SemanticTerminal object at 0x10fc45518>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out PIBLING terminal with values set()
we picked PIBLING_8: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: le#PIBLING-e
full_pronunciation: l#PIBLINGi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 118.89999999999824
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_8
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.799999999999876
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 24.300000000000026
line done
line done

---------------------

input line #358
input roots: [<__main__.Root object at 0x10fc86208>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 118.89999999999824..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 55.70000000000032..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 38.30000000000022..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 118.99999999999824..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 52.800000000000345..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 38.40000000000022..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 119.09999999999823..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: FLOWER in its selectional

now working with the word 'FLOWER-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'FLOWER_1', 'i_1'}
     what if we combine triggers with the otherwise identical vi FLOWER_3 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'FLOWER_2', 'null_13', 'i_1', 'FLOWER_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67da0>, '-', <__main__.AgrTerminal object at 0x10fc45e80>, '#', <__main__.Root object at 0x10fc86e48>, '-', <__main__.NominalizerTerminal object at 0x10fc86b38>, '-', <__main__.SemanticTerminal object at 0x10fc67ef0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'o_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FLOWER terminal with values set()
we picked FLOWER_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'i_2', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#FLOWER-i
full_pronunciation: li#FLOWERi
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: FLOWER to the selectional of the nominalizer whose values are {'i_2', 'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'o_2'}
    selectional: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'GRANDPARENT', 'CASTLE', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 23.500000000000043
    linear: (<__main__.NominalizerTerminal object at 0x10fc22eb8>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 119.09999999999823
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 38.40000000000022
VocabularyItem:
    pronunciation: FLOWER
    label: FLOWER
    values: set()
    diacritic: FLOWER_4
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'})), ('e', frozenset({'+atomic'}))}
    weight: 10.3
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 10.90000000000001
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 24.300000000000026
line done
line done

---------------------

input line #359
input roots: [<__main__.Root object at 0x10fc67d68>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 55.800000000000324..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 119.69999999999823..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 49.700000000000315..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 49.80000000000032..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'GRANDPARENT_1'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'GRANDPARENT_1', 'null_11', 'null_10', 'GRANDPARENT_3'}
done processing input, time to test
we selected the nominalizer with values: {'e_1'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc86e10>, '#', <__main__.Root object at 0x10fc860f0>, '-', <__main__.NominalizerTerminal object at 0x10fc86ef0>, '-', <__main__.SemanticTerminal object at 0x10fc864e0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'e_1', '-definite', '+atomic'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1', 'null'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: una#GRANDPARENT-a
full_pronunciation: un#GRANDPARENTe
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 49.80000000000032
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_4
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.100000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.699999999999875
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 16.5
line done
line done

---------------------

input line #360
input roots: [<__main__.Root object at 0x10fc86400>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 119.79999999999822..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 36.90000000000023..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 52.90000000000035..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 119.89999999999822..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 53.00000000000035..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 49.80000000000032..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 119.99999999999821..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 120.0999999999982..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 39.00000000000022..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 53.10000000000035..already existed
  we're in a functional word...
  - nominalizer's values are now {'e_1', 'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'o_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_20'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_20', 'null_21'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_20', 'null_21', 'CHILD_1'}
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_20', 'CHILD_1', 'o_1', 'null_21', 'CHILD_3'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc22940>, '-', <__main__.AgrTerminal object at 0x10fc86c18>, '#', <__main__.Root object at 0x10fc280b8>, '-', <__main__.NominalizerTerminal object at 0x10fc38390>, '-', <__main__.SemanticTerminal object at 0x10fc22a90>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_9: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: lo#CHILD-o
full_pronunciation: la#CHILDo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 120.0999999999982
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 55.800000000000324
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_9
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.599999999999874
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 24.200000000000017
line done
line done

---------------------

input line #361
input roots: [<__main__.Root object at 0x10fc226d8>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 53.20000000000035..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 120.0999999999982..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 49.90000000000032..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 50.00000000000032..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CHILD_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'CHILD_1', 'null_9', 'o_1', 'CHILD_3'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc1b9b0>, '-', <__main__.AgrTerminal object at 0x10fc2d9e8>, '#', <__main__.Root object at 0x10fc47ef0>, '-', <__main__.NominalizerTerminal object at 0x10fc47780>, '-', <__main__.SemanticTerminal object at 0x10fc47588>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'a_2'}
we picked null_10: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: uno#CHILD-o
full_pronunciation: una#CHILDe
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 50.00000000000032
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 55.70000000000032
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_1
    triggers: set()
    weight: 9.500000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 11.800000000000008
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 16.4
line done
line done

---------------------

input line #362
input roots: [<__main__.Root object at 0x10fc3e898>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 120.1999999999982..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 55.70000000000032..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 37.000000000000234..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 120.29999999999819..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 53.30000000000035..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 37.100000000000236..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 120.39999999999819..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: CAR in its selectional

now working with the word 'CAR-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'null_17'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'CAR_1', 'null_17'}
     what if we combine triggers with the otherwise identical vi CAR_3 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'CAR_2', 'null_16', 'null_17', 'CAR_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4bd68>, '-', <__main__.AgrTerminal object at 0x10fc182b0>, '#', <__main__.Root object at 0x10fc4b160>, '-', <__main__.NominalizerTerminal object at 0x10fc4b400>, '-', <__main__.SemanticTerminal object at 0x10fc4b9e8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'a_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CAR terminal with values set()
we picked CAR_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i_2', 'a_2'}
we picked null_14: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: le#CAR-e
full_pronunciation: li#CARi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 120.39999999999819
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 39.00000000000022
VocabularyItem:
    pronunciation: CAR
    label: CAR
    values: set()
    diacritic: CAR_1
    triggers: set()
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 13.8
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 24.800000000000026
line done
line done

---------------------

input line #363
input roots: [<__main__.Root object at 0x10fc4b3c8>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 120.39999999999819..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 37.20000000000024..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 53.400000000000354..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 120.49999999999818..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 53.500000000000355..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 50.00000000000032..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 120.59999999999818..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 120.69999999999817..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 39.00000000000022..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 53.60000000000036..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: MOUSE in its selectional

now working with the word 'MOUSE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'MOUSE_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi MOUSE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'MOUSE_2', 'MOUSE_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6f518>, '-', <__main__.AgrTerminal object at 0x10fc4bf60>, '#', <__main__.Root object at 0x10fc6f080>, '-', <__main__.NominalizerTerminal object at 0x10fc6fcf8>, '-', <__main__.SemanticTerminal object at 0x10fc6fa90>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MOUSE terminal with values set()
we picked MOUSE_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: lo#MOUSE-o
full_pronunciation: la#MOUSEo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 120.69999999999817
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 55.70000000000032
VocabularyItem:
    pronunciation: MOUSE
    label: MOUSE
    values: set()
    diacritic: MOUSE_3
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.3
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 11.700000000000008
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 24.30000000000002
line done
line done

---------------------

input line #364
input roots: [<__main__.Root object at 0x10fbff828>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 120.69999999999817..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 55.70000000000032..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 37.30000000000024..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 120.79999999999816..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 53.70000000000036..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 37.40000000000024..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 120.89999999999816..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: CAR in its selectional

now working with the word 'CAR-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'CAR_1', 'null_6'}
     what if we combine triggers with the otherwise identical vi CAR_3 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'CAR_2', 'null_26', 'CAR_1', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc58ac8>, '-', <__main__.AgrTerminal object at 0x10fc4b390>, '#', <__main__.Root object at 0x10fc36080>, '-', <__main__.NominalizerTerminal object at 0x10fc36240>, '-', <__main__.SemanticTerminal object at 0x10fc36780>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic', 'a_2'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CAR terminal with values set()
we picked CAR_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e', 'e_1', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: le#CAR-e
full_pronunciation: le#CARe
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CAR to the selectional of the nominalizer whose values are {'e_1', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1', 'a_2'}
    selectional: {'FROG', 'BALL', 'CHILD', 'TOWER', 'PIBLING', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 24.700000000000042
    linear: (<__main__.NominalizerTerminal object at 0x10fc2aa20>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 120.89999999999816
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 37.40000000000024
VocabularyItem:
    pronunciation: CAR
    label: CAR
    values: set()
    diacritic: CAR_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.3
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.499999999999872
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 14.399999999999999
line done
line done

---------------------

input line #365
input roots: [<__main__.Root object at 0x10fc36390>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 53.80000000000036..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 121.49999999999815..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 50.10000000000032..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 50.20000000000032..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CLOWN in its selectional

now working with the word 'CLOWN-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CLOWN_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CLOWN_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'CLOWN_3', 'o_1', 'CLOWN_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6f6a0>, '-', <__main__.AgrTerminal object at 0x10fc3d550>, '#', <__main__.Root object at 0x10fc6fcf8>, '-', <__main__.NominalizerTerminal object at 0x10fc6f080>, '-', <__main__.SemanticTerminal object at 0x10fc6f160>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CLOWN terminal with values set()
we picked CLOWN_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: uno#CLOWN-o
full_pronunciation: uno#CLOWNo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CLOWN to the selectional of the nominalizer whose values are {'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'o_2'}
    selectional: {'MOUSE', 'CHILD', 'BOOK', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 59.10000000000059
    linear: (<__main__.NominalizerTerminal object at 0x10fc08908>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_6, triggers = set(), weight = 11.200000000000001..already existed

create_vi: tried nominalizer: null_7, triggers = {('i', frozenset({'-atomic'}))}, weight = 11.399999999999995..already existed

create_vi: tried nominalizer: null_26, triggers = {('e', frozenset({'-atomic'}))}, weight = 12.499999999999995..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_14, triggers = set(), weight = 13.8..already existed

create_vi: tried nominalizer: null_15, triggers = {('i', frozenset({'-atomic'}))}, weight = 11.599999999999994..already existed
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 50.20000000000032
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 53.80000000000036
VocabularyItem:
    pronunciation: CLOWN
    label: CLOWN
    values: set()
    diacritic: CLOWN_3
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 10.3
     what if we combine triggers with the otherwise identical vi CLOWN_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.999999999999872
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 24.30000000000002
line done
line done

---------------------

input line #366
input roots: [<__main__.Root object at 0x10fc58160>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 121.59999999999815..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 38.00000000000024..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 54.40000000000036..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 121.69999999999814..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 54.50000000000036..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 50.800000000000324..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 121.79999999999814..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 121.89999999999813..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 39.10000000000022..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 54.600000000000364..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FLOWER in its selectional

now working with the word 'FLOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19', 'FLOWER_1'}
     what if we combine triggers with the otherwise identical vi FLOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FLOWER_3', 'e_3', 'null_19', 'FLOWER_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6f518>, '#', <__main__.Root object at 0x10fc4b8d0>, '-', <__main__.NominalizerTerminal object at 0x10fc4bda0>, '-', <__main__.SemanticTerminal object at 0x10fc4be10>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '+atomic', 'i_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out FLOWER terminal with values set()
we picked FLOWER_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2'}
we picked null_14 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: lo#FLOWER-e
full_pronunciation: l#FLOWERe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 121.89999999999813
VocabularyItem:
    pronunciation: FLOWER
    label: FLOWER
    values: set()
    diacritic: FLOWER_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 13.8
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 16.4
line done
line done

---------------------

input line #367
input roots: [<__main__.Root object at 0x10fc4b4a8>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 121.89999999999813..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 38.10000000000024..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 55.800000000000324..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 121.99999999999812..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 55.900000000000325..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 50.900000000000325..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 122.09999999999812..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 122.19999999999811..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 39.20000000000022..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 56.00000000000033..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_2', 'a_1', 'PIBLING_1', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc470f0>, '-', <__main__.AgrTerminal object at 0x10fc4b128>, '#', <__main__.Root object at 0x10fc47320>, '-', <__main__.NominalizerTerminal object at 0x10fc47400>, '-', <__main__.SemanticTerminal object at 0x10fc47c18>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2', 'a'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#PIBLING-a
full_pronunciation: lo#PIBLINGa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 122.19999999999811
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 54.600000000000364
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_2
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 10.4
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 11.40000000000001
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 29.500000000000036
line done
line done

---------------------

input line #368
input roots: [<__main__.Root object at 0x10fc4bac8>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 122.19999999999811..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 38.200000000000244..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 56.10000000000033..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 122.29999999999811..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 56.20000000000033..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 51.00000000000033..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 122.3999999999981..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 122.4999999999981..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 39.300000000000225..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 56.30000000000033..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1', 'i_2'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'a_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_24', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_25', 'null_24', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_25', 'null_24', 'a_1', 'CHILD_1'}
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CHILD_1', 'a_1', 'null_25', 'CHILD_2', 'null_24'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc35fd0>, '-', <__main__.AgrTerminal object at 0x10fc47588>, '#', <__main__.Root object at 0x10fc280b8>, '-', <__main__.NominalizerTerminal object at 0x10fc28128>, '-', <__main__.SemanticTerminal object at 0x10fc356d8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_7: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: la#CHILD-a
full_pronunciation: la#CHILDo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 122.4999999999981
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 56.30000000000033
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_7
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.499999999999872
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 24.80000000000002
line done
line done

---------------------

input line #369
input roots: [<__main__.Root object at 0x10fc4b5c0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 54.600000000000364..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 122.4999999999981..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 51.10000000000033..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 51.20000000000033..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: BOOK in its selectional

now working with the word 'BOOK-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'BOOK_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi BOOK_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'BOOK_1', 'BOOK_3'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc86dd8>, '-', <__main__.AgrTerminal object at 0x10fc2d9e8>, '#', <__main__.Root object at 0x10fc86cf8>, '-', <__main__.NominalizerTerminal object at 0x10fc862b0>, '-', <__main__.SemanticTerminal object at 0x10fc861d0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BOOK terminal with values set()
we picked BOOK_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: uno#BOOK-o
full_pronunciation: uno#BOOKa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 51.20000000000033
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 54.600000000000364
VocabularyItem:
    pronunciation: BOOK
    label: BOOK
    values: set()
    diacritic: BOOK_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.39999999999987
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 29.500000000000036
line done
line done

---------------------

input line #370
input roots: [<__main__.Root object at 0x10fc38908>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 122.59999999999809..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 56.30000000000033..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 38.300000000000246..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 122.69999999999808..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 54.600000000000364..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 38.40000000000025..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 122.79999999999808..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: BALL in its selectional

now working with the word 'BALL-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'null_17'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'BALL_1', 'null_17'}
     what if we combine triggers with the otherwise identical vi BALL_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'BALL_1', 'BALL_3', 'null_17'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc866a0>, '#', <__main__.Root object at 0x10fc86240>, '-', <__main__.NominalizerTerminal object at 0x10fc86588>, '-', <__main__.SemanticTerminal object at 0x10fc86e80>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked li_1: no super match (neither decl nor L1-gender)
now spelling out BALL terminal with values set()
we picked BALL_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: le#BALL-e
full_pronunciation: li#BALLe
vis_used:
Failure
VocabularyItem:
    pronunciation: li
    label: definite
    values: {'+definite', '-atomic'}
    diacritic: li_1
    triggers: set()
    weight: 10.900000000000002
VocabularyItem:
    pronunciation: BALL
    label: BALL
    values: set()
    diacritic: BALL_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.29999999999987
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 14.999999999999998
line done
line done

---------------------

input line #371
input roots: [<__main__.Root object at 0x10fc86128>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 56.40000000000033..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 122.89999999999807..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 51.20000000000033..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 51.30000000000033..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'OFFSPRING_1', 'null_11', 'null_10', 'OFFSPRING_5'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc42630>, '-', <__main__.AgrTerminal object at 0x10fc86da0>, '#', <__main__.Root object at 0x10fc452b0>, '-', <__main__.NominalizerTerminal object at 0x10fc459b0>, '-', <__main__.SemanticTerminal object at 0x10fc45160>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'e_1', 'a_2'}
we picked null_16 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: una#OFFSPRING-a
full_pronunciation: una#OFFSPRINGo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 51.30000000000033
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 56.40000000000033
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_3
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 9.600000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1', 'a_2'}
    diacritic: null_16
    triggers: set()
    weight: 11.6
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 24.80000000000002
line done
line done

---------------------

input line #372
input roots: [<__main__.Root object at 0x10fc2d438>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 122.99999999999807..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 38.50000000000025..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 54.700000000000365..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 123.09999999999806..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 54.80000000000037..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 51.30000000000033..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 123.19999999999806..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 123.29999999999805..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 39.400000000000226..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 54.90000000000037..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'OFFSPRING_3', 'o_1', 'OFFSPRING_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc459b0>, '-', <__main__.AgrTerminal object at 0x10fc41390>, '#', <__main__.Root object at 0x10fc42908>, '-', <__main__.NominalizerTerminal object at 0x10fc42208>, '-', <__main__.SemanticTerminal object at 0x10fc45860>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'i_2', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'i_2', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: lo#OFFSPRING-o
full_pronunciation: la#OFFSPRINGo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 123.29999999999805
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 56.30000000000033
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_3
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 9.500000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.199999999999868
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 24.80000000000002
line done
line done

---------------------

input line #373
input roots: [<__main__.Root object at 0x10fc433c8>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 123.29999999999805..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 56.30000000000033..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 39.50000000000023..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 123.39999999999804..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 55.00000000000037..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 39.60000000000023..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 123.49999999999804..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1', 'GRANDPARENT_1'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_3 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1', 'GRANDPARENT_4', 'GRANDPARENT_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67b00>, '#', <__main__.Root object at 0x10fc86c50>, '-', <__main__.NominalizerTerminal object at 0x10fc86b38>, '-', <__main__.SemanticTerminal object at 0x10fc86da0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_7: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: li#GRANDPARENT-i
full_pronunciation: l#GRANDPARENTe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 123.49999999999804
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_7
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.099999999999866
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 14.899999999999999
line done
line done

---------------------

input line #374
input roots: [<__main__.Root object at 0x10fc86668>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 123.49999999999804..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 56.40000000000033..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 38.60000000000025..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 123.59999999999803..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 55.10000000000037..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 38.70000000000025..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 123.69999999999803..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: CAR in its selectional

now working with the word 'CAR-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'CAR_1', 'null_6'}
     what if we combine triggers with the otherwise identical vi CAR_3 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'CAR_2', 'null_26', 'CAR_1', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc86c88>, '#', <__main__.Root object at 0x10fc867b8>, '-', <__main__.NominalizerTerminal object at 0x10fc86278>, '-', <__main__.SemanticTerminal object at 0x10fc86518>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out CAR terminal with values set()
we picked CAR_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: le#CAR-e
full_pronunciation: l#CARe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 123.69999999999803
VocabularyItem:
    pronunciation: CAR
    label: CAR
    values: set()
    diacritic: CAR_3
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 9.600000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.999999999999865
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 14.899999999999999
line done
line done

---------------------

input line #375
input roots: [<__main__.Root object at 0x10fc86f28>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 56.500000000000334..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 123.69999999999803..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 51.40000000000033..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 51.500000000000334..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: MILKCOW in its selectional

now working with the word 'MILKCOW-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'MILKCOW_1'}
     what if we combine triggers with the otherwise identical vi MILKCOW_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'MILKCOW_1', 'MILKCOW_2', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc3bf98>, '-', <__main__.AgrTerminal object at 0x10fc86710>, '#', <__main__.Root object at 0x10fc2deb8>, '-', <__main__.NominalizerTerminal object at 0x10fc35fd0>, '-', <__main__.SemanticTerminal object at 0x10fc35be0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MILKCOW terminal with values set()
we picked MILKCOW_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2', 'a'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: una#MILKCOW-a
full_pronunciation: una#MILKCOWa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: MILKCOW to the selectional of the nominalizer whose values are {'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'a_2'}
    selectional: {'FROG', 'CHILD', 'BALL', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 58.700000000000585
    linear: (<__main__.NominalizerTerminal object at 0x10fc05f28>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'FROG', 'BALL', 'CHILD', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_16, triggers = set(), weight = 11.6..already existed

create_vi: tried nominalizer: null_32, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.399999999999999..already existed

create_vi: tried nominalizer: null_17, triggers = {('e', frozenset({'-atomic'}))}, weight = 10.599999999999998..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_24, triggers = set(), weight = 12.2..already existed

create_vi: tried nominalizer: null_28, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.999999999999998..already existed
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 51.500000000000334
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 56.500000000000334
VocabularyItem:
    pronunciation: MILKCOW
    label: MILKCOW
    values: set()
    diacritic: MILKCOW_2
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 10.3
     what if we combine triggers with the otherwise identical vi MILKCOW_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 11.600000000000009
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 29.600000000000037
line done
line done

---------------------

input line #376
input roots: [<__main__.Root object at 0x10fc28128>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 123.79999999999802..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 38.80000000000025..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 55.20000000000037..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 123.89999999999802..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 55.300000000000374..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 52.100000000000335..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 123.99999999999801..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 124.099999999998..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 39.70000000000023..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 55.400000000000375..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'OFFSPRING_3', 'o_1', 'OFFSPRING_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc47da0>, '-', <__main__.AgrTerminal object at 0x10fc3bf28>, '#', <__main__.Root object at 0x10fc47cf8>, '-', <__main__.NominalizerTerminal object at 0x10fc47e10>, '-', <__main__.SemanticTerminal object at 0x10fc47160>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: lo#OFFSPRING-o
full_pronunciation: lo#OFFSPRINGo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: OFFSPRING to the selectional of the nominalizer whose values are {'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'o_2'}
    selectional: {'MOUSE', 'CHILD', 'BOOK', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 61.00000000000062
    linear: (<__main__.NominalizerTerminal object at 0x10fc08908>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_20, triggers = set(), weight = 11.899999999999999..already existed

create_vi: tried nominalizer: null_30, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.299999999999999..already existed

create_vi: tried nominalizer: null_31, triggers = {('e', frozenset({'-atomic'}))}, weight = 10.399999999999999..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_12, triggers = set(), weight = 11.599999999999998..already existed

create_vi: tried nominalizer: null_13, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.399999999999999..already existed
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 124.099999999998
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 55.400000000000375
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_4
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 11.30000000000001
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 24.80000000000002
line done
line done

---------------------

input line #377
input roots: [<__main__.Root object at 0x10fc47080>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 124.699999999998..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 57.100000000000335..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 39.80000000000023..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 124.799999999998..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 56.00000000000038..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 39.90000000000023..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 124.89999999999799..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: CASTLE in its selectional

now working with the word 'CASTLE-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CASTLE_1', 'null_12', 'null_13', 'i_1'}
     what if we combine triggers with the otherwise identical vi CASTLE_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1', 'CASTLE_1', 'CASTLE_3'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4ba20>, '#', <__main__.Root object at 0x10fc4b668>, '-', <__main__.NominalizerTerminal object at 0x10fc4b898>, '-', <__main__.SemanticTerminal object at 0x10fc4b9e8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out CASTLE terminal with values set()
we picked CASTLE_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: li#CASTLE-i
full_pronunciation: l#CASTLEi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 124.89999999999799
VocabularyItem:
    pronunciation: CASTLE
    label: CASTLE
    values: set()
    diacritic: CASTLE_2
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 11.200000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 12.100000000000009
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 24.900000000000027
line done
line done

---------------------

input line #378
input roots: [<__main__.Root object at 0x10fc4b4e0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 124.89999999999799..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 57.20000000000034..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 40.000000000000234..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 124.99999999999798..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 56.10000000000038..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 40.100000000000236..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 125.09999999999798..already existed
  we're in a functional word...
  - nominalizer's values are now {'a_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'a_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_24', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_24', 'i_1', 'null_28'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_24', 'i_1', 'null_28'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_5 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_28', 'OFFSPRING_2', 'null_24', 'i_1', 'OFFSPRING_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b198>, '#', <__main__.Root object at 0x10fc6f3c8>, '-', <__main__.NominalizerTerminal object at 0x10fc6ff98>, '-', <__main__.SemanticTerminal object at 0x10fc052b0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#OFFSPRING-i
full_pronunciation: l#OFFSPRINGi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 125.09999999999798
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 12.000000000000009
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 24.900000000000027
line done
line done

---------------------

input line #379
input roots: [<__main__.Root object at 0x10fc4b128>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 125.09999999999798..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 38.900000000000254..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 57.30000000000034..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 125.19999999999797..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 57.40000000000034..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 52.20000000000034..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 125.29999999999797..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 125.39999999999796..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 40.20000000000024..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 57.50000000000034..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: KEY in its selectional

now working with the word 'KEY-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'KEY_1', 'null_10'}
     what if we combine triggers with the otherwise identical vi KEY_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'KEY_3', 'KEY_1', 'e_3', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc58320>, '-', <__main__.AgrTerminal object at 0x10fc4b860>, '#', <__main__.Root object at 0x10fc50a20>, '-', <__main__.NominalizerTerminal object at 0x10fc50390>, '-', <__main__.SemanticTerminal object at 0x10fc36320>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out KEY terminal with values set()
we picked KEY_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'a_2'}
we picked null_6 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: la#KEY-e
full_pronunciation: la#KEYo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 125.39999999999796
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 57.50000000000034
VocabularyItem:
    pronunciation: KEY
    label: KEY
    values: set()
    diacritic: KEY_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.100000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_6
    triggers: set()
    weight: 11.200000000000001
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 25.30000000000002
line done
line done

---------------------

input line #380
input roots: [<__main__.Root object at 0x10fc38390>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 125.39999999999796..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 57.50000000000034..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 40.30000000000024..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 125.49999999999795..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 56.20000000000038..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 40.40000000000024..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 125.59999999999795..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_12', 'null_13', 'i_1'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_5 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'OFFSPRING_2', 'null_13', 'i_1', 'OFFSPRING_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc580f0>, '#', <__main__.Root object at 0x10fc583c8>, '-', <__main__.NominalizerTerminal object at 0x10fc58198>, '-', <__main__.SemanticTerminal object at 0x10fc58c88>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_8: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: li#OFFSPRING-i
full_pronunciation: l#OFFSPRINGe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 125.59999999999795
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_8
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.200000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.899999999999864
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 14.799999999999999
line done
line done

---------------------

input line #381
input roots: [<__main__.Root object at 0x10fc58c50>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 125.59999999999795..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 57.60000000000034..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 39.000000000000256..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 125.69999999999794..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 56.30000000000038..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 39.10000000000026..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 125.79999999999794..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'GRANDPARENT_1', 'null_6'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_3 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'GRANDPARENT_7', 'null_26', 'GRANDPARENT_1', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'e_1'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b390>, '-', <__main__.AgrTerminal object at 0x10fc58ac8>, '#', <__main__.Root object at 0x10fc4bf60>, '-', <__main__.NominalizerTerminal object at 0x10fc4bc50>, '-', <__main__.SemanticTerminal object at 0x10fc4b358>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1'}
we picked null_26: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: le#GRANDPARENT-e
full_pronunciation: le#GRANDPARENTe
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: GRANDPARENT to the selectional of the nominalizer whose values are {'e_1'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1'}
    selectional: {'CHILD', 'FROG', 'BALL', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 13.399999999999988
    linear: (<__main__.NominalizerTerminal object at 0x10fbeb2e8>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'a_2'} as values: {'CHILD', 'BALL', 'FROG', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
..so we'll also combine the vis that spell out {'a_2'}

create_vi: tried nominalizer: null_17, triggers = {('e', frozenset({'-atomic'}))}, weight = 10.699999999999998..already existed

create_vi: tried nominalizer: null_34, triggers = {('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}, weight = 10.299999999999999..already existed

create_vi: tried nominalizer: null_35, triggers = {('e', frozenset({'-atomic'})), ('e', frozenset({'+atomic'}))}, weight = 10.1..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'o_2'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'o_2'}

create_vi: tried nominalizer: null_31, triggers = {('e', frozenset({'-atomic'}))}, weight = 10.499999999999998..already existed

create_vi: tried nominalizer: null_36, triggers = {('o', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}, weight = 10.2..already existed

create_vi: tried nominalizer: null_37, triggers = {('e', frozenset({'-atomic'})), ('e', frozenset({'+atomic'}))}, weight = 10.1..already existed
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 125.79999999999794
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 39.10000000000026
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_1
    triggers: set()
    weight: 9.500000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_26
    triggers: {('e', frozenset({'-atomic'}))}
    weight: 12.499999999999995
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 14.799999999999999
line done
line done

---------------------

input line #382
input roots: [<__main__.Root object at 0x10fc05470>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 126.39999999999793..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 39.70000000000026..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 57.700000000000344..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 126.49999999999793..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 57.800000000000345..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 52.30000000000034..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 126.59999999999792..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 126.69999999999791..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 40.50000000000024..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 57.90000000000035..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1', 'e_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: KEY in its selectional

now working with the word 'KEY-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'e_3', 'null_22'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'e_3', 'KEY_1', 'null_22'}
     what if we combine triggers with the otherwise identical vi KEY_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'KEY_3', 'KEY_1', 'null_16', 'null_22', 'e_3'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b828>, '-', <__main__.AgrTerminal object at 0x10fc4bda0>, '#', <__main__.Root object at 0x10fc47f28>, '-', <__main__.NominalizerTerminal object at 0x10fc47438>, '-', <__main__.SemanticTerminal object at 0x10fc1b9b0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out KEY terminal with values set()
we picked KEY_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e', 'e_1', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: la#KEY-e
full_pronunciation: lo#KEYe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 126.69999999999791
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 56.30000000000038
VocabularyItem:
    pronunciation: KEY
    label: KEY
    values: set()
    diacritic: KEY_4
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'})), ('e', frozenset({'+atomic'}))}
    weight: 11.200000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 11.80000000000001
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 16.5
line done
line done

---------------------

input line #383
input roots: [<__main__.Root object at 0x10fc4b160>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 126.69999999999791..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 39.80000000000026..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 56.30000000000038..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 126.79999999999791..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 56.40000000000038..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 52.40000000000034..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 126.8999999999979..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 126.9999999999979..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 40.60000000000024..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 56.500000000000384..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CLOWN in its selectional

now working with the word 'CLOWN-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CLOWN_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CLOWN_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'CLOWN_3', 'o_1', 'CLOWN_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc2d518>, '-', <__main__.AgrTerminal object at 0x10fc180f0>, '#', <__main__.Root object at 0x10fc3bf28>, '-', <__main__.NominalizerTerminal object at 0x10fc35be0>, '-', <__main__.SemanticTerminal object at 0x10fc356d8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CLOWN terminal with values set()
we picked CLOWN_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o_2'}
we picked null_9: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: lo#CLOWN-o
full_pronunciation: lo#CLOWNo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CLOWN to the selectional of the nominalizer whose values are {'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'o_2'}
    selectional: {'MOUSE', 'CHILD', 'BOOK', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 62.00000000000063
    linear: (<__main__.NominalizerTerminal object at 0x10fc08908>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_21, triggers = {('o', frozenset({'+atomic'}))}, weight = 10.2..already existed

create_vi: tried nominalizer: null_38, triggers = {('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}, weight = 10.1..already existed

create_vi: tried nominalizer: null_36, triggers = {('o', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}, weight = 10.299999999999999..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_18, triggers = {('o', frozenset({'+atomic'}))}, weight = 10.899999999999999..already existed

create_vi: tried nominalizer: null_39, triggers = {('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}, weight = 10.1..already existed
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 126.9999999999979
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 56.500000000000384
VocabularyItem:
    pronunciation: CLOWN
    label: CLOWN
    values: set()
    diacritic: CLOWN_1
    triggers: set()
    weight: 10.600000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_9
    triggers: {('o', frozenset({'+atomic'}))}
    weight: 10.3
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 25.30000000000002
line done
line done

---------------------

input line #384
input roots: [<__main__.Root object at 0x10fc2dbe0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 127.59999999999789..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 39.90000000000026..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 58.00000000000035..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 127.69999999999789..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 58.10000000000035..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 52.50000000000034..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 127.79999999999788..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 127.89999999999787..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 40.700000000000244..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 58.20000000000035..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'CHILD_1', 'a_1'}
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CHILD_1', 'a_1', 'CHILD_2', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc86550>, '-', <__main__.AgrTerminal object at 0x10fc471d0>, '#', <__main__.Root object at 0x10fc86dd8>, '-', <__main__.NominalizerTerminal object at 0x10fc868d0>, '-', <__main__.SemanticTerminal object at 0x10fc86080>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_7: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: la#CHILD-a
full_pronunciation: lo#CHILDe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 127.89999999999787
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 57.000000000000384
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_7
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.799999999999862
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 16.4
line done
line done

---------------------

input line #385
input roots: [<__main__.Root object at 0x10fc3c748>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 127.89999999999787..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 58.30000000000035..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 40.00000000000026..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 127.99999999999787..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 57.000000000000384..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 40.100000000000264..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 128.09999999999786..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: FROG in its selectional

now working with the word 'FROG-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'null_17'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_1', 'e_2', 'null_16', 'null_17'}
     what if we combine triggers with the otherwise identical vi FROG_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'FROG_1', 'FROG_3', 'null_17'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc86b38>, '-', <__main__.AgrTerminal object at 0x10fc86f28>, '#', <__main__.Root object at 0x10fc676d8>, '-', <__main__.NominalizerTerminal object at 0x10fc67080>, '-', <__main__.SemanticTerminal object at 0x10fc86e48>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic', 'a_2'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FROG terminal with values set()
we picked FROG_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e', 'e_1', 'a_2'}
we picked null_6 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: le#FROG-e
full_pronunciation: le#FROGe
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: FROG to the selectional of the nominalizer whose values are {'e_1', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1', 'a_2'}
    selectional: {'FROG', 'BALL', 'CHILD', 'TOWER', 'PIBLING', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 26.400000000000052
    linear: (<__main__.NominalizerTerminal object at 0x10fc2aa20>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 128.09999999999786
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 40.100000000000264
VocabularyItem:
    pronunciation: FROG
    label: FROG
    values: set()
    diacritic: FROG_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.200000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_6
    triggers: set()
    weight: 11.100000000000001
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 15.399999999999999
line done
line done

---------------------

input line #386
input roots: [<__main__.Root object at 0x10fc866a0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 57.100000000000385..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 128.69999999999786..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 52.60000000000034..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 52.700000000000344..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1', 'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: CASTLE in its selectional

now working with the word 'CASTLE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_18', 'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_18', 'o_1', 'CASTLE_1', 'null_12'}
     what if we combine triggers with the otherwise identical vi CASTLE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'CASTLE_2', 'o_1', 'null_18', 'CASTLE_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc45160>, '-', <__main__.AgrTerminal object at 0x10fc67240>, '#', <__main__.Root object at 0x10fc43278>, '-', <__main__.NominalizerTerminal object at 0x10fc43198>, '-', <__main__.SemanticTerminal object at 0x10fc45940>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CASTLE terminal with values set()
we picked CASTLE_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: uno#CASTLE-o
full_pronunciation: uno#CASTLEo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CASTLE to the selectional of the nominalizer whose values are {'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'o_2'}
    selectional: {'MOUSE', 'CHILD', 'BOOK', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 62.40000000000064
    linear: (<__main__.NominalizerTerminal object at 0x10fc08908>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_6, triggers = set(), weight = 11.700000000000001..already existed

create_vi: tried nominalizer: null_7, triggers = {('i', frozenset({'-atomic'}))}, weight = 11.499999999999995..already existed

create_vi: tried nominalizer: null_26, triggers = {('e', frozenset({'-atomic'}))}, weight = 13.099999999999994..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_14, triggers = set(), weight = 13.8..already existed

create_vi: tried nominalizer: null_15, triggers = {('i', frozenset({'-atomic'}))}, weight = 11.699999999999994..already existed
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 52.700000000000344
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 57.100000000000385
VocabularyItem:
    pronunciation: CASTLE
    label: CASTLE
    values: set()
    diacritic: CASTLE_2
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 11.100000000000001
     what if we combine triggers with the otherwise identical vi CASTLE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.69999999999986
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 25.90000000000002
line done
line done

---------------------

input line #387
input roots: [<__main__.Root object at 0x10fc45860>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 128.79999999999785..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 58.400000000000354..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 40.800000000000246..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 128.89999999999785..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 57.70000000000039..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 40.90000000000025..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 128.99999999999784..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: BOOK in its selectional

now working with the word 'BOOK-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'BOOK_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi BOOK_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_15', 'BOOK_2', 'BOOK_1', 'i_1', 'null_14'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50438>, '#', <__main__.Root object at 0x10fc505c0>, '-', <__main__.NominalizerTerminal object at 0x10fc6a5f8>, '-', <__main__.SemanticTerminal object at 0x10fc502e8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out BOOK terminal with values set()
we picked BOOK_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: li#BOOK-i
full_pronunciation: l#BOOKe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 128.99999999999784
VocabularyItem:
    pronunciation: BOOK
    label: BOOK
    values: set()
    diacritic: BOOK_3
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 10.100000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.19999999999986
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 15.899999999999999
line done
line done

---------------------

input line #388
input roots: [<__main__.Root object at 0x10fc50828>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 128.99999999999784..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 40.700000000000266..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 57.80000000000039..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 129.09999999999783..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 57.90000000000039..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 53.300000000000345..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 129.19999999999783..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 129.29999999999782..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 41.00000000000025..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 58.00000000000039..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FLOWER in its selectional

now working with the word 'FLOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19', 'FLOWER_1'}
     what if we combine triggers with the otherwise identical vi FLOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FLOWER_3', 'e_3', 'null_19', 'FLOWER_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67278>, '-', <__main__.AgrTerminal object at 0x10fc509e8>, '#', <__main__.Root object at 0x10fc3c748>, '-', <__main__.NominalizerTerminal object at 0x10fc670b8>, '-', <__main__.SemanticTerminal object at 0x10fc67780>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'i_2', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FLOWER terminal with values set()
we picked FLOWER_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: lo#FLOWER-e
full_pronunciation: la#FLOWERo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 129.29999999999782
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 58.400000000000354
VocabularyItem:
    pronunciation: FLOWER
    label: FLOWER
    values: set()
    diacritic: FLOWER_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.600000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.09999999999986
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 26.40000000000002
line done
line done

---------------------

input line #389
input roots: [<__main__.Root object at 0x10fc67390>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 58.400000000000354..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 129.29999999999782..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 53.40000000000035..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 53.50000000000035..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: TOWER in its selectional

now working with the word 'TOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'TOWER_1', 'e_3', 'null_10'}
     what if we combine triggers with the otherwise identical vi TOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'TOWER_1', 'TOWER_3', 'e_3', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc86518>, '-', <__main__.AgrTerminal object at 0x10fc86d30>, '#', <__main__.Root object at 0x10fc868d0>, '-', <__main__.NominalizerTerminal object at 0x10fc86dd8>, '-', <__main__.SemanticTerminal object at 0x10fc86f98>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out TOWER terminal with values set()
we picked TOWER_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'o_2'}
we picked null_14 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: una#TOWER-e
full_pronunciation: uno#TOWERe
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 53.50000000000035
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 58.00000000000039
VocabularyItem:
    pronunciation: TOWER
    label: TOWER
    values: set()
    diacritic: TOWER_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 13.8
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 16.5
line done
line done

---------------------

input line #390
input roots: [<__main__.Root object at 0x10fc41390>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 58.00000000000039..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 129.39999999999782..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 53.50000000000035..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 53.60000000000035..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'OFFSPRING_3', 'o_1', 'OFFSPRING_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc22c88>, '-', <__main__.AgrTerminal object at 0x10fc86d68>, '#', <__main__.Root object at 0x10fc2d748>, '-', <__main__.NominalizerTerminal object at 0x10fc356d8>, '-', <__main__.SemanticTerminal object at 0x10fc3bf28>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_5: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a', 'i_2', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: uno#OFFSPRING-o
full_pronunciation: una#OFFSPRINGa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 53.60000000000035
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 58.400000000000354
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_5
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 10.100000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 11.90000000000001
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 30.20000000000004
line done
line done

---------------------

input line #391
input roots: [<__main__.Root object at 0x10fc20ef0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 58.400000000000354..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 129.4999999999978..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 53.60000000000035..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 53.70000000000035..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: TOWER in its selectional

now working with the word 'TOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'TOWER_1', 'e_3', 'null_10'}
     what if we combine triggers with the otherwise identical vi TOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'TOWER_1', 'TOWER_3', 'e_3', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc47400>, '-', <__main__.AgrTerminal object at 0x10fc2dbe0>, '#', <__main__.Root object at 0x10fc1b710>, '-', <__main__.NominalizerTerminal object at 0x10fc47320>, '-', <__main__.SemanticTerminal object at 0x10fc47240>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out TOWER terminal with values set()
we picked TOWER_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o_2'}
we picked null_8: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: una#TOWER-e
full_pronunciation: uno#TOWERa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 53.70000000000035
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 58.00000000000039
VocabularyItem:
    pronunciation: TOWER
    label: TOWER
    values: set()
    diacritic: TOWER_1
    triggers: set()
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 11.70000000000001
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 30.100000000000037
line done
line done

---------------------

input line #392
input roots: [<__main__.Root object at 0x10fc47e10>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 58.00000000000039..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 129.5999999999978..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 53.70000000000035..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 53.80000000000035..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'OFFSPRING_3', 'o_1', 'OFFSPRING_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b5f8>, '-', <__main__.AgrTerminal object at 0x10fc471d0>, '#', <__main__.Root object at 0x10fc4b7f0>, '-', <__main__.NominalizerTerminal object at 0x10fc4b128>, '-', <__main__.SemanticTerminal object at 0x10fc4b588>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_8: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'a_2', 'o'}
we picked null_6 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: uno#OFFSPRING-o
full_pronunciation: una#OFFSPRINGo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 53.80000000000035
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 58.400000000000354
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_8
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.100000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_6
    triggers: set()
    weight: 11.700000000000001
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 26.50000000000002
line done
line done

---------------------

input line #393
input roots: [<__main__.Root object at 0x10fc4bfd0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 129.6999999999978..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 40.80000000000027..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 58.10000000000039..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 129.7999999999978..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 58.200000000000394..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 53.80000000000035..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 129.8999999999978..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 129.99999999999778..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 41.10000000000025..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 58.300000000000395..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'GRANDPARENT_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'GRANDPARENT_1', 'GRANDPARENT_2'}
done processing input, time to test
we selected the nominalizer with values: {'e_1'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4bda0>, '#', <__main__.Root object at 0x10fc6f7b8>, '-', <__main__.NominalizerTerminal object at 0x10fc6f080>, '-', <__main__.SemanticTerminal object at 0x10fc6f3c8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', 'e_1', '+atomic'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_8: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'e_1', 'null'}
we picked null_6 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: lo#GRANDPARENT-o
full_pronunciation: l#GRANDPARENTo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 129.99999999999778
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_8
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_6
    triggers: set()
    weight: 11.600000000000001
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 26.50000000000002
line done
line done

---------------------

input line #394
input roots: [<__main__.Root object at 0x10fc6f518>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 58.4000000000004..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 129.99999999999778..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 53.900000000000354..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 54.000000000000355..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: MOUSE in its selectional

now working with the word 'MOUSE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'MOUSE_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi MOUSE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'MOUSE_2', 'MOUSE_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6fa58>, '#', <__main__.Root object at 0x10fc6a9b0>, '-', <__main__.NominalizerTerminal object at 0x10fc6a8d0>, '-', <__main__.SemanticTerminal object at 0x10fc6afd0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite', 'i_2', '+atomic'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out MOUSE terminal with values set()
we picked MOUSE_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i_2'}
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: uno#MOUSE-o
full_pronunciation: un#MOUSEa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 54.000000000000355
VocabularyItem:
    pronunciation: MOUSE
    label: MOUSE
    values: set()
    diacritic: MOUSE_1
    triggers: set()
    weight: 9.600000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.999999999999858
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 30.000000000000036
line done
line done

---------------------

input line #395
input roots: [<__main__.Root object at 0x10fc58358>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 130.09999999999778..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 58.400000000000354..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 41.20000000000025..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 130.19999999999777..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 58.5000000000004..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 41.30000000000025..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 130.29999999999777..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: MOUSE in its selectional

now working with the word 'MOUSE-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'MOUSE_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi MOUSE_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'MOUSE_3', 'null_15', 'MOUSE_1', 'i_1', 'null_14'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc08400>, '-', <__main__.AgrTerminal object at 0x10fc3d550>, '#', <__main__.Root object at 0x10fc4b080>, '-', <__main__.NominalizerTerminal object at 0x10fc4b160>, '-', <__main__.SemanticTerminal object at 0x10fc10780>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic', 'a_2'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MOUSE terminal with values set()
we picked MOUSE_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: li#MOUSE-i
full_pronunciation: le#MOUSEe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 130.29999999999777
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 40.80000000000027
VocabularyItem:
    pronunciation: MOUSE
    label: MOUSE
    values: set()
    diacritic: MOUSE_2
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 10.200000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.899999999999856
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 15.799999999999999
line done
line done

---------------------

input line #396
input roots: [<__main__.Root object at 0x10fc58eb8>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 130.29999999999777..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 40.80000000000027..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 58.6000000000004..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 130.39999999999776..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 58.7000000000004..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 54.000000000000355..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 130.49999999999775..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 130.59999999999775..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 41.400000000000254..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 58.8000000000004..already existed
  we're in a functional word...
  - nominalizer's values are now {'i_2', 'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: CASTLE in its selectional

now working with the word 'CASTLE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_18', 'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_18', 'o_1', 'CASTLE_1', 'null_12'}
     what if we combine triggers with the otherwise identical vi CASTLE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'CASTLE_2', 'o_1', 'null_18', 'CASTLE_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b828>, '-', <__main__.AgrTerminal object at 0x10fc58ac8>, '#', <__main__.Root object at 0x10fc1b9b0>, '-', <__main__.NominalizerTerminal object at 0x10fc4ba58>, '-', <__main__.SemanticTerminal object at 0x10fc4b5c0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'i_2', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CASTLE terminal with values set()
we picked CASTLE_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'i_2', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: lo#CASTLE-o
full_pronunciation: lo#CASTLEo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CASTLE to the selectional of the nominalizer whose values are {'i_2', 'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'o_2'}
    selectional: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'GRANDPARENT', 'CASTLE', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 26.60000000000006
    linear: (<__main__.NominalizerTerminal object at 0x10fc22eb8>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 130.59999999999775
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 58.8000000000004
VocabularyItem:
    pronunciation: CASTLE
    label: CASTLE
    values: set()
    diacritic: CASTLE_2
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 11.600000000000001
     what if we combine triggers with the otherwise identical vi CASTLE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 11.60000000000001
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 26.600000000000023
line done
line done

---------------------

input line #397
input roots: [<__main__.Root object at 0x10fc4b518>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 59.400000000000404..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 131.19999999999774..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 54.10000000000036..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 54.20000000000036..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1', 'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_18', 'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_18', 'o_1', 'GRANDPARENT_1', 'null_12'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'o_1', 'null_18', 'GRANDPARENT_1', 'GRANDPARENT_2'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc2df28>, '-', <__main__.AgrTerminal object at 0x10fc080b8>, '#', <__main__.Root object at 0x10fc3bf98>, '-', <__main__.NominalizerTerminal object at 0x10fc2deb8>, '-', <__main__.SemanticTerminal object at 0x10fc2d518>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_9: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'o_2', 'a'}
we picked null_6 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: uno#GRANDPARENT-o
full_pronunciation: uno#GRANDPARENTa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 54.20000000000036
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 59.400000000000404
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_9
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_6
    triggers: set()
    weight: 11.500000000000002
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 29.900000000000034
line done
line done

---------------------

input line #398
input roots: [<__main__.Root object at 0x10fc4b588>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 58.500000000000355..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 131.29999999999774..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 54.20000000000036..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 54.30000000000036..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'OFFSPRING_1', 'null_11', 'null_10', 'OFFSPRING_5'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc31da0>, '-', <__main__.AgrTerminal object at 0x10fc228d0>, '#', <__main__.Root object at 0x10fc86fd0>, '-', <__main__.NominalizerTerminal object at 0x10fc86e48>, '-', <__main__.SemanticTerminal object at 0x10fc86c18>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_9: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2', 'a'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: una#OFFSPRING-a
full_pronunciation: uno#OFFSPRINGa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 54.30000000000036
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 59.3000000000004
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_9
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 12.10000000000001
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 29.900000000000034
line done
line done

---------------------

input line #399
input roots: [<__main__.Root object at 0x10fc2d6d8>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 59.3000000000004..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 131.39999999999773..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 54.30000000000036..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 54.40000000000036..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FOOT in its selectional

now working with the word 'FOOT-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FOOT_1', 'null_8', 'e_3', 'null_19'}
     what if we combine triggers with the otherwise identical vi FOOT_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FOOT_1', 'e_3', 'FOOT_2', 'null_19'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc86048>, '-', <__main__.AgrTerminal object at 0x10fc86550>, '#', <__main__.Root object at 0x10fc3c748>, '-', <__main__.NominalizerTerminal object at 0x10fc86da0>, '-', <__main__.SemanticTerminal object at 0x10fc86940>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FOOT terminal with values set()
we picked FOOT_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: uno#FOOT-e
full_pronunciation: uno#FOOTe
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: FOOT to the selectional of the nominalizer whose values are {'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'o_2'}
    selectional: {'MOUSE', 'CHILD', 'BOOK', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 64.80000000000061
    linear: (<__main__.NominalizerTerminal object at 0x10fc08908>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_6, triggers = set(), weight = 11.500000000000002..already existed

create_vi: tried nominalizer: null_7, triggers = {('i', frozenset({'-atomic'}))}, weight = 11.599999999999994..already existed

create_vi: tried nominalizer: null_26, triggers = {('e', frozenset({'-atomic'}))}, weight = 13.199999999999994..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_14, triggers = set(), weight = 13.8..already existed

create_vi: tried nominalizer: null_15, triggers = {('i', frozenset({'-atomic'}))}, weight = 11.799999999999994..already existed
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 54.40000000000036
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 59.3000000000004
VocabularyItem:
    pronunciation: FOOT
    label: FOOT
    values: set()
    diacritic: FOOT_4
    triggers: {('null', frozenset()), ('e', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 10.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.799999999999855
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 16.6
line done
line done

---------------------

input line #400
input roots: [<__main__.Root object at 0x10fc861d0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 58.60000000000036..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 131.49999999999773..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 55.00000000000036..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 55.100000000000364..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'OFFSPRING_1', 'null_11', 'null_10', 'OFFSPRING_5'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67ac8>, '-', <__main__.AgrTerminal object at 0x10fc86470>, '#', <__main__.Root object at 0x10fc67160>, '-', <__main__.NominalizerTerminal object at 0x10fc67860>, '-', <__main__.SemanticTerminal object at 0x10fc67dd8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_5: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'o_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: una#OFFSPRING-a
full_pronunciation: uno#OFFSPRINGa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 55.100000000000364
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 59.8000000000004
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_5
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 10.000000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.299999999999855
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 29.900000000000034
line done
line done

---------------------

input line #401
input roots: [<__main__.Root object at 0x10fc2f048>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 131.59999999999772..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 40.90000000000027..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 58.70000000000036..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 131.69999999999771..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 58.80000000000036..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 55.100000000000364..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 131.7999999999977..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 131.8999999999977..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 41.500000000000256..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 58.90000000000036..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: BALL in its selectional

now working with the word 'BALL-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'BALL_1', 'a_1'}
     what if we combine triggers with the otherwise identical vi BALL_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'BALL_1', 'BALL_2', 'null_10', 'null_11'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a0b8>, '-', <__main__.AgrTerminal object at 0x10fc45160>, '#', <__main__.Root object at 0x10fc6a978>, '-', <__main__.NominalizerTerminal object at 0x10fc6a7f0>, '-', <__main__.SemanticTerminal object at 0x10fc6a048>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BALL terminal with values set()
we picked BALL_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1', 'o_2'}
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: la#BALL-a
full_pronunciation: lo#BALLe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 131.8999999999977
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 59.7000000000004
VocabularyItem:
    pronunciation: BALL
    label: BALL
    values: set()
    diacritic: BALL_1
    triggers: set()
    weight: 10.3
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.199999999999854
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 17.1
line done
line done

---------------------

input line #402
input roots: [<__main__.Root object at 0x10fc67240>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 131.8999999999977..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 41.00000000000027..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 59.7000000000004..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 131.9999999999977..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 59.8000000000004..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 55.200000000000365..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 132.0999999999977..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 132.1999999999977..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 41.60000000000026..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 59.900000000000404..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'GRANDPARENT_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'GRANDPARENT_1', 'GRANDPARENT_2'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc45358>, '-', <__main__.AgrTerminal object at 0x10fc67e80>, '#', <__main__.Root object at 0x10fc411d0>, '-', <__main__.NominalizerTerminal object at 0x10fc41390>, '-', <__main__.SemanticTerminal object at 0x10fc42630>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'i_2', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_6: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'o_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: lo#GRANDPARENT-o
full_pronunciation: lo#GRANDPARENTa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 132.1999999999977
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 59.900000000000404
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_6
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 10.200000000000003
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.099999999999852
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 29.900000000000034
line done
line done

---------------------

input line #403
input roots: [<__main__.Root object at 0x10fc3c748>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 132.1999999999977..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 59.00000000000036..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 41.10000000000027..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 132.29999999999768..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 59.900000000000404..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 41.20000000000027..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 132.39999999999768..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: MILKCOW in its selectional

now working with the word 'MILKCOW-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'null_17'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'MILKCOW_1', 'null_17'}
     what if we combine triggers with the otherwise identical vi MILKCOW_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'MILKCOW_3', 'MILKCOW_1', 'null_17'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc861d0>, '#', <__main__.Root object at 0x10fc86d30>, '-', <__main__.NominalizerTerminal object at 0x10fc866d8>, '-', <__main__.SemanticTerminal object at 0x10fc864e0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out MILKCOW terminal with values set()
we picked MILKCOW_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: le#MILKCOW-e
full_pronunciation: l#MILKCOWe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 132.39999999999768
VocabularyItem:
    pronunciation: MILKCOW
    label: MILKCOW
    values: set()
    diacritic: MILKCOW_3
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 9.300000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 11.80000000000001
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 15.799999999999999
line done
line done

---------------------

input line #404
input roots: [<__main__.Root object at 0x10fc86748>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 132.39999999999768..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 59.100000000000364..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 41.70000000000026..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 132.49999999999767..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 60.000000000000405..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 41.80000000000026..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 132.59999999999766..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: BOOK in its selectional

now working with the word 'BOOK-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'BOOK_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi BOOK_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_15', 'BOOK_2', 'BOOK_1', 'i_1', 'null_14'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc86e10>, '#', <__main__.Root object at 0x10fc207b8>, '-', <__main__.NominalizerTerminal object at 0x10fc38908>, '-', <__main__.SemanticTerminal object at 0x10fc3e828>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out BOOK terminal with values set()
we picked BOOK_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#BOOK-i
full_pronunciation: l#BOOKi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 132.59999999999766
VocabularyItem:
    pronunciation: BOOK
    label: BOOK
    values: set()
    diacritic: BOOK_4
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 12.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 12.00000000000001
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 25.20000000000003
line done
line done

---------------------

input line #405
input roots: [<__main__.Root object at 0x10fc20ef0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 60.100000000000406..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 132.59999999999766..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 55.30000000000037..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 55.40000000000037..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CLOWN in its selectional

now working with the word 'CLOWN-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CLOWN_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CLOWN_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'CLOWN_3', 'o_1', 'CLOWN_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc18588>, '-', <__main__.AgrTerminal object at 0x10fc86b70>, '#', <__main__.Root object at 0x10fc47da0>, '-', <__main__.NominalizerTerminal object at 0x10fc47080>, '-', <__main__.SemanticTerminal object at 0x10fc182b0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CLOWN terminal with values set()
we picked CLOWN_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: uno#CLOWN-o
full_pronunciation: uno#CLOWNo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CLOWN to the selectional of the nominalizer whose values are {'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'o_2'}
    selectional: {'MOUSE', 'CHILD', 'BOOK', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 65.80000000000055
    linear: (<__main__.NominalizerTerminal object at 0x10fc08908>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_6, triggers = set(), weight = 11.600000000000001..already existed

create_vi: tried nominalizer: null_7, triggers = {('i', frozenset({'-atomic'}))}, weight = 11.699999999999994..already existed

create_vi: tried nominalizer: null_26, triggers = {('e', frozenset({'-atomic'}))}, weight = 13.299999999999994..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_14, triggers = set(), weight = 13.9..already existed

create_vi: tried nominalizer: null_15, triggers = {('i', frozenset({'-atomic'}))}, weight = 11.899999999999993..already existed
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 55.40000000000037
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 60.100000000000406
VocabularyItem:
    pronunciation: CLOWN
    label: CLOWN
    values: set()
    diacritic: CLOWN_3
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 10.8
     what if we combine triggers with the otherwise identical vi CLOWN_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 20.99999999999985
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 27.400000000000027
line done
line done

---------------------

input line #406
input roots: [<__main__.Root object at 0x10fc180f0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 132.69999999999766..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 59.200000000000365..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 41.90000000000026..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 132.79999999999765..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 60.70000000000041..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 42.00000000000026..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 132.89999999999765..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: CASTLE in its selectional

now working with the word 'CASTLE-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'CASTLE_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi CASTLE_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_15', 'i_1', 'null_14', 'CASTLE_1', 'CASTLE_3'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4bcc0>, '-', <__main__.AgrTerminal object at 0x10fc356d8>, '#', <__main__.Root object at 0x10fc4b668>, '-', <__main__.NominalizerTerminal object at 0x10fc4ba20>, '-', <__main__.SemanticTerminal object at 0x10fc4b320>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'a_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CASTLE terminal with values set()
we picked CASTLE_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'i_2', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#CASTLE-i
full_pronunciation: li#CASTLEi
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CASTLE to the selectional of the nominalizer whose values are {'i_2', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'a_2'}
    selectional: {'BOOK', 'CHILD', 'BALL', 'FROG', 'PIBLING', 'FLOWER', 'GRANDPARENT', 'TOWER', 'CASTLE', 'CAR', 'KEY', 'CLOWN', 'FOOT', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 22.100000000000016
    linear: (<__main__.NominalizerTerminal object at 0x10fc36a90>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 132.89999999999765
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 42.00000000000026
VocabularyItem:
    pronunciation: CASTLE
    label: CASTLE
    values: set()
    diacritic: CASTLE_3
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.100000000000001
     what if we combine triggers with the otherwise identical vi CASTLE_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.49999999999985
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 25.20000000000003
line done
line done

---------------------

input line #407
input roots: [<__main__.Root object at 0x10fc4b400>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 133.49999999999764..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 41.300000000000274..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 60.80000000000041..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 133.59999999999764..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 60.90000000000041..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 56.00000000000037..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 133.69999999999763..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 133.79999999999762..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 42.600000000000264..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 61.00000000000041..already existed
  we're in a functional word...
  - nominalizer's values are now {'i_2', 'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: MOUSE in its selectional

now working with the word 'MOUSE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_18', 'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'MOUSE_1', 'null_18', 'o_1', 'null_12'}
     what if we combine triggers with the otherwise identical vi MOUSE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'o_1', 'MOUSE_2', 'MOUSE_1', 'null_18'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc36080>, '-', <__main__.AgrTerminal object at 0x10fc4b470>, '#', <__main__.Root object at 0x10fc6fa90>, '-', <__main__.NominalizerTerminal object at 0x10fc6f780>, '-', <__main__.SemanticTerminal object at 0x10fc6fba8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'i_2', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MOUSE terminal with values set()
we picked MOUSE_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'i_2', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: lo#MOUSE-o
full_pronunciation: lo#MOUSEo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: MOUSE to the selectional of the nominalizer whose values are {'i_2', 'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'o_2'}
    selectional: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'GRANDPARENT', 'CASTLE', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 28.200000000000067
    linear: (<__main__.NominalizerTerminal object at 0x10fc22eb8>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 133.79999999999762
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 61.00000000000041
VocabularyItem:
    pronunciation: MOUSE
    label: MOUSE
    values: set()
    diacritic: MOUSE_4
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 10.3
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 11.900000000000011
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 28.00000000000003
line done
line done

---------------------

input line #408
input roots: [<__main__.Root object at 0x10fc47e10>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 134.39999999999762..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 41.400000000000276..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 61.60000000000041..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 134.4999999999976..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 61.700000000000415..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 56.10000000000037..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 134.5999999999976..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 134.6999999999976..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 42.700000000000266..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 61.800000000000416..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: BOOK in its selectional

now working with the word 'BOOK-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'BOOK_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi BOOK_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'BOOK_1', 'BOOK_3'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6aa58>, '-', <__main__.AgrTerminal object at 0x10fc6f550>, '#', <__main__.Root object at 0x10fc6a1d0>, '-', <__main__.NominalizerTerminal object at 0x10fc6a748>, '-', <__main__.SemanticTerminal object at 0x10fc6a8d0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BOOK terminal with values set()
we picked BOOK_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'a_2'}
we picked null_6 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: lo#BOOK-o
full_pronunciation: la#BOOKo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 134.6999999999976
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 59.200000000000365
VocabularyItem:
    pronunciation: BOOK
    label: BOOK
    values: set()
    diacritic: BOOK_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.600000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_6
    triggers: set()
    weight: 11.600000000000001
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 28.60000000000003
line done
line done

---------------------

input line #409
input roots: [<__main__.Root object at 0x10fc47fd0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 134.6999999999976..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 41.50000000000028..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 59.200000000000365..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 134.7999999999976..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 59.30000000000037..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 56.20000000000037..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 134.8999999999976..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 134.99999999999758..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 42.80000000000027..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 59.40000000000037..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_2', 'a_1', 'PIBLING_1', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6f3c8>, '-', <__main__.AgrTerminal object at 0x10fc58ac8>, '#', <__main__.Root object at 0x10fc6fba8>, '-', <__main__.NominalizerTerminal object at 0x10fc6f780>, '-', <__main__.SemanticTerminal object at 0x10fc6fcf8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_8: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#PIBLING-a
full_pronunciation: lo#PIBLINGa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 134.99999999999758
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 61.800000000000416
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_8
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.99999999999985
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 29.900000000000034
line done
line done

---------------------

input line #410
input roots: [<__main__.Root object at 0x10fc6f198>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 134.99999999999758..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 41.60000000000028..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 59.50000000000037..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 135.09999999999758..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 59.60000000000037..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 56.300000000000374..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 135.19999999999757..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 135.29999999999757..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 42.90000000000027..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 59.70000000000037..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: MILKCOW in its selectional

now working with the word 'MILKCOW-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'MILKCOW_1'}
     what if we combine triggers with the otherwise identical vi MILKCOW_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'MILKCOW_1', 'MILKCOW_2', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b588>, '-', <__main__.AgrTerminal object at 0x10fc6fd30>, '#', <__main__.Root object at 0x10fc4b7b8>, '-', <__main__.NominalizerTerminal object at 0x10fc4bfd0>, '-', <__main__.SemanticTerminal object at 0x10fc4b518>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'i_2', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MILKCOW terminal with values set()
we picked MILKCOW_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a', 'i_2', 'a_2'}
we picked null_24 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#MILKCOW-a
full_pronunciation: la#MILKCOWa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: MILKCOW to the selectional of the nominalizer whose values are {'i_2', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'a_2'}
    selectional: {'BOOK', 'CHILD', 'BALL', 'FROG', 'PIBLING', 'FLOWER', 'GRANDPARENT', 'TOWER', 'CASTLE', 'CAR', 'KEY', 'CLOWN', 'FOOT', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 22.30000000000002
    linear: (<__main__.NominalizerTerminal object at 0x10fc36a90>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 135.29999999999757
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 59.70000000000037
VocabularyItem:
    pronunciation: MILKCOW
    label: MILKCOW
    values: set()
    diacritic: MILKCOW_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2', 'a_2'}
    diacritic: null_24
    triggers: set()
    weight: 12.2
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 29.900000000000034
line done
line done

---------------------

input line #411
input roots: [<__main__.Root object at 0x10fc4ba58>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 135.89999999999756..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 60.300000000000374..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 43.00000000000027..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 135.99999999999756..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 61.800000000000416..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 43.10000000000027..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 136.09999999999755..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: MOUSE in its selectional

now working with the word 'MOUSE-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'MOUSE_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi MOUSE_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'MOUSE_3', 'null_15', 'MOUSE_1', 'i_1', 'null_14'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4bba8>, '#', <__main__.Root object at 0x10fc184e0>, '-', <__main__.NominalizerTerminal object at 0x10fc47080>, '-', <__main__.SemanticTerminal object at 0x10fc47240>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked le_1: no super match (neither decl nor L1-gender)
now spelling out MOUSE terminal with values set()
we picked MOUSE_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o_2'}
we picked null_19: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: li#MOUSE-i
full_pronunciation: le#MOUSEe
vis_used:
Failure
VocabularyItem:
    pronunciation: le
    label: definite
    values: {'+definite', '-atomic'}
    diacritic: le_1
    triggers: set()
    weight: 11.000000000000002
VocabularyItem:
    pronunciation: MOUSE
    label: MOUSE
    values: set()
    diacritic: MOUSE_1
    triggers: set()
    weight: 9.500000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_19
    triggers: {('e', frozenset({'+atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 15.7
line done
line done

---------------------

input line #412
input roots: [<__main__.Root object at 0x10fc47da0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 61.90000000000042..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 136.19999999999754..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 56.400000000000375..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 56.50000000000038..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'PIBLING_1', 'o_1', 'PIBLING_5'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc22940>, '-', <__main__.AgrTerminal object at 0x10fc58c88>, '#', <__main__.Root object at 0x10fc2f7f0>, '-', <__main__.NominalizerTerminal object at 0x10fc20ef0>, '-', <__main__.SemanticTerminal object at 0x10fc281d0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_5: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: uno#PIBLING-o
full_pronunciation: una#PIBLINGo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 56.50000000000038
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 60.300000000000374
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_5
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 10.000000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.89999999999985
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 28.60000000000003
line done
line done

---------------------

input line #413
input roots: [<__main__.Root object at 0x10fc47cf8>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 136.29999999999754..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 60.300000000000374..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 41.70000000000028..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 136.39999999999753..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 62.00000000000042..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 41.80000000000028..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 136.49999999999753..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: FROG in its selectional

now working with the word 'FROG-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'null_17'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_1', 'e_2', 'null_16', 'null_17'}
     what if we combine triggers with the otherwise identical vi FROG_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'FROG_1', 'FROG_3', 'null_17'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc08400>, '#', <__main__.Root object at 0x10fc86e80>, '-', <__main__.NominalizerTerminal object at 0x10fc86080>, '-', <__main__.SemanticTerminal object at 0x10fc867b8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out FROG terminal with values set()
we picked FROG_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: le#FROG-e
full_pronunciation: l#FROGe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 136.49999999999753
VocabularyItem:
    pronunciation: FROG
    label: FROG
    values: set()
    diacritic: FROG_2
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 11.4
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 12.400000000000011
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 15.7
line done
line done

---------------------

input line #414
input roots: [<__main__.Root object at 0x10fc86d68>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 136.49999999999753..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 41.90000000000028..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 62.10000000000042..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 136.59999999999752..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 62.20000000000042..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 56.50000000000038..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 136.69999999999752..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 136.7999999999975..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 43.20000000000027..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 62.30000000000042..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FOOT in its selectional

now working with the word 'FOOT-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FOOT_1', 'null_8', 'e_3', 'null_19'}
     what if we combine triggers with the otherwise identical vi FOOT_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FOOT_1', 'e_3', 'FOOT_2', 'null_19'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a2b0>, '-', <__main__.AgrTerminal object at 0x10fc86358>, '#', <__main__.Root object at 0x10fc6a668>, '-', <__main__.NominalizerTerminal object at 0x10fc6a3c8>, '-', <__main__.SemanticTerminal object at 0x10fc6a2e8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FOOT terminal with values set()
we picked FOOT_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: lo#FOOT-e
full_pronunciation: la#FOOTa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 136.7999999999975
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 60.300000000000374
VocabularyItem:
    pronunciation: FOOT
    label: FOOT
    values: set()
    diacritic: FOOT_3
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.900000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 11.70000000000001
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 30.400000000000034
line done
line done

---------------------

input line #415
input roots: [<__main__.Root object at 0x10fc868d0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 60.300000000000374..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 136.7999999999975..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 56.60000000000038..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 56.70000000000038..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'GRANDPARENT_1'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'GRANDPARENT_1', 'null_11', 'null_10', 'GRANDPARENT_3'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc454a8>, '-', <__main__.AgrTerminal object at 0x10fc47ef0>, '#', <__main__.Root object at 0x10fc509e8>, '-', <__main__.NominalizerTerminal object at 0x10fc50358>, '-', <__main__.SemanticTerminal object at 0x10fc43278>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_9: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'a_2', 'a'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: una#GRANDPARENT-a
full_pronunciation: una#GRANDPARENTa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: GRANDPARENT to the selectional of the nominalizer whose values are {'e_1', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1', 'a_2'}
    selectional: {'FROG', 'BALL', 'CHILD', 'TOWER', 'PIBLING', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 26.800000000000058
    linear: (<__main__.NominalizerTerminal object at 0x10fc2aa20>,)
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 56.70000000000038
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 60.300000000000374
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_9
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 11.60000000000001
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 30.400000000000034
line done
line done

---------------------

input line #416
input roots: [<__main__.Root object at 0x10fc6a940>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 136.8999999999975..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 42.000000000000284..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 62.400000000000425..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 136.9999999999975..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 62.500000000000426..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 57.30000000000038..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 137.0999999999975..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 137.1999999999975..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 43.300000000000274..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 62.60000000000043..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CLOWN in its selectional

now working with the word 'CLOWN-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CLOWN_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CLOWN_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'CLOWN_3', 'o_1', 'CLOWN_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc96470>, '-', <__main__.AgrTerminal object at 0x10fc67160>, '#', <__main__.Root object at 0x10fc3eb00>, '-', <__main__.NominalizerTerminal object at 0x10fc96630>, '-', <__main__.SemanticTerminal object at 0x10fc96550>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CLOWN terminal with values set()
we picked CLOWN_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: lo#CLOWN-o
full_pronunciation: la#CLOWNo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 137.1999999999975
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 60.800000000000374
VocabularyItem:
    pronunciation: CLOWN
    label: CLOWN
    values: set()
    diacritic: CLOWN_3
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 11.3
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.799999999999848
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 28.60000000000003
line done
line done

---------------------

input line #417
input roots: [<__main__.Root object at 0x10fc3e2b0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 137.1999999999975..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 60.800000000000374..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 42.100000000000286..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 137.29999999999748..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 62.70000000000043..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 42.20000000000029..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 137.39999999999748..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'o_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'o_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_20'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_20', 'null_31'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'OFFSPRING_1', 'null_20', 'null_31'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_5 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_20', 'OFFSPRING_7', 'OFFSPRING_1', 'null_31'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a748>, '-', <__main__.AgrTerminal object at 0x10fc18588>, '#', <__main__.Root object at 0x10fc6a908>, '-', <__main__.NominalizerTerminal object at 0x10fc6ada0>, '-', <__main__.SemanticTerminal object at 0x10fc6ab70>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic', 'a_2'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_9: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e', 'e_1', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: le#OFFSPRING-e
full_pronunciation: le#OFFSPRINGe
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: OFFSPRING to the selectional of the nominalizer whose values are {'e_1', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1', 'a_2'}
    selectional: {'FROG', 'BALL', 'CHILD', 'TOWER', 'PIBLING', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 27.00000000000006
    linear: (<__main__.NominalizerTerminal object at 0x10fc2aa20>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 137.39999999999748
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 42.20000000000029
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_9
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 9.600000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.699999999999847
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 15.7
line done
line done

---------------------

input line #418
input roots: [<__main__.Root object at 0x10fc18828>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 137.99999999999747..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 42.80000000000029..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 60.900000000000375..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 138.09999999999746..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 61.00000000000038..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 57.40000000000038..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 138.19999999999746..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 138.29999999999745..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 43.400000000000276..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 61.10000000000038..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: BALL in its selectional

now working with the word 'BALL-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'BALL_1', 'a_1'}
     what if we combine triggers with the otherwise identical vi BALL_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'BALL_1', 'BALL_2', 'null_10', 'null_11'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6aac8>, '-', <__main__.AgrTerminal object at 0x10fc6aa58>, '#', <__main__.Root object at 0x10fc38390>, '-', <__main__.NominalizerTerminal object at 0x10fc38908>, '-', <__main__.SemanticTerminal object at 0x10fc6ae10>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BALL terminal with values set()
we picked BALL_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'a_2'}
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: la#BALL-a
full_pronunciation: la#BALLo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 138.29999999999745
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 61.10000000000038
VocabularyItem:
    pronunciation: BALL
    label: BALL
    values: set()
    diacritic: BALL_1
    triggers: set()
    weight: 10.200000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 22.199999999999847
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 28.50000000000003
line done
line done

---------------------

input line #419
input roots: [<__main__.Root object at 0x10fc6aa20>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 138.29999999999745..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 61.10000000000038..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 42.90000000000029..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 138.39999999999745..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 62.80000000000043..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 43.00000000000029..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 138.49999999999744..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'o_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'o_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_20'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_20', 'null_31'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_20', 'CHILD_1', 'null_31'}
     what if we combine triggers with the otherwise identical vi CHILD_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_20', 'CHILD_1', 'CHILD_7', 'null_31'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50438>, '#', <__main__.Root object at 0x10fc50160>, '-', <__main__.NominalizerTerminal object at 0x10fc50a90>, '-', <__main__.SemanticTerminal object at 0x10fc50a58>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out CHILD terminal with values set()
we picked CHILD_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o_2'}
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: le#CHILD-e
full_pronunciation: l#CHILDe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 138.49999999999744
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_1
    triggers: set()
    weight: 9.400000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 22.099999999999845
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 16.3
line done
line done

---------------------

input line #420
input roots: [<__main__.Root object at 0x10fc50f98>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 62.90000000000043..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 138.49999999999744..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 57.500000000000384..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 57.600000000000385..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CHILD_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'CHILD_1', 'null_9', 'o_1', 'CHILD_3'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc05630>, '-', <__main__.AgrTerminal object at 0x10fc502e8>, '#', <__main__.Root object at 0x10fc43198>, '-', <__main__.NominalizerTerminal object at 0x10fc433c8>, '-', <__main__.SemanticTerminal object at 0x10fc05e80>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_5: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'a_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: uno#CHILD-o
full_pronunciation: una#CHILDa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 57.600000000000385
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 61.10000000000038
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_5
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 11.0
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.999999999999844
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 31.000000000000036
line done
line done

---------------------

input line #421
input roots: [<__main__.Root object at 0x10fc50be0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 63.00000000000043..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 138.59999999999744..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 57.600000000000385..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 57.70000000000039..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CASTLE in its selectional

now working with the word 'CASTLE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CASTLE_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CASTLE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'CASTLE_2', 'o_1', 'CASTLE_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc2f048>, '#', <__main__.Root object at 0x10fc864e0>, '-', <__main__.NominalizerTerminal object at 0x10fc86940>, '-', <__main__.SemanticTerminal object at 0x10fc86668>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite', 'i_2', '+atomic'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out CASTLE terminal with values set()
we picked CASTLE_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'i_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: uno#CASTLE-o
full_pronunciation: un#CASTLEo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 57.70000000000039
VocabularyItem:
    pronunciation: CASTLE
    label: CASTLE
    values: set()
    diacritic: CASTLE_2
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 12.100000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.899999999999842
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 28.60000000000003
line done
line done

---------------------

input line #422
input roots: [<__main__.Root object at 0x10fc86470>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 138.69999999999743..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 61.10000000000038..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 43.10000000000029..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 138.79999999999742..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 63.100000000000435..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 43.200000000000294..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 138.89999999999742..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'o_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'o_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_20'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_20', 'null_31'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'e_2', 'null_20', 'null_31'}
     what if we combine triggers with the otherwise identical vi PIBLING_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_5 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_20', 'PIBLING_1', 'PIBLING_3', 'null_31'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc86198>, '-', <__main__.AgrTerminal object at 0x10fc86f28>, '#', <__main__.Root object at 0x10fc45358>, '-', <__main__.NominalizerTerminal object at 0x10fc45160>, '-', <__main__.SemanticTerminal object at 0x10fc453c8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic', 'o_2'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_5: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'o_2'}
we picked null_20 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: le#PIBLING-e
full_pronunciation: le#PIBLINGe
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: PIBLING to the selectional of the nominalizer whose values are {'e_1', 'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1', 'o_2'}
    selectional: {'BOOK', 'CHILD', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'CLOWN', 'OFFSPRING'}
    selection_strength: True
    weight: 22.20000000000001
    linear: (<__main__.NominalizerTerminal object at 0x10fc3d400>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 138.89999999999742
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 43.200000000000294
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_5
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 9.900000000000002
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1', 'o_2'}
    diacritic: null_20
    triggers: set()
    weight: 11.899999999999999
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 16.3
line done
line done

---------------------

input line #423
input roots: [<__main__.Root object at 0x10fc86748>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 139.4999999999974..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 61.20000000000038..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 43.800000000000296..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 139.5999999999974..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 63.200000000000436..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 43.9000000000003..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 139.6999999999974..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: TOWER in its selectional

now working with the word 'TOWER-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_6', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_6', 'null_7', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'TOWER_1', 'null_6', 'null_7', 'i_1'}
     what if we combine triggers with the otherwise identical vi TOWER_3 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'TOWER_1', 'null_7', 'i_1', 'TOWER_2', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc670b8>, '-', <__main__.AgrTerminal object at 0x10fc86978>, '#', <__main__.Root object at 0x10fc67e48>, '-', <__main__.NominalizerTerminal object at 0x10fc67278>, '-', <__main__.SemanticTerminal object at 0x10fc67d68>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic', 'a_2'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out TOWER terminal with values set()
we picked TOWER_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i', 'e_1', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: le#TOWER-i
full_pronunciation: le#TOWERi
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: TOWER to the selectional of the nominalizer whose values are {'e_1', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1', 'a_2'}
    selectional: {'FROG', 'BALL', 'CHILD', 'TOWER', 'PIBLING', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 27.200000000000063
    linear: (<__main__.NominalizerTerminal object at 0x10fc2aa20>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 139.6999999999974
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 43.9000000000003
VocabularyItem:
    pronunciation: TOWER
    label: TOWER
    values: set()
    diacritic: TOWER_4
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'})), ('e', frozenset({'+atomic'}))}
    weight: 10.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 12.10000000000001
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 25.900000000000034
line done
line done

---------------------

input line #424
input roots: [<__main__.Root object at 0x10fc42908>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 140.2999999999974..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 61.30000000000038..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 43.50000000000028..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 140.3999999999974..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 63.30000000000044..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 43.60000000000028..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 140.49999999999739..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: MOUSE in its selectional

now working with the word 'MOUSE-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'MOUSE_1', 'null_12', 'null_13', 'i_1'}
     what if we combine triggers with the otherwise identical vi MOUSE_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'MOUSE_3', 'null_12', 'null_13', 'i_1', 'MOUSE_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc45160>, '#', <__main__.Root object at 0x10fc86c18>, '-', <__main__.NominalizerTerminal object at 0x10fc86f28>, '-', <__main__.SemanticTerminal object at 0x10fc86128>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked li_1: no super match (neither decl nor L1-gender)
now spelling out MOUSE terminal with values set()
we picked MOUSE_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: li#MOUSE-i
full_pronunciation: li#MOUSEi
vis_used:
Successful derivation!
VocabularyItem:
    pronunciation: li
    label: definite
    values: {'+definite', '-atomic'}
    diacritic: li_1
    triggers: set()
    weight: 10.800000000000002
VocabularyItem:
    pronunciation: MOUSE
    label: MOUSE
    values: set()
    diacritic: MOUSE_2
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 10.100000000000001
     what if we combine triggers with the otherwise identical vi MOUSE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 12.300000000000011
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 26.500000000000036
line done
line done

---------------------

input line #425
input roots: [<__main__.Root object at 0x10fc86978>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 63.40000000000044..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 140.59999999999738..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 57.70000000000039..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 57.80000000000039..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'OFFSPRING_3', 'o_1', 'OFFSPRING_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc86198>, '#', <__main__.Root object at 0x10fc863c8>, '-', <__main__.NominalizerTerminal object at 0x10fc860f0>, '-', <__main__.SemanticTerminal object at 0x10fc86f98>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite', 'i_2', '+atomic'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'i_2'}
we picked null_14 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: uno#OFFSPRING-o
full_pronunciation: un#OFFSPRINGo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 57.80000000000039
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_4
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.4
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 13.9
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 28.60000000000003
line done
line done

---------------------

input line #426
input roots: [<__main__.Root object at 0x10fc86fd0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 140.69999999999737..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 44.5000000000003..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 63.50000000000044..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 140.79999999999737..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 63.60000000000044..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 57.80000000000039..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 140.89999999999736..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 140.99999999999736..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 43.70000000000028..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 63.70000000000044..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CHILD_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'CHILD_1', 'null_9', 'o_1', 'CHILD_3'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc2db70>, '-', <__main__.AgrTerminal object at 0x10fc86e80>, '#', <__main__.Root object at 0x10fc2dc88>, '-', <__main__.NominalizerTerminal object at 0x10fc2dc50>, '-', <__main__.SemanticTerminal object at 0x10fc2dbe0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_6: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: lo#CHILD-o
full_pronunciation: lo#CHILDo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CHILD to the selectional of the nominalizer whose values are {'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'o_2'}
    selectional: {'MOUSE', 'CHILD', 'BOOK', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 69.60000000000034
    linear: (<__main__.NominalizerTerminal object at 0x10fc08908>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_6, triggers = set(), weight = 11.600000000000001..already existed

create_vi: tried nominalizer: null_7, triggers = {('i', frozenset({'-atomic'}))}, weight = 11.799999999999994..already existed

create_vi: tried nominalizer: null_26, triggers = {('e', frozenset({'-atomic'}))}, weight = 13.399999999999993..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_14, triggers = set(), weight = 13.9..already existed

create_vi: tried nominalizer: null_15, triggers = {('i', frozenset({'-atomic'}))}, weight = 11.999999999999993..already existed
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 140.99999999999736
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 63.70000000000044
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_6
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 10.4
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 21.79999999999984
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 28.60000000000003
line done
line done

---------------------

input line #427
input roots: [<__main__.Root object at 0x10fc05320>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 141.59999999999735..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 44.6000000000003..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 61.40000000000038..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 141.69999999999735..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 61.500000000000384..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 57.90000000000039..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 141.79999999999734..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 141.89999999999733..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 43.80000000000028..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 61.600000000000385..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: TOWER in its selectional

now working with the word 'TOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'TOWER_1', 'e_3', 'null_10'}
     what if we combine triggers with the otherwise identical vi TOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'TOWER_1', 'TOWER_3', 'e_3', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50e80>, '-', <__main__.AgrTerminal object at 0x10fc2d6d8>, '#', <__main__.Root object at 0x10fc31e10>, '-', <__main__.NominalizerTerminal object at 0x10fc38470>, '-', <__main__.SemanticTerminal object at 0x10fc50b38>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out TOWER terminal with values set()
we picked TOWER_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e', 'e_1', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: la#TOWER-e
full_pronunciation: lo#TOWERe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 141.89999999999733
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 64.20000000000044
VocabularyItem:
    pronunciation: TOWER
    label: TOWER
    values: set()
    diacritic: TOWER_4
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'})), ('e', frozenset({'+atomic'}))}
    weight: 11.3
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 22.29999999999984
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 17.200000000000003
line done
line done

---------------------

input line #428
input roots: [<__main__.Root object at 0x10fc42b00>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 141.89999999999733..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 44.7000000000003..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 61.70000000000039..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 141.99999999999733..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 61.80000000000039..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 58.00000000000039..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 142.09999999999732..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 142.19999999999732..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 43.90000000000028..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 61.90000000000039..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_2', 'a_1', 'PIBLING_1', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a080>, '-', <__main__.AgrTerminal object at 0x10fc6a438>, '#', <__main__.Root object at 0x10fc6a4a8>, '-', <__main__.NominalizerTerminal object at 0x10fc6a048>, '-', <__main__.SemanticTerminal object at 0x10fc6a3c8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'a_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#PIBLING-a
full_pronunciation: la#PIBLINGa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: PIBLING to the selectional of the nominalizer whose values are {'e_1', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1', 'a_2'}
    selectional: {'FROG', 'BALL', 'CHILD', 'TOWER', 'PIBLING', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 27.400000000000066
    linear: (<__main__.NominalizerTerminal object at 0x10fc2aa20>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 142.19999999999732
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 61.90000000000039
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_2
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 10.3
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 22.19999999999984
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 31.000000000000036
line done
line done

---------------------

input line #429
input roots: [<__main__.Root object at 0x10fc6a2b0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 62.50000000000039..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 142.7999999999973..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 58.10000000000039..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 58.200000000000394..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: FROG in its selectional

now working with the word 'FROG-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi FROG_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_2', 'a_1', 'FROG_1', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6ae10>, '#', <__main__.Root object at 0x10fc3bf28>, '-', <__main__.NominalizerTerminal object at 0x10fc185c0>, '-', <__main__.SemanticTerminal object at 0x10fc18320>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite', '+atomic'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out FROG terminal with values set()
we picked FROG_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: una#FROG-a
full_pronunciation: un#FROGe
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 58.200000000000394
VocabularyItem:
    pronunciation: FROG
    label: FROG
    values: set()
    diacritic: FROG_3
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 9.500000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 22.69999999999984
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 17.1
line done
line done

---------------------

input line #430
input roots: [<__main__.Root object at 0x10fc6a198>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 142.8999999999973..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 44.8000000000003..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 62.60000000000039..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 142.9999999999973..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 62.700000000000394..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 58.200000000000394..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 143.0999999999973..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 143.1999999999973..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 44.000000000000284..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 62.800000000000395..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: KEY in its selectional

now working with the word 'KEY-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'KEY_1', 'null_10'}
     what if we combine triggers with the otherwise identical vi KEY_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'KEY_3', 'KEY_1', 'e_3', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc35a90>, '#', <__main__.Root object at 0x10fc3ecf8>, '-', <__main__.NominalizerTerminal object at 0x10fc3eac8>, '-', <__main__.SemanticTerminal object at 0x10fc41cf8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '+atomic', 'i_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out KEY terminal with values set()
we picked KEY_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'i_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: la#KEY-e
full_pronunciation: l#KEYe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 143.1999999999973
VocabularyItem:
    pronunciation: KEY
    label: KEY
    values: set()
    diacritic: KEY_3
    triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))}
    weight: 9.500000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 22.599999999999838
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 17.1
line done
line done

---------------------

input line #431
input roots: [<__main__.Root object at 0x10fc41eb8>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 143.1999999999973..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 62.9000000000004..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 44.900000000000304..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 143.29999999999728..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 64.20000000000044..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 45.000000000000306..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 143.39999999999728..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: TOWER in its selectional

now working with the word 'TOWER-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'null_32', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'TOWER_1', 'null_16', 'null_32', 'i_1'}
     what if we combine triggers with the otherwise identical vi TOWER_3 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'TOWER_1', 'null_16', 'null_32', 'i_1', 'TOWER_2'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67908>, '#', <__main__.Root object at 0x10fc6f198>, '-', <__main__.NominalizerTerminal object at 0x10fc6f160>, '-', <__main__.SemanticTerminal object at 0x10fc6f940>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out TOWER terminal with values set()
we picked TOWER_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: le#TOWER-i
full_pronunciation: l#TOWERi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 143.39999999999728
VocabularyItem:
    pronunciation: TOWER
    label: TOWER
    values: set()
    diacritic: TOWER_3
    triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))}
    weight: 11.200000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 22.499999999999837
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 27.100000000000037
line done
line done

---------------------

input line #432
input roots: [<__main__.Root object at 0x10fc3eb00>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 64.30000000000044..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 143.39999999999728..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 58.300000000000395..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 58.4000000000004..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: BOOK in its selectional

now working with the word 'BOOK-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'BOOK_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi BOOK_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'BOOK_1', 'BOOK_3'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc18160>, '-', <__main__.AgrTerminal object at 0x10fc3e898>, '#', <__main__.Root object at 0x10fc14668>, '-', <__main__.NominalizerTerminal object at 0x10fc18748>, '-', <__main__.SemanticTerminal object at 0x10fc18320>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BOOK terminal with values set()
we picked BOOK_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: uno#BOOK-o
full_pronunciation: una#BOOKo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 58.4000000000004
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 62.9000000000004
VocabularyItem:
    pronunciation: BOOK
    label: BOOK
    values: set()
    diacritic: BOOK_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.500000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 12.60000000000001
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 29.20000000000003
line done
line done

---------------------

input line #433
input roots: [<__main__.Root object at 0x10fc3bf28>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 143.49999999999727..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 45.10000000000031..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 64.40000000000043..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 143.59999999999727..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 64.50000000000043..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 58.4000000000004..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 143.69999999999726..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 143.79999999999725..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 44.100000000000286..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 64.60000000000042..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FLOWER in its selectional

now working with the word 'FLOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19', 'FLOWER_1'}
     what if we combine triggers with the otherwise identical vi FLOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FLOWER_3', 'e_3', 'null_19', 'FLOWER_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6af28>, '-', <__main__.AgrTerminal object at 0x10fc184e0>, '#', <__main__.Root object at 0x10fc6acf8>, '-', <__main__.NominalizerTerminal object at 0x10fc6aa20>, '-', <__main__.SemanticTerminal object at 0x10fc6a7f0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FLOWER terminal with values set()
we picked FLOWER_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: lo#FLOWER-e
full_pronunciation: la#FLOWERe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 143.79999999999725
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 62.800000000000395
VocabularyItem:
    pronunciation: FLOWER
    label: FLOWER
    values: set()
    diacritic: FLOWER_3
    triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))}
    weight: 10.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 12.50000000000001
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 17.1
line done
line done

---------------------

input line #434
input roots: [<__main__.Root object at 0x10fc6aba8>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 62.800000000000395..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 143.79999999999725..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 58.5000000000004..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 58.6000000000004..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1', 'e_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: MILKCOW in its selectional

now working with the word 'MILKCOW-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'null_27', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'null_27', 'a_1', 'MILKCOW_1'}
     what if we combine triggers with the otherwise identical vi MILKCOW_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'null_16', 'MILKCOW_1', 'null_27', 'MILKCOW_2'}
done processing input, time to test
we selected the nominalizer with values: {'e_1'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a630>, '#', <__main__.Root object at 0x10fc50e80>, '-', <__main__.NominalizerTerminal object at 0x10fc50b38>, '-', <__main__.SemanticTerminal object at 0x10fc50828>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'e_1', '-definite', '+atomic'}
we picked una_1: no super match (neither decl nor L1-gender)
now spelling out MILKCOW terminal with values set()
we picked MILKCOW_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1'}
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: una#MILKCOW-a
full_pronunciation: una#MILKCOWa
vis_used:
Successful derivation!
VocabularyItem:
    pronunciation: una
    label: definite
    values: {'-definite', '+atomic'}
    diacritic: una_1
    triggers: set()
    weight: 10.800000000000002
VocabularyItem:
    pronunciation: MILKCOW
    label: MILKCOW
    values: set()
    diacritic: MILKCOW_1
    triggers: set()
    weight: 10.500000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 22.399999999999835
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 31.70000000000004
line done
line done

---------------------

input line #435
input roots: [<__main__.Root object at 0x10fc50128>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 62.9000000000004..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 143.89999999999725..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 58.7000000000004..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 58.8000000000004..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: TOWER in its selectional

now working with the word 'TOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'TOWER_1', 'e_3', 'null_10'}
     what if we combine triggers with the otherwise identical vi TOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'TOWER_1', 'TOWER_3', 'e_3', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc2dd68>, '-', <__main__.AgrTerminal object at 0x10fc509e8>, '#', <__main__.Root object at 0x10fc43198>, '-', <__main__.NominalizerTerminal object at 0x10fc05550>, '-', <__main__.SemanticTerminal object at 0x10fc05668>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out TOWER terminal with values set()
we picked TOWER_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: una#TOWER-e
full_pronunciation: una#TOWERe
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: TOWER to the selectional of the nominalizer whose values are {'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'a_2'}
    selectional: {'FROG', 'CHILD', 'BALL', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 66.10000000000053
    linear: (<__main__.NominalizerTerminal object at 0x10fc05f28>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'FROG', 'BALL', 'CHILD', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_6, triggers = set(), weight = 11.700000000000001..already existed

create_vi: tried nominalizer: null_7, triggers = {('i', frozenset({'-atomic'}))}, weight = 11.899999999999993..already existed

create_vi: tried nominalizer: null_26, triggers = {('e', frozenset({'-atomic'}))}, weight = 13.499999999999993..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_14, triggers = set(), weight = 14.0..already existed

create_vi: tried nominalizer: null_15, triggers = {('i', frozenset({'-atomic'}))}, weight = 12.099999999999993..already existed
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 58.8000000000004
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 62.9000000000004
VocabularyItem:
    pronunciation: TOWER
    label: TOWER
    values: set()
    diacritic: TOWER_3
    triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))}
    weight: 11.100000000000001
     what if we combine triggers with the otherwise identical vi TOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 22.899999999999835
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 17.1
line done
line done

---------------------

input line #436
input roots: [<__main__.Root object at 0x10fc502e8>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 64.70000000000041..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 143.99999999999724..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 59.400000000000404..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 59.500000000000405..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CLOWN in its selectional

now working with the word 'CLOWN-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CLOWN_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CLOWN_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'CLOWN_3', 'o_1', 'CLOWN_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67828>, '-', <__main__.AgrTerminal object at 0x10fc436a0>, '#', <__main__.Root object at 0x10fc86cf8>, '-', <__main__.NominalizerTerminal object at 0x10fc86e48>, '-', <__main__.SemanticTerminal object at 0x10fc67ac8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CLOWN terminal with values set()
we picked CLOWN_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'i_2', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: uno#CLOWN-o
full_pronunciation: uno#CLOWNo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CLOWN to the selectional of the nominalizer whose values are {'i_2', 'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'o_2'}
    selectional: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'GRANDPARENT', 'CASTLE', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 29.100000000000072
    linear: (<__main__.NominalizerTerminal object at 0x10fc22eb8>,)
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 59.500000000000405
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 64.70000000000041
VocabularyItem:
    pronunciation: CLOWN
    label: CLOWN
    values: set()
    diacritic: CLOWN_3
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 11.200000000000001
     what if we combine triggers with the otherwise identical vi CLOWN_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 12.800000000000011
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 29.20000000000003
line done
line done

---------------------

input line #437
input roots: [<__main__.Root object at 0x10fc676a0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 65.30000000000041..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 144.09999999999724..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 60.100000000000406..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 60.20000000000041..already existed
  we're in a functional word...
  - nominalizer's values are now {'e_1', 'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'o_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_20'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_20', 'null_21'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'o_1', 'null_20', 'null_21'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_20', 'OFFSPRING_3', 'o_1', 'null_21', 'OFFSPRING_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc865f8>, '-', <__main__.AgrTerminal object at 0x10fc86dd8>, '#', <__main__.Root object at 0x10fc864a8>, '-', <__main__.NominalizerTerminal object at 0x10fc86128>, '-', <__main__.SemanticTerminal object at 0x10fc86c18>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: uno#OFFSPRING-o
full_pronunciation: una#OFFSPRINGo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 60.20000000000041
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 63.4000000000004
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_4
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.3
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 12.400000000000011
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 29.800000000000033
line done
line done

---------------------

input line #438
input roots: [<__main__.Root object at 0x10fc86710>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 144.19999999999723..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 45.20000000000031..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 65.4000000000004..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 144.29999999999723..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 65.5000000000004..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 60.20000000000041..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 144.39999999999722..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 144.49999999999721..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 44.20000000000029..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 65.60000000000039..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: MOUSE in its selectional

now working with the word 'MOUSE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'MOUSE_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi MOUSE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'MOUSE_2', 'MOUSE_1'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc86978>, '#', <__main__.Root object at 0x10fc6f080>, '-', <__main__.NominalizerTerminal object at 0x10fc6fa58>, '-', <__main__.SemanticTerminal object at 0x10fc42710>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '+atomic'}
we picked lo_1: no super match (neither decl nor L1-gender)
now spelling out MOUSE terminal with values set()
we picked MOUSE_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values set()
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: lo#MOUSE-o
full_pronunciation: lo#MOUSEa
vis_used:
Failure
VocabularyItem:
    pronunciation: lo
    label: definite
    values: {'+definite', '+atomic'}
    diacritic: lo_1
    triggers: set()
    weight: 10.600000000000001
VocabularyItem:
    pronunciation: MOUSE
    label: MOUSE
    values: set()
    diacritic: MOUSE_1
    triggers: set()
    weight: 9.400000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 23.399999999999835
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 32.20000000000004
line done
line done

---------------------

input line #439
input roots: [<__main__.Root object at 0x10fc42a20>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 144.5999999999972..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 63.4000000000004..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 45.30000000000031..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 144.6999999999972..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 65.70000000000039..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 45.40000000000031..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 144.7999999999972..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'OFFSPRING_1', 'null_6'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_5 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'OFFSPRING_1', 'OFFSPRING_7', 'null_26', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6f0b8>, '#', <__main__.Root object at 0x10fc45080>, '-', <__main__.NominalizerTerminal object at 0x10fc453c8>, '-', <__main__.SemanticTerminal object at 0x10fc42128>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: le#OFFSPRING-e
full_pronunciation: l#OFFSPRINGi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 144.7999999999972
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 13.300000000000011
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 27.000000000000036
line done
line done

---------------------

input line #440
input roots: [<__main__.Root object at 0x10fc450f0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 144.7999999999972..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 63.5000000000004..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 44.30000000000029..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 144.8999999999972..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 65.80000000000038..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 44.40000000000029..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 144.9999999999972..already existed
  we're in a functional word...
  - nominalizer's values are now {'a_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'a_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_24', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_24', 'i_1', 'null_28'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_24', 'i_1', 'null_28'}
     what if we combine triggers with the otherwise identical vi PIBLING_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_5 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_28', 'PIBLING_7', 'PIBLING_1', 'null_24', 'i_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc86390>, '#', <__main__.Root object at 0x10fc86160>, '-', <__main__.NominalizerTerminal object at 0x10fc86ba8>, '-', <__main__.SemanticTerminal object at 0x10fc86358>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out PIBLING terminal with values set()
we picked PIBLING_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: li#PIBLING-i
full_pronunciation: l#PIBLINGi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 144.9999999999972
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_2
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 10.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 23.299999999999834
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 27.000000000000036
line done
line done

---------------------

input line #441
input roots: [<__main__.Root object at 0x10fc86da0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 144.9999999999972..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 45.50000000000031..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 65.90000000000038..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 145.09999999999718..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 66.00000000000037..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 60.30000000000041..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 145.19999999999717..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 145.29999999999717..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 44.50000000000029..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 66.10000000000036..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CASTLE in its selectional

now working with the word 'CASTLE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CASTLE_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CASTLE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'CASTLE_2', 'o_1', 'CASTLE_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc10780>, '-', <__main__.AgrTerminal object at 0x10fc863c8>, '#', <__main__.Root object at 0x10fc43438>, '-', <__main__.NominalizerTerminal object at 0x10fc436a0>, '-', <__main__.SemanticTerminal object at 0x10fc3c748>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CASTLE terminal with values set()
we picked CASTLE_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'o_2', 'o'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: lo#CASTLE-o
full_pronunciation: lo#CASTLEo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CASTLE to the selectional of the nominalizer whose values are {'e_1', 'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1', 'o_2'}
    selectional: {'BOOK', 'CHILD', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'CLOWN', 'OFFSPRING'}
    selection_strength: True
    weight: 23.000000000000014
    linear: (<__main__.NominalizerTerminal object at 0x10fc3d400>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 145.29999999999717
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 66.10000000000036
VocabularyItem:
    pronunciation: CASTLE
    label: CASTLE
    values: set()
    diacritic: CASTLE_4
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 23.199999999999832
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 29.900000000000034
line done
line done

---------------------

input line #442
input roots: [<__main__.Root object at 0x10fc45e80>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 63.6000000000004..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 145.89999999999716..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 60.40000000000041..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 60.50000000000041..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: CAR in its selectional

now working with the word 'CAR-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'CAR_1'}
     what if we combine triggers with the otherwise identical vi CAR_2 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'null_10', 'CAR_1', 'null_11', 'CAR_3'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50c88>, '-', <__main__.AgrTerminal object at 0x10fc05668>, '#', <__main__.Root object at 0x10fc50748>, '-', <__main__.NominalizerTerminal object at 0x10fc50be0>, '-', <__main__.SemanticTerminal object at 0x10fc502e8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CAR terminal with values set()
we picked CAR_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'o_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: una#CAR-a
full_pronunciation: uno#CARa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 60.50000000000041
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 66.60000000000036
VocabularyItem:
    pronunciation: CAR
    label: CAR
    values: set()
    diacritic: CAR_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 23.699999999999832
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 32.20000000000004
line done
line done

---------------------

input line #443
input roots: [<__main__.Root object at 0x10fc43e48>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 145.99999999999716..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 45.600000000000314..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 63.7000000000004..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 146.09999999999715..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 63.8000000000004..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 60.50000000000041..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 146.19999999999715..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 146.29999999999714..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 44.60000000000029..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 63.900000000000404..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1', 'e_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'null_27', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_16', 'null_27', 'a_1'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_2', 'a_1', 'null_16', 'PIBLING_1', 'null_27'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a9e8>, '-', <__main__.AgrTerminal object at 0x10fc2db70>, '#', <__main__.Root object at 0x10fc6a6a0>, '-', <__main__.NominalizerTerminal object at 0x10fc6a470>, '-', <__main__.SemanticTerminal object at 0x10fc6a080>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_8: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'a_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#PIBLING-a
full_pronunciation: la#PIBLINGa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: PIBLING to the selectional of the nominalizer whose values are {'e_1', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1', 'a_2'}
    selectional: {'FROG', 'BALL', 'CHILD', 'TOWER', 'PIBLING', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 28.500000000000075
    linear: (<__main__.NominalizerTerminal object at 0x10fc2aa20>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 146.29999999999714
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 63.900000000000404
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_8
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 23.59999999999983
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 32.20000000000004
line done
line done

---------------------

input line #444
input roots: [<__main__.Root object at 0x10fc506a0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 146.89999999999714..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 64.5000000000004..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 44.700000000000294..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 146.99999999999713..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 66.60000000000036..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 44.800000000000296..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 147.09999999999712..already existed
  we're in a functional word...
  - nominalizer's values are now {'a_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'a_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_24', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_24', 'i_1', 'null_28'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'GRANDPARENT_1', 'null_24', 'i_1', 'null_28'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_3 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_28', 'null_24', 'i_1', 'GRANDPARENT_4', 'GRANDPARENT_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6ac88>, '-', <__main__.AgrTerminal object at 0x10fc6a550>, '#', <__main__.Root object at 0x10fc2f128>, '-', <__main__.NominalizerTerminal object at 0x10fc6a278>, '-', <__main__.SemanticTerminal object at 0x10fc6add8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'o_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'i_2', 'o_2'}
we picked null_12 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#GRANDPARENT-i
full_pronunciation: li#GRANDPARENTi
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: GRANDPARENT to the selectional of the nominalizer whose values are {'i_2', 'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'o_2'}
    selectional: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'GRANDPARENT', 'CASTLE', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 29.300000000000075
    linear: (<__main__.NominalizerTerminal object at 0x10fc22eb8>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 147.09999999999712
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 44.800000000000296
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_4
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.000000000000002
     what if we combine triggers with the otherwise identical vi GRANDPARENT_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_3 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2', 'o_2'}
    diacritic: null_12
    triggers: set()
    weight: 11.599999999999998
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 27.000000000000036
line done
line done

---------------------

input line #445
input roots: [<__main__.Root object at 0x10fc6a4a8>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 66.70000000000036..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 147.69999999999712..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 60.60000000000041..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 60.700000000000415..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CASTLE in its selectional

now working with the word 'CASTLE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CASTLE_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CASTLE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'CASTLE_2', 'o_1', 'CASTLE_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc281d0>, '-', <__main__.AgrTerminal object at 0x10fc182b0>, '#', <__main__.Root object at 0x10fc41940>, '-', <__main__.NominalizerTerminal object at 0x10fc41be0>, '-', <__main__.SemanticTerminal object at 0x10fc41cf8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CASTLE terminal with values set()
we picked CASTLE_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: uno#CASTLE-o
full_pronunciation: uno#CASTLEo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CASTLE to the selectional of the nominalizer whose values are {'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'o_2'}
    selectional: {'MOUSE', 'CHILD', 'BOOK', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 72.1000000000002
    linear: (<__main__.NominalizerTerminal object at 0x10fc08908>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_20, triggers = set(), weight = 12.499999999999998..already existed

create_vi: tried nominalizer: null_30, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.399999999999999..already existed

create_vi: tried nominalizer: null_31, triggers = {('e', frozenset({'-atomic'}))}, weight = 10.599999999999998..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_12, triggers = set(), weight = 12.199999999999998..already existed

create_vi: tried nominalizer: null_13, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.499999999999998..already existed
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 60.700000000000415
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 66.70000000000036
VocabularyItem:
    pronunciation: CASTLE
    label: CASTLE
    values: set()
    diacritic: CASTLE_2
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 12.000000000000002
     what if we combine triggers with the otherwise identical vi CASTLE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 13.200000000000012
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 30.500000000000036
line done
line done

---------------------

input line #446
input roots: [<__main__.Root object at 0x10fc22a20>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 147.7999999999971..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 45.700000000000315..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 64.60000000000039..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 147.8999999999971..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 64.70000000000039..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 61.300000000000416..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 147.9999999999971..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 148.0999999999971..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 45.4000000000003..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 64.80000000000038..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_2', 'a_1', 'PIBLING_1', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b3c8>, '-', <__main__.AgrTerminal object at 0x10fc280b8>, '#', <__main__.Root object at 0x10fc6f160>, '-', <__main__.NominalizerTerminal object at 0x10fc6f2e8>, '-', <__main__.SemanticTerminal object at 0x10fc4b358>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o_2'}
we picked null_8: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: la#PIBLING-a
full_pronunciation: lo#PIBLINGe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 148.0999999999971
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 67.20000000000036
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_1
    triggers: set()
    weight: 11.600000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 13.700000000000012
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 17.6
line done
line done

---------------------

input line #447
input roots: [<__main__.Root object at 0x10fc6f940>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 148.0999999999971..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 45.80000000000032..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 67.20000000000036..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 148.1999999999971..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 67.30000000000035..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 61.40000000000042..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 148.29999999999708..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 148.39999999999708..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 45.5000000000003..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 67.40000000000035..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FOOT in its selectional

now working with the word 'FOOT-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FOOT_1', 'null_8', 'e_3', 'null_19'}
     what if we combine triggers with the otherwise identical vi FOOT_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FOOT_1', 'e_3', 'FOOT_2', 'null_19'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc41940>, '#', <__main__.Root object at 0x10fc356d8>, '-', <__main__.NominalizerTerminal object at 0x10fc14668>, '-', <__main__.SemanticTerminal object at 0x10fc180f0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '+atomic'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out FOOT terminal with values set()
we picked FOOT_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values set()
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: lo#FOOT-e
full_pronunciation: l#FOOTa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 148.39999999999708
VocabularyItem:
    pronunciation: FOOT
    label: FOOT
    values: set()
    diacritic: FOOT_1
    triggers: set()
    weight: 10.100000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 24.09999999999983
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 32.80000000000004
line done
line done

---------------------

input line #448
input roots: [<__main__.Root object at 0x10fc184e0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 67.50000000000034..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 148.39999999999708..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 61.50000000000042..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 61.60000000000042..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'OFFSPRING_3', 'o_1', 'OFFSPRING_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6af28>, '-', <__main__.AgrTerminal object at 0x10fc207b8>, '#', <__main__.Root object at 0x10fc6ac50>, '-', <__main__.NominalizerTerminal object at 0x10fc6a240>, '-', <__main__.SemanticTerminal object at 0x10fc6aa20>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_5: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a', 'i_2', 'a_2'}
we picked null_24 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: uno#OFFSPRING-o
full_pronunciation: una#OFFSPRINGa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 61.60000000000042
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 64.80000000000038
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_5
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 9.900000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2', 'a_2'}
    diacritic: null_24
    triggers: set()
    weight: 12.7
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 32.70000000000004
line done
line done

---------------------

input line #449
input roots: [<__main__.Root object at 0x10fc6af60>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 148.49999999999707..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 45.90000000000032..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 64.80000000000038..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 148.59999999999707..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 64.90000000000038..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 61.60000000000042..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 148.69999999999706..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 148.79999999999706..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 45.6000000000003..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 65.00000000000037..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: BALL in its selectional

now working with the word 'BALL-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'BALL_1', 'a_1'}
     what if we combine triggers with the otherwise identical vi BALL_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'BALL_1', 'BALL_2', 'null_10', 'null_11'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50780>, '-', <__main__.AgrTerminal object at 0x10fc6a3c8>, '#', <__main__.Root object at 0x10fc50a90>, '-', <__main__.NominalizerTerminal object at 0x10fc50a20>, '-', <__main__.SemanticTerminal object at 0x10fc50128>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BALL terminal with values set()
we picked BALL_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#BALL-a
full_pronunciation: la#BALLa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: BALL to the selectional of the nominalizer whose values are {'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'a_2'}
    selectional: {'FROG', 'CHILD', 'BALL', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 67.90000000000043
    linear: (<__main__.NominalizerTerminal object at 0x10fc05f28>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'FROG', 'BALL', 'CHILD', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_6, triggers = set(), weight = 11.8..already existed

create_vi: tried nominalizer: null_7, triggers = {('i', frozenset({'-atomic'}))}, weight = 11.999999999999993..already existed

create_vi: tried nominalizer: null_26, triggers = {('e', frozenset({'-atomic'}))}, weight = 13.599999999999993..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_14, triggers = set(), weight = 14.1..already existed

create_vi: tried nominalizer: null_15, triggers = {('i', frozenset({'-atomic'}))}, weight = 12.199999999999992..already existed
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 148.79999999999706
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 65.00000000000037
VocabularyItem:
    pronunciation: BALL
    label: BALL
    values: set()
    diacritic: BALL_2
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 11.200000000000001
     what if we combine triggers with the otherwise identical vi BALL_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 23.99999999999983
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 32.70000000000004
line done
line done

---------------------

input line #450
input roots: [<__main__.Root object at 0x10fc50f98>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 149.39999999999705..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 65.60000000000036..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 45.7000000000003..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 149.49999999999704..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 67.60000000000034..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 45.8000000000003..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 149.59999999999704..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: BOOK in its selectional

now working with the word 'BOOK-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'BOOK_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi BOOK_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_15', 'BOOK_2', 'BOOK_1', 'i_1', 'null_14'}
done processing input, time to test
we selected the nominalizer with values: {'e_1'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc3ce48>, '-', <__main__.AgrTerminal object at 0x10fc50b38>, '#', <__main__.Root object at 0x10fc438d0>, '-', <__main__.NominalizerTerminal object at 0x10fc43780>, '-', <__main__.SemanticTerminal object at 0x10fc43e48>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BOOK terminal with values set()
we picked BOOK_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1', 'null'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: li#BOOK-i
full_pronunciation: le#BOOKe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 149.59999999999704
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 45.90000000000032
VocabularyItem:
    pronunciation: BOOK
    label: BOOK
    values: set()
    diacritic: BOOK_3
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 10.000000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 24.49999999999983
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 16.900000000000002
line done
line done

---------------------

input line #451
input roots: [<__main__.Root object at 0x10fc3ecf8>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 67.70000000000033..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 149.59999999999704..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 61.70000000000042..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 61.80000000000042..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FLOWER in its selectional

now working with the word 'FLOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19', 'FLOWER_1'}
     what if we combine triggers with the otherwise identical vi FLOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FLOWER_3', 'e_3', 'null_19', 'FLOWER_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc86438>, '-', <__main__.AgrTerminal object at 0x10fc3cf28>, '#', <__main__.Root object at 0x10fc86cf8>, '-', <__main__.NominalizerTerminal object at 0x10fc86b38>, '-', <__main__.SemanticTerminal object at 0x10fc86400>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FLOWER terminal with values set()
we picked FLOWER_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e', 'e_1', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: uno#FLOWER-e
full_pronunciation: una#FLOWERe
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 61.80000000000042
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 65.60000000000036
VocabularyItem:
    pronunciation: FLOWER
    label: FLOWER
    values: set()
    diacritic: FLOWER_4
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'})), ('e', frozenset({'+atomic'}))}
    weight: 10.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 24.399999999999828
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 17.700000000000003
line done
line done

---------------------

input line #452
input roots: [<__main__.Root object at 0x10fc6a1d0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 149.69999999999703..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 65.60000000000036..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 45.90000000000032..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 149.79999999999703..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 67.80000000000032..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 46.00000000000032..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 149.89999999999702..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: BALL in its selectional

now working with the word 'BALL-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'BALL_1', 'null_6'}
     what if we combine triggers with the otherwise identical vi BALL_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'BALL_1', 'BALL_3', 'null_26', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc867b8>, '-', <__main__.AgrTerminal object at 0x10fc862e8>, '#', <__main__.Root object at 0x10fc452b0>, '-', <__main__.NominalizerTerminal object at 0x10fc45438>, '-', <__main__.SemanticTerminal object at 0x10fc45f98>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'o_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BALL terminal with values set()
we picked BALL_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'i_2', 'o_2'}
we picked null_14 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: le#BALL-e
full_pronunciation: li#BALLe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 149.89999999999702
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 45.8000000000003
VocabularyItem:
    pronunciation: BALL
    label: BALL
    values: set()
    diacritic: BALL_3
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 10.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 14.1
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 16.900000000000002
line done
line done

---------------------

input line #453
input roots: [<__main__.Root object at 0x10fc862b0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 149.89999999999702..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 65.70000000000036..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 45.8000000000003..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 149.99999999999702..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 67.90000000000032..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 45.900000000000304..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 150.099999999997..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: FLOWER in its selectional

now working with the word 'FLOWER-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'FLOWER_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi FLOWER_3 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_15', 'FLOWER_2', 'i_1', 'null_14', 'FLOWER_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc86da0>, '#', <__main__.Root object at 0x10fc4b860>, '-', <__main__.NominalizerTerminal object at 0x10fc4b8d0>, '-', <__main__.SemanticTerminal object at 0x10fc4bc50>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out FLOWER terminal with values set()
we picked FLOWER_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#FLOWER-i
full_pronunciation: l#FLOWERi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 150.099999999997
VocabularyItem:
    pronunciation: FLOWER
    label: FLOWER
    values: set()
    diacritic: FLOWER_4
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'})), ('e', frozenset({'+atomic'}))}
    weight: 10.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 24.299999999999827
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 27.70000000000004
line done
line done

---------------------

input line #454
input roots: [<__main__.Root object at 0x10fc459b0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 150.099999999997..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 46.10000000000032..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 65.80000000000035..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 150.199999999997..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 65.90000000000035..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 61.80000000000042..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 150.299999999997..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 150.399999999997..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 46.000000000000306..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 66.00000000000034..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'OFFSPRING_1', 'null_11', 'null_10', 'OFFSPRING_5'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc86550>, '-', <__main__.AgrTerminal object at 0x10fc42710>, '#', <__main__.Root object at 0x10fc864a8>, '-', <__main__.NominalizerTerminal object at 0x10fc86940>, '-', <__main__.SemanticTerminal object at 0x10fc868d0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'e_1', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: la#OFFSPRING-a
full_pronunciation: lo#OFFSPRINGo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 150.399999999997
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 67.90000000000032
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_4
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.200000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 24.199999999999825
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 31.100000000000037
line done
line done

---------------------

input line #455
input roots: [<__main__.Root object at 0x10fc86390>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 67.90000000000032..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 150.399999999997..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 61.900000000000425..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 62.000000000000426..already existed
  we're in a functional word...
  - nominalizer's values are now {'e_1', 'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'o_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_20'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_20', 'null_21'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_20', 'null_21', 'CHILD_1'}
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_20', 'CHILD_1', 'o_1', 'null_21', 'CHILD_3'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67320>, '-', <__main__.AgrTerminal object at 0x10fc86668>, '#', <__main__.Root object at 0x10fc43ba8>, '-', <__main__.NominalizerTerminal object at 0x10fc43f60>, '-', <__main__.SemanticTerminal object at 0x10fc439e8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: uno#CHILD-o
full_pronunciation: uno#CHILDa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 62.000000000000426
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 67.90000000000032
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_4
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 24.099999999999824
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 33.30000000000004
line done
line done

---------------------

input line #456
input roots: [<__main__.Root object at 0x10fc452b0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 66.10000000000034..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 150.499999999997..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 62.000000000000426..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 62.10000000000043..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: CAR in its selectional

now working with the word 'CAR-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'CAR_1'}
     what if we combine triggers with the otherwise identical vi CAR_2 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'null_10', 'CAR_1', 'null_11', 'CAR_3'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc504e0>, '-', <__main__.AgrTerminal object at 0x10fc436a0>, '#', <__main__.Root object at 0x10fc50748>, '-', <__main__.NominalizerTerminal object at 0x10fc509e8>, '-', <__main__.SemanticTerminal object at 0x10fc504a8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CAR terminal with values set()
we picked CAR_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'a_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: una#CAR-a
full_pronunciation: una#CARa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CAR to the selectional of the nominalizer whose values are {'e_1', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1', 'a_2'}
    selectional: {'FROG', 'BALL', 'CHILD', 'TOWER', 'PIBLING', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 29.30000000000008
    linear: (<__main__.NominalizerTerminal object at 0x10fc2aa20>,)
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 62.10000000000043
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 66.10000000000034
VocabularyItem:
    pronunciation: CAR
    label: CAR
    values: set()
    diacritic: CAR_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 23.999999999999822
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 33.30000000000004
line done
line done

---------------------

input line #457
input roots: [<__main__.Root object at 0x10fc43278>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 150.59999999999698..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 46.20000000000032..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 66.70000000000033..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 150.69999999999698..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 66.80000000000032..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 62.70000000000043..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 150.79999999999697..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 150.89999999999696..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 46.10000000000031..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 66.90000000000032..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: TOWER in its selectional

now working with the word 'TOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'TOWER_1', 'e_3', 'null_10'}
     what if we combine triggers with the otherwise identical vi TOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'TOWER_1', 'TOWER_3', 'e_3', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a2e8>, '-', <__main__.AgrTerminal object at 0x10fc50b38>, '#', <__main__.Root object at 0x10fc6ab00>, '-', <__main__.NominalizerTerminal object at 0x10fc6a358>, '-', <__main__.SemanticTerminal object at 0x10fc6a588>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out TOWER terminal with values set()
we picked TOWER_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o_2'}
we picked null_19: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: la#TOWER-e
full_pronunciation: lo#TOWERe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 150.89999999999696
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 67.80000000000032
VocabularyItem:
    pronunciation: TOWER
    label: TOWER
    values: set()
    diacritic: TOWER_1
    triggers: set()
    weight: 9.600000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_19
    triggers: {('e', frozenset({'+atomic'}))}
    weight: 9.8
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 17.700000000000003
line done
line done

---------------------

input line #458
input roots: [<__main__.Root object at 0x10fc50400>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 150.89999999999696..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 67.00000000000031..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 46.300000000000324..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 150.99999999999696..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 67.80000000000032..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 46.400000000000325..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 151.09999999999695..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: FROG in its selectional

now working with the word 'FROG-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'null_17'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_1', 'e_2', 'null_16', 'null_17'}
     what if we combine triggers with the otherwise identical vi FROG_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'FROG_1', 'FROG_3', 'null_17'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a9b0>, '-', <__main__.AgrTerminal object at 0x10fc6a710>, '#', <__main__.Root object at 0x10fc14668>, '-', <__main__.NominalizerTerminal object at 0x10fc2f048>, '-', <__main__.SemanticTerminal object at 0x10fc6a438>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'a_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FROG terminal with values set()
we picked FROG_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'i_2', 'a_2'}
we picked null_14 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: le#FROG-e
full_pronunciation: li#FROGe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 151.09999999999695
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 46.10000000000031
VocabularyItem:
    pronunciation: FROG
    label: FROG
    values: set()
    diacritic: FROG_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 14.0
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 16.900000000000002
line done
line done

---------------------

input line #459
input roots: [<__main__.Root object at 0x10fc6a128>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 151.09999999999695..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 46.50000000000033..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 67.90000000000032..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 151.19999999999695..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 68.00000000000031..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 62.80000000000043..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 151.29999999999694..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 151.39999999999694..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 46.10000000000031..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 68.1000000000003..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FLOWER in its selectional

now working with the word 'FLOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19', 'FLOWER_1'}
     what if we combine triggers with the otherwise identical vi FLOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FLOWER_3', 'e_3', 'null_19', 'FLOWER_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a0f0>, '#', <__main__.Root object at 0x10fc28128>, '-', <__main__.NominalizerTerminal object at 0x10fc22be0>, '-', <__main__.SemanticTerminal object at 0x10fc22f60>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', 'e_1', '+atomic'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out FLOWER terminal with values set()
we picked FLOWER_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1', 'null'}
we picked null_6 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: lo#FLOWER-e
full_pronunciation: l#FLOWERo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 151.39999999999694
VocabularyItem:
    pronunciation: FLOWER
    label: FLOWER
    values: set()
    diacritic: FLOWER_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.500000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_6
    triggers: set()
    weight: 11.8
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 31.100000000000037
line done
line done

---------------------

input line #460
input roots: [<__main__.Root object at 0x10fc3e898>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 151.39999999999694..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 46.60000000000033..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 68.2000000000003..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 151.49999999999693..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 68.3000000000003..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 62.90000000000043..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 151.59999999999692..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 151.69999999999692..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 46.20000000000031..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 68.40000000000029..already existed
  we're in a functional word...
  - nominalizer's values are now {'i_2', 'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: BOOK in its selectional

now working with the word 'BOOK-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_18', 'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_18', 'o_1', 'BOOK_1', 'null_12'}
     what if we combine triggers with the otherwise identical vi BOOK_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'o_1', 'BOOK_1', 'BOOK_3', 'null_18'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4bf28>, '-', <__main__.AgrTerminal object at 0x10fc6f198>, '#', <__main__.Root object at 0x10fc4b9e8>, '-', <__main__.NominalizerTerminal object at 0x10fc4b198>, '-', <__main__.SemanticTerminal object at 0x10fc4be10>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BOOK terminal with values set()
we picked BOOK_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'e_1', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: lo#BOOK-o
full_pronunciation: lo#BOOKo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: BOOK to the selectional of the nominalizer whose values are {'e_1', 'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1', 'o_2'}
    selectional: {'BOOK', 'CHILD', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CASTLE', 'CAR', 'CLOWN', 'OFFSPRING'}
    selection_strength: True
    weight: 23.700000000000017
    linear: (<__main__.NominalizerTerminal object at 0x10fc3d400>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 151.69999999999692
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 68.40000000000029
VocabularyItem:
    pronunciation: BOOK
    label: BOOK
    values: set()
    diacritic: BOOK_4
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 11.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 24.499999999999822
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 31.100000000000037
line done
line done

---------------------

input line #461
input roots: [<__main__.Root object at 0x10fc22a90>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 69.00000000000028..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 152.2999999999969..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 63.00000000000043..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 63.100000000000435..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CHILD_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'CHILD_1', 'null_9', 'o_1', 'CHILD_3'}
done processing input, time to test
we selected the nominalizer with values: {'e_1'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b2b0>, '#', <__main__.Root object at 0x10fc6f7b8>, '-', <__main__.NominalizerTerminal object at 0x10fc4bef0>, '-', <__main__.SemanticTerminal object at 0x10fc4b4a8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'e_1', '-definite', '+atomic'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out CHILD terminal with values set()
we picked CHILD_8: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1', 'null', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: uno#CHILD-o
full_pronunciation: un#CHILDa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 63.100000000000435
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_8
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 24.999999999999822
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 33.80000000000004
line done
line done

---------------------

input line #462
input roots: [<__main__.Root object at 0x10fc4b7f0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 152.3999999999969..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 46.70000000000033..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 69.10000000000028..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 152.4999999999969..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 69.20000000000027..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 63.100000000000435..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 152.5999999999969..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 152.6999999999969..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 46.30000000000031..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 69.30000000000027..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: MOUSE in its selectional

now working with the word 'MOUSE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'MOUSE_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi MOUSE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'MOUSE_2', 'MOUSE_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc35be0>, '-', <__main__.AgrTerminal object at 0x10fc41a90>, '#', <__main__.Root object at 0x10fc6ae48>, '-', <__main__.NominalizerTerminal object at 0x10fc6ae10>, '-', <__main__.SemanticTerminal object at 0x10fc14668>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MOUSE terminal with values set()
we picked MOUSE_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'o_2', 'o'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: lo#MOUSE-o
full_pronunciation: lo#MOUSEo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: MOUSE to the selectional of the nominalizer whose values are {'e_1', 'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1', 'o_2'}
    selectional: {'BOOK', 'CHILD', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CASTLE', 'CAR', 'CLOWN', 'OFFSPRING'}
    selection_strength: True
    weight: 23.90000000000002
    linear: (<__main__.NominalizerTerminal object at 0x10fc3d400>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 152.6999999999969
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 69.30000000000027
VocabularyItem:
    pronunciation: MOUSE
    label: MOUSE
    values: set()
    diacritic: MOUSE_4
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 10.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 13.600000000000012
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 31.80000000000004
line done
line done

---------------------

input line #463
input roots: [<__main__.Root object at 0x10fc4b048>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 69.90000000000026..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 153.29999999999688..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 63.200000000000436..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 63.30000000000044..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: BOOK in its selectional

now working with the word 'BOOK-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'BOOK_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi BOOK_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'BOOK_1', 'BOOK_3'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a7f0>, '-', <__main__.AgrTerminal object at 0x10fc6ab38>, '#', <__main__.Root object at 0x10fc6aa58>, '-', <__main__.NominalizerTerminal object at 0x10fc6a9e8>, '-', <__main__.SemanticTerminal object at 0x10fc6a3c8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BOOK terminal with values set()
we picked BOOK_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1', 'a_2'}
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: uno#BOOK-o
full_pronunciation: una#BOOKo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 63.30000000000044
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 67.00000000000031
VocabularyItem:
    pronunciation: BOOK
    label: BOOK
    values: set()
    diacritic: BOOK_1
    triggers: set()
    weight: 10.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 24.89999999999982
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 32.40000000000004
line done
line done

---------------------

input line #464
input roots: [<__main__.Root object at 0x10fc6f2e8>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 153.39999999999688..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 46.80000000000033..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 70.00000000000026..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 153.49999999999687..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 70.10000000000025..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 63.30000000000044..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 153.59999999999687..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 153.69999999999686..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 46.40000000000031..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 70.20000000000024..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CLOWN in its selectional

now working with the word 'CLOWN-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CLOWN_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CLOWN_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'CLOWN_3', 'o_1', 'CLOWN_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50518>, '-', <__main__.AgrTerminal object at 0x10fc6a630>, '#', <__main__.Root object at 0x10fc504a8>, '-', <__main__.NominalizerTerminal object at 0x10fc509e8>, '-', <__main__.SemanticTerminal object at 0x10fc505c0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CLOWN terminal with values set()
we picked CLOWN_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: lo#CLOWN-o
full_pronunciation: la#CLOWNo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 153.69999999999686
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 66.90000000000032
VocabularyItem:
    pronunciation: CLOWN
    label: CLOWN
    values: set()
    diacritic: CLOWN_3
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 11.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 12.300000000000011
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 32.40000000000004
line done
line done

---------------------

input line #465
input roots: [<__main__.Root object at 0x10fc50f98>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 153.69999999999686..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 66.90000000000032..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 46.90000000000033..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 153.79999999999686..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 70.30000000000024..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 47.000000000000334..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 153.89999999999685..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'null_17'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'e_2', 'null_16', 'null_17'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_5 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'OFFSPRING_7', 'null_16', 'OFFSPRING_1', 'null_17'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc43208>, '-', <__main__.AgrTerminal object at 0x10fc50be0>, '#', <__main__.Root object at 0x10fc43f60>, '-', <__main__.NominalizerTerminal object at 0x10fc43ba8>, '-', <__main__.SemanticTerminal object at 0x10fc43780>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic', 'a_2'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i', 'e_1', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: le#OFFSPRING-e
full_pronunciation: le#OFFSPRINGi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 153.89999999999685
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 47.000000000000334
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_4
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.100000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 24.79999999999982
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 27.600000000000037
line done
line done

---------------------

input line #466
input roots: [<__main__.Root object at 0x10fc3cf28>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 153.89999999999685..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 67.00000000000031..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 47.000000000000334..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 153.99999999999685..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 70.40000000000023..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 47.100000000000335..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 154.09999999999684..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: BALL in its selectional

now working with the word 'BALL-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'null_17'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'BALL_1', 'null_17'}
     what if we combine triggers with the otherwise identical vi BALL_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'BALL_1', 'BALL_3', 'null_17'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc86dd8>, '-', <__main__.AgrTerminal object at 0x10fc67e80>, '#', <__main__.Root object at 0x10fc861d0>, '-', <__main__.NominalizerTerminal object at 0x10fc86e80>, '-', <__main__.SemanticTerminal object at 0x10fc86be0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BALL terminal with values set()
we picked BALL_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i_2'}
we picked null_14: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: le#BALL-e
full_pronunciation: li#BALLe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 154.09999999999684
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 46.40000000000031
VocabularyItem:
    pronunciation: BALL
    label: BALL
    values: set()
    diacritic: BALL_1
    triggers: set()
    weight: 10.100000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 13.9
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 17.000000000000004
line done
line done

---------------------

input line #467
input roots: [<__main__.Root object at 0x10fc6aa20>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 154.09999999999684..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 67.1000000000003..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 47.20000000000034..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 154.19999999999683..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 70.50000000000023..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 47.30000000000034..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 154.29999999999683..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'OFFSPRING_1', 'null_6'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_5 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'OFFSPRING_1', 'OFFSPRING_7', 'null_26', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc45e80>, '-', <__main__.AgrTerminal object at 0x10fc86cc0>, '#', <__main__.Root object at 0x10fc47da0>, '-', <__main__.NominalizerTerminal object at 0x10fc453c8>, '-', <__main__.SemanticTerminal object at 0x10fc45438>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic', 'a_2'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_6: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i', 'e_1', 'a_2'}
we picked null_16 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: le#OFFSPRING-e
full_pronunciation: le#OFFSPRINGi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 154.29999999999683
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 47.30000000000034
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_6
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1', 'a_2'}
    diacritic: null_16
    triggers: set()
    weight: 11.6
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 27.500000000000036
line done
line done

---------------------

input line #468
input roots: [<__main__.Root object at 0x10fc86198>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 154.29999999999683..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 47.30000000000034..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 67.2000000000003..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 154.39999999999682..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 67.3000000000003..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 63.40000000000044..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 154.49999999999682..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 154.5999999999968..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 46.40000000000031..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 67.40000000000029..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: BALL in its selectional

now working with the word 'BALL-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'BALL_1', 'a_1'}
     what if we combine triggers with the otherwise identical vi BALL_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'BALL_1', 'BALL_2', 'null_10', 'null_11'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc45e80>, '#', <__main__.Root object at 0x10fc866a0>, '-', <__main__.NominalizerTerminal object at 0x10fc862e8>, '-', <__main__.SemanticTerminal object at 0x10fc10dd8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '+atomic', 'i_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out BALL terminal with values set()
we picked BALL_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: la#BALL-a
full_pronunciation: l#BALLo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 154.5999999999968
VocabularyItem:
    pronunciation: BALL
    label: BALL
    values: set()
    diacritic: BALL_3
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 10.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 24.699999999999818
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 32.30000000000004
line done
line done

---------------------

input line #469
input roots: [<__main__.Root object at 0x10fc47da0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 70.60000000000022..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 154.5999999999968..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 63.50000000000044..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 63.60000000000044..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CLOWN in its selectional

now working with the word 'CLOWN-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CLOWN_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CLOWN_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'CLOWN_3', 'o_1', 'CLOWN_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc676a0>, '-', <__main__.AgrTerminal object at 0x10fc86940>, '#', <__main__.Root object at 0x10fc673c8>, '-', <__main__.NominalizerTerminal object at 0x10fc67da0>, '-', <__main__.SemanticTerminal object at 0x10fc67ba8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CLOWN terminal with values set()
we picked CLOWN_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: uno#CLOWN-o
full_pronunciation: uno#CLOWNa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 63.60000000000044
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 70.60000000000022
VocabularyItem:
    pronunciation: CLOWN
    label: CLOWN
    values: set()
    diacritic: CLOWN_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 14.100000000000012
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 33.80000000000004
line done
line done

---------------------

input line #470
input roots: [<__main__.Root object at 0x10fc86eb8>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 70.60000000000022..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 154.6999999999968..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 63.60000000000044..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 63.70000000000044..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FLOWER in its selectional

now working with the word 'FLOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19', 'FLOWER_1'}
     what if we combine triggers with the otherwise identical vi FLOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FLOWER_3', 'e_3', 'null_19', 'FLOWER_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc2d588>, '-', <__main__.AgrTerminal object at 0x10fc43198>, '#', <__main__.Root object at 0x10fc2dbe0>, '-', <__main__.NominalizerTerminal object at 0x10fc2df28>, '-', <__main__.SemanticTerminal object at 0x10fc2dc50>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FLOWER terminal with values set()
we picked FLOWER_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: uno#FLOWER-e
full_pronunciation: una#FLOWERo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 63.70000000000044
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 67.40000000000029
VocabularyItem:
    pronunciation: FLOWER
    label: FLOWER
    values: set()
    diacritic: FLOWER_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.400000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 24.599999999999817
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 32.30000000000004
line done
line done

---------------------

input line #471
input roots: [<__main__.Root object at 0x10fc67278>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 154.7999999999968..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 47.40000000000034..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 70.70000000000022..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 154.8999999999968..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 70.80000000000021..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 63.70000000000044..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 154.9999999999968..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 155.09999999999678..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 46.50000000000031..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 70.9000000000002..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CLOWN in its selectional

now working with the word 'CLOWN-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CLOWN_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CLOWN_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'CLOWN_3', 'o_1', 'CLOWN_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50d30>, '-', <__main__.AgrTerminal object at 0x10fc500f0>, '#', <__main__.Root object at 0x10fc6a630>, '-', <__main__.NominalizerTerminal object at 0x10fc6add8>, '-', <__main__.SemanticTerminal object at 0x10fc38390>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'i_2', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CLOWN terminal with values set()
we picked CLOWN_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'i_2', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: lo#CLOWN-o
full_pronunciation: lo#CLOWNo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CLOWN to the selectional of the nominalizer whose values are {'i_2', 'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'o_2'}
    selectional: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'GRANDPARENT', 'CASTLE', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 30.20000000000008
    linear: (<__main__.NominalizerTerminal object at 0x10fc22eb8>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 155.09999999999678
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 70.9000000000002
VocabularyItem:
    pronunciation: CLOWN
    label: CLOWN
    values: set()
    diacritic: CLOWN_4
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.000000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 24.499999999999815
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 32.30000000000004
line done
line done

---------------------

input line #472
input roots: [<__main__.Root object at 0x10fc50860>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 155.69999999999678..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 67.40000000000029..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 46.600000000000314..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 155.79999999999677..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 71.5000000000002..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 46.700000000000315..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 155.89999999999677..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: CASTLE in its selectional

now working with the word 'CASTLE-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'CASTLE_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi CASTLE_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_15', 'i_1', 'null_14', 'CASTLE_1', 'CASTLE_3'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6ac50>, '-', <__main__.AgrTerminal object at 0x10fc50780>, '#', <__main__.Root object at 0x10fc6a128>, '-', <__main__.NominalizerTerminal object at 0x10fc6a438>, '-', <__main__.SemanticTerminal object at 0x10fc6a0b8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic', 'o_2'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CASTLE terminal with values set()
we picked CASTLE_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: li#CASTLE-i
full_pronunciation: le#CASTLEe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 155.89999999999677
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 47.40000000000034
VocabularyItem:
    pronunciation: CASTLE
    label: CASTLE
    values: set()
    diacritic: CASTLE_2
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 12.500000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 24.999999999999815
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 17.000000000000004
line done
line done

---------------------

input line #473
input roots: [<__main__.Root object at 0x10fc3c748>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 155.89999999999677..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 67.50000000000028..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 46.80000000000032..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 155.99999999999676..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 71.6000000000002..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 46.90000000000032..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 156.09999999999675..already existed
  we're in a functional word...
  - nominalizer's values are now {'a_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'a_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_24', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_24', 'i_1', 'null_28'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_24', 'i_1', 'null_28'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_5 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_28', 'OFFSPRING_2', 'null_24', 'i_1', 'OFFSPRING_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc3bf28>, '-', <__main__.AgrTerminal object at 0x10fc6a6d8>, '#', <__main__.Root object at 0x10fc41e48>, '-', <__main__.NominalizerTerminal object at 0x10fc41a90>, '-', <__main__.SemanticTerminal object at 0x10fc22f60>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1', 'null'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: li#OFFSPRING-i
full_pronunciation: le#OFFSPRINGi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 156.09999999999675
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 47.30000000000034
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_3
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 9.400000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 24.899999999999814
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 27.600000000000037
line done
line done

---------------------

input line #474
input roots: [<__main__.Root object at 0x10fc22b70>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 156.09999999999675..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 47.30000000000034..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 67.60000000000028..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 156.19999999999675..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 67.70000000000027..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 63.800000000000445..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 156.29999999999674..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 156.39999999999674..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 47.00000000000032..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 67.80000000000027..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: CAR in its selectional

now working with the word 'CAR-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'CAR_1'}
     what if we combine triggers with the otherwise identical vi CAR_2 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'null_10', 'CAR_1', 'null_11', 'CAR_3'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4be10>, '-', <__main__.AgrTerminal object at 0x10fc3bf98>, '#', <__main__.Root object at 0x10fc58470>, '-', <__main__.NominalizerTerminal object at 0x10fc58d30>, '-', <__main__.SemanticTerminal object at 0x10fc084e0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'i_2', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CAR terminal with values set()
we picked CAR_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a', 'i_2', 'a_2'}
we picked null_24 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#CAR-a
full_pronunciation: la#CARa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CAR to the selectional of the nominalizer whose values are {'i_2', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'a_2'}
    selectional: {'BOOK', 'CHILD', 'BALL', 'FROG', 'PIBLING', 'FLOWER', 'GRANDPARENT', 'TOWER', 'CASTLE', 'CAR', 'KEY', 'CLOWN', 'FOOT', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 23.800000000000026
    linear: (<__main__.NominalizerTerminal object at 0x10fc36a90>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 156.39999999999674
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 67.80000000000027
VocabularyItem:
    pronunciation: CAR
    label: CAR
    values: set()
    diacritic: CAR_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 11.200000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2', 'a_2'}
    diacritic: null_24
    triggers: set()
    weight: 12.6
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 33.80000000000004
line done
line done

---------------------

input line #475
input roots: [<__main__.Root object at 0x10fc412b0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 156.99999999999673..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 47.40000000000034..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 71.70000000000019..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 157.09999999999673..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 71.80000000000018..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 63.900000000000446..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 157.19999999999672..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 157.29999999999671..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 47.10000000000032..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 71.90000000000018..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FLOWER in its selectional

now working with the word 'FLOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19', 'FLOWER_1'}
     what if we combine triggers with the otherwise identical vi FLOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FLOWER_3', 'e_3', 'null_19', 'FLOWER_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc41748>, '-', <__main__.AgrTerminal object at 0x10fc4b080>, '#', <__main__.Root object at 0x10fc3ecf8>, '-', <__main__.NominalizerTerminal object at 0x10fc22f60>, '-', <__main__.SemanticTerminal object at 0x10fc281d0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FLOWER terminal with values set()
we picked FLOWER_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1', 'a_2'}
we picked null_32: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: lo#FLOWER-e
full_pronunciation: la#FLOWERa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 157.29999999999671
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 68.30000000000027
VocabularyItem:
    pronunciation: FLOWER
    label: FLOWER
    values: set()
    diacritic: FLOWER_1
    triggers: set()
    weight: 10.000000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1', 'a_2'}
    diacritic: null_32
    triggers: {('i', frozenset({'-atomic'}))}
    weight: 10.399999999999999
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 34.30000000000004
line done
line done

---------------------

input line #476
input roots: [<__main__.Root object at 0x10fc41b00>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 157.29999999999671..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 68.30000000000027..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 47.50000000000034..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 157.3999999999967..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 72.00000000000017..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 47.60000000000034..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 157.4999999999967..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'o_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'o_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_20'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_20', 'null_31'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'e_2', 'null_20', 'null_31'}
     what if we combine triggers with the otherwise identical vi PIBLING_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_5 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_20', 'PIBLING_1', 'PIBLING_3', 'null_31'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a198>, '-', <__main__.AgrTerminal object at 0x10fc355c0>, '#', <__main__.Root object at 0x10fc6a978>, '-', <__main__.NominalizerTerminal object at 0x10fc6a9b0>, '-', <__main__.SemanticTerminal object at 0x10fc6ab70>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'a_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'i_2', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: le#PIBLING-e
full_pronunciation: li#PIBLINGe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 157.4999999999967
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 47.10000000000032
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_3
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 10.200000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 12.200000000000012
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 17.000000000000004
line done
line done

---------------------

input line #477
input roots: [<__main__.Root object at 0x10fc3eac8>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 157.4999999999967..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 47.700000000000344..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 72.10000000000016..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 157.5999999999967..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 72.20000000000016..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 64.00000000000044..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 157.6999999999967..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 157.7999999999967..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 47.10000000000032..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 72.30000000000015..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CASTLE in its selectional

now working with the word 'CASTLE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CASTLE_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CASTLE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'CASTLE_2', 'o_1', 'CASTLE_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc38470>, '-', <__main__.AgrTerminal object at 0x10fc6ac50>, '#', <__main__.Root object at 0x10fc503c8>, '-', <__main__.NominalizerTerminal object at 0x10fc50f60>, '-', <__main__.SemanticTerminal object at 0x10fc50518>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CASTLE terminal with values set()
we picked CASTLE_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1', 'a_2'}
we picked null_29: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: lo#CASTLE-o
full_pronunciation: la#CASTLEe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 157.7999999999967
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 68.30000000000027
VocabularyItem:
    pronunciation: CASTLE
    label: CASTLE
    values: set()
    diacritic: CASTLE_1
    triggers: set()
    weight: 10.600000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_29
    triggers: {('e', frozenset({'+atomic'}))}
    weight: 9.9
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 17.900000000000006
line done
line done

---------------------

input line #478
input roots: [<__main__.Root object at 0x10fc6ada0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 157.7999999999967..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 47.800000000000345..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 72.40000000000015..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 157.89999999999668..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 72.50000000000014..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 64.10000000000043..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 157.99999999999667..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 158.09999999999667..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 47.20000000000032..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 72.60000000000014..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: BOOK in its selectional

now working with the word 'BOOK-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'BOOK_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi BOOK_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'BOOK_1', 'BOOK_3'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc2df28>, '-', <__main__.AgrTerminal object at 0x10fc500f0>, '#', <__main__.Root object at 0x10fc3ce48>, '-', <__main__.NominalizerTerminal object at 0x10fc2d9e8>, '-', <__main__.SemanticTerminal object at 0x10fc2d588>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BOOK terminal with values set()
we picked BOOK_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o_2'}
we picked null_9: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: lo#BOOK-o
full_pronunciation: lo#BOOKo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: BOOK to the selectional of the nominalizer whose values are {'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'o_2'}
    selectional: {'MOUSE', 'CHILD', 'BOOK', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 78.09999999999985
    linear: (<__main__.NominalizerTerminal object at 0x10fc08908>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_21, triggers = {('o', frozenset({'+atomic'}))}, weight = 10.299999999999999..already existed

create_vi: tried nominalizer: null_38, triggers = {('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}, weight = 10.2..already existed

create_vi: tried nominalizer: null_36, triggers = {('o', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}, weight = 10.399999999999999..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_18, triggers = {('o', frozenset({'+atomic'}))}, weight = 10.999999999999998..already existed

create_vi: tried nominalizer: null_39, triggers = {('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}, weight = 10.2..already existed
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 158.09999999999667
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 72.60000000000014
VocabularyItem:
    pronunciation: BOOK
    label: BOOK
    values: set()
    diacritic: BOOK_1
    triggers: set()
    weight: 10.600000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_9
    triggers: {('o', frozenset({'+atomic'}))}
    weight: 10.8
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 33.00000000000004
line done
line done

---------------------

input line #479
input roots: [<__main__.Root object at 0x10fc38390>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 158.69999999999666..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 68.30000000000027..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 47.300000000000324..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 158.79999999999666..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 73.20000000000013..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 47.400000000000325..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 158.89999999999665..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: MOUSE in its selectional

now working with the word 'MOUSE-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'MOUSE_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi MOUSE_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'MOUSE_3', 'null_15', 'MOUSE_1', 'i_1', 'null_14'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50748>, '#', <__main__.Root object at 0x10fc67198>, '-', <__main__.NominalizerTerminal object at 0x10fc67128>, '-', <__main__.SemanticTerminal object at 0x10fc67828>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out MOUSE terminal with values set()
we picked MOUSE_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: li#MOUSE-i
full_pronunciation: l#MOUSEi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 158.89999999999665
VocabularyItem:
    pronunciation: MOUSE
    label: MOUSE
    values: set()
    diacritic: MOUSE_2
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 10.600000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 12.100000000000012
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 27.600000000000037
line done
line done

---------------------

input line #480
input roots: [<__main__.Root object at 0x10fc2d438>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 158.89999999999665..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 47.90000000000035..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 73.30000000000013..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 158.99999999999665..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 73.40000000000012..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 64.20000000000043..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 159.09999999999664..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 159.19999999999663..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 47.50000000000033..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 73.50000000000011..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: MOUSE in its selectional

now working with the word 'MOUSE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'MOUSE_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi MOUSE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'MOUSE_2', 'MOUSE_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc864a8>, '-', <__main__.AgrTerminal object at 0x10fc436a0>, '#', <__main__.Root object at 0x10fc86438>, '-', <__main__.NominalizerTerminal object at 0x10fc86240>, '-', <__main__.SemanticTerminal object at 0x10fc86160>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MOUSE terminal with values set()
we picked MOUSE_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: lo#MOUSE-o
full_pronunciation: lo#MOUSEo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: MOUSE to the selectional of the nominalizer whose values are {'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'o_2'}
    selectional: {'MOUSE', 'CHILD', 'BOOK', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 78.79999999999981
    linear: (<__main__.NominalizerTerminal object at 0x10fc08908>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_6, triggers = set(), weight = 11.8..already existed

create_vi: tried nominalizer: null_7, triggers = {('i', frozenset({'-atomic'}))}, weight = 12.099999999999993..already existed

create_vi: tried nominalizer: null_26, triggers = {('e', frozenset({'-atomic'}))}, weight = 13.699999999999992..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_14, triggers = set(), weight = 13.9..already existed

create_vi: tried nominalizer: null_15, triggers = {('i', frozenset({'-atomic'}))}, weight = 12.299999999999992..already existed
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 159.19999999999663
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 73.50000000000011
VocabularyItem:
    pronunciation: MOUSE
    label: MOUSE
    values: set()
    diacritic: MOUSE_3
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.200000000000001
     what if we combine triggers with the otherwise identical vi MOUSE_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 24.799999999999812
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 33.600000000000044
line done
line done

---------------------

input line #481
input roots: [<__main__.Root object at 0x10fc86208>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 68.40000000000026..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 159.79999999999663..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 64.30000000000042..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 64.40000000000042..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'CHILD_1', 'a_1'}
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CHILD_1', 'a_1', 'CHILD_2', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc58c88>, '-', <__main__.AgrTerminal object at 0x10fc86b70>, '#', <__main__.Root object at 0x10fc58cf8>, '-', <__main__.NominalizerTerminal object at 0x10fc58400>, '-', <__main__.SemanticTerminal object at 0x10fc582e8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i_2', 'o_2'}
we picked null_14: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: una#CHILD-a
full_pronunciation: uno#CHILDa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 64.40000000000042
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 74.00000000000011
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_1
    triggers: set()
    weight: 9.300000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 13.9
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 34.30000000000004
line done
line done

---------------------

input line #482
input roots: [<__main__.Root object at 0x10fc864e0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 74.00000000000011..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 159.89999999999662..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 64.40000000000042..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 64.50000000000041..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'OFFSPRING_3', 'o_1', 'OFFSPRING_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc10dd8>, '-', <__main__.AgrTerminal object at 0x10fc58630>, '#', <__main__.Root object at 0x10fc86be0>, '-', <__main__.NominalizerTerminal object at 0x10fc86da0>, '-', <__main__.SemanticTerminal object at 0x10fc452b0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_9: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: uno#OFFSPRING-o
full_pronunciation: una#OFFSPRINGa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 64.50000000000041
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 68.40000000000026
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_9
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.100000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 25.299999999999812
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 34.20000000000004
line done
line done

---------------------

input line #483
input roots: [<__main__.Root object at 0x10fc470f0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 68.40000000000026..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 159.99999999999662..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 64.50000000000041..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 64.6000000000004..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'GRANDPARENT_1'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'GRANDPARENT_1', 'null_11', 'null_10', 'GRANDPARENT_3'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67e80>, '-', <__main__.AgrTerminal object at 0x10fc866a0>, '#', <__main__.Root object at 0x10fc67f28>, '-', <__main__.NominalizerTerminal object at 0x10fc67ac8>, '-', <__main__.SemanticTerminal object at 0x10fc676a0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_8: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'a_2', 'o'}
we picked null_16 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: una#GRANDPARENT-a
full_pronunciation: una#GRANDPARENTo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 64.6000000000004
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 68.40000000000026
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_8
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1', 'a_2'}
    diacritic: null_16
    triggers: set()
    weight: 11.5
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 34.200000000000045
line done
line done

---------------------

input line #484
input roots: [<__main__.Root object at 0x10fc86940>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 160.0999999999966..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 68.40000000000026..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 48.00000000000035..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 160.1999999999966..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 74.10000000000011..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 48.10000000000035..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 160.2999999999966..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'OFFSPRING_1', 'null_6'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_5 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'OFFSPRING_1', 'OFFSPRING_7', 'null_26', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc2dd68>, '-', <__main__.AgrTerminal object at 0x10fc673c8>, '#', <__main__.Root object at 0x10fc2dbe0>, '-', <__main__.NominalizerTerminal object at 0x10fc2df28>, '-', <__main__.SemanticTerminal object at 0x10fc2d6d8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic', 'a_2'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i', 'e_1', 'a_2'}
we picked null_16 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: le#OFFSPRING-e
full_pronunciation: le#OFFSPRINGi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 160.2999999999966
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 48.10000000000035
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_4
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.000000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1', 'a_2'}
    diacritic: null_16
    triggers: set()
    weight: 11.4
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 27.500000000000036
line done
line done

---------------------

input line #485
input roots: [<__main__.Root object at 0x10fc05630>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 74.2000000000001..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 160.2999999999966..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 64.6000000000004..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 64.7000000000004..already existed
  we're in a functional word...
  - nominalizer's values are now {'e_1', 'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'o_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_20'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_20', 'null_21'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_20', 'null_21', 'GRANDPARENT_1'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_20', 'o_1', 'null_21', 'GRANDPARENT_1', 'GRANDPARENT_2'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50940>, '-', <__main__.AgrTerminal object at 0x10fc2dc50>, '#', <__main__.Root object at 0x10fc38908>, '-', <__main__.NominalizerTerminal object at 0x10fc38390>, '-', <__main__.SemanticTerminal object at 0x10fc50860>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'a_2'}
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: uno#GRANDPARENT-o
full_pronunciation: una#GRANDPARENTo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 64.7000000000004
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 68.40000000000026
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_1
    triggers: set()
    weight: 10.000000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 25.19999999999981
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 34.200000000000045
line done
line done

---------------------

input line #486
input roots: [<__main__.Root object at 0x10fc50780>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 160.3999999999966..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 48.10000000000035..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 74.3000000000001..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 160.4999999999966..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 74.40000000000009..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 64.7000000000004..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 160.59999999999658..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 160.69999999999658..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 47.60000000000033..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 74.50000000000009..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FOOT in its selectional

now working with the word 'FOOT-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FOOT_1', 'null_8', 'e_3', 'null_19'}
     what if we combine triggers with the otherwise identical vi FOOT_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FOOT_1', 'e_3', 'FOOT_2', 'null_19'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a4a8>, '-', <__main__.AgrTerminal object at 0x10fc6a5f8>, '#', <__main__.Root object at 0x10fc6a198>, '-', <__main__.NominalizerTerminal object at 0x10fc6ab70>, '-', <__main__.SemanticTerminal object at 0x10fc6a978>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FOOT terminal with values set()
we picked FOOT_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: lo#FOOT-e
full_pronunciation: lo#FOOTa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 160.69999999999658
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 74.50000000000009
VocabularyItem:
    pronunciation: FOOT
    label: FOOT
    values: set()
    diacritic: FOOT_3
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.800000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 25.09999999999981
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 34.20000000000004
line done
line done

---------------------

input line #487
input roots: [<__main__.Root object at 0x10fc6aac8>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 160.69999999999658..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 48.20000000000035..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 74.50000000000009..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 160.79999999999657..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 74.60000000000008..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 64.8000000000004..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 160.89999999999657..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 160.99999999999656..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 47.70000000000033..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 74.70000000000007..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'OFFSPRING_3', 'o_1', 'OFFSPRING_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a470>, '#', <__main__.Root object at 0x10fc084e0>, '-', <__main__.NominalizerTerminal object at 0x10fc207b8>, '-', <__main__.SemanticTerminal object at 0x10fc18358>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '+atomic', 'i_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: lo#OFFSPRING-o
full_pronunciation: l#OFFSPRINGa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 160.99999999999656
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.600000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 24.999999999999808
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 34.10000000000004
line done
line done

---------------------

input line #488
input roots: [<__main__.Root object at 0x10fc18588>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 160.99999999999656..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 48.30000000000035..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 68.40000000000026..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 161.09999999999656..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 68.50000000000026..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 64.90000000000039..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 161.19999999999655..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 161.29999999999654..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 47.80000000000033..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 68.60000000000025..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: CAR in its selectional

now working with the word 'CAR-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'CAR_1'}
     what if we combine triggers with the otherwise identical vi CAR_2 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'null_10', 'CAR_1', 'null_11', 'CAR_3'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4bf28>, '-', <__main__.AgrTerminal object at 0x10fc3e080>, '#', <__main__.Root object at 0x10fc363c8>, '-', <__main__.NominalizerTerminal object at 0x10fc365c0>, '-', <__main__.SemanticTerminal object at 0x10fc4b8d0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CAR terminal with values set()
we picked CAR_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1', 'o_2'}
we picked null_37: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: la#CAR-a
full_pronunciation: lo#CARe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 161.29999999999654
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 74.70000000000007
VocabularyItem:
    pronunciation: CAR
    label: CAR
    values: set()
    diacritic: CAR_1
    triggers: set()
    weight: 9.600000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1', 'o_2'}
    diacritic: null_37
    triggers: {('e', frozenset({'-atomic'})), ('e', frozenset({'+atomic'}))}
    weight: 10.1
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 17.900000000000006
line done
line done

---------------------

input line #489
input roots: [<__main__.Root object at 0x10fc4b828>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 68.70000000000024..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 161.29999999999654..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 65.00000000000038..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 65.10000000000038..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'OFFSPRING_1', 'null_11', 'null_10', 'OFFSPRING_5'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc419b0>, '-', <__main__.AgrTerminal object at 0x10fc36780>, '#', <__main__.Root object at 0x10fc3ecf8>, '-', <__main__.NominalizerTerminal object at 0x10fc28128>, '-', <__main__.SemanticTerminal object at 0x10fc41be0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: una#OFFSPRING-a
full_pronunciation: una#OFFSPRINGa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: OFFSPRING to the selectional of the nominalizer whose values are {'e_1', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1', 'a_2'}
    selectional: {'FROG', 'BALL', 'CHILD', 'TOWER', 'PIBLING', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 29.800000000000086
    linear: (<__main__.NominalizerTerminal object at 0x10fc2aa20>,)
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 65.10000000000038
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 68.70000000000024
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.500000000000002
     what if we combine triggers with the otherwise identical vi OFFSPRING_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_5 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 12.000000000000012
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 34.20000000000004
line done
line done

---------------------

input line #490
input roots: [<__main__.Root object at 0x10fc41390>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 161.39999999999654..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 48.400000000000354..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 69.30000000000024..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 161.49999999999653..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 69.40000000000023..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 65.70000000000037..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 161.59999999999653..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 161.69999999999652..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 47.90000000000033..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 69.50000000000023..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: FROG in its selectional

now working with the word 'FROG-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi FROG_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_2', 'a_1', 'FROG_1', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a1d0>, '-', <__main__.AgrTerminal object at 0x10fc228d0>, '#', <__main__.Root object at 0x10fc6a908>, '-', <__main__.NominalizerTerminal object at 0x10fc6a588>, '-', <__main__.SemanticTerminal object at 0x10fc6a400>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FROG terminal with values set()
we picked FROG_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o_2'}
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: la#FROG-a
full_pronunciation: lo#FROGo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 161.69999999999652
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 74.60000000000008
VocabularyItem:
    pronunciation: FROG
    label: FROG
    values: set()
    diacritic: FROG_1
    triggers: set()
    weight: 10.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 24.899999999999807
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 34.200000000000045
line done
line done

---------------------

input line #491
input roots: [<__main__.Root object at 0x10fc355c0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 161.69999999999652..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 69.60000000000022..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 48.500000000000355..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 161.79999999999652..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 74.60000000000008..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 48.60000000000036..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 161.8999999999965..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: CAR in its selectional

now working with the word 'CAR-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'null_17'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'CAR_1', 'null_17'}
     what if we combine triggers with the otherwise identical vi CAR_3 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'CAR_2', 'null_16', 'null_17', 'CAR_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6ab00>, '#', <__main__.Root object at 0x10fc50a20>, '-', <__main__.NominalizerTerminal object at 0x10fc50f60>, '-', <__main__.SemanticTerminal object at 0x10fc38390>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out CAR terminal with values set()
we picked CAR_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: le#CAR-e
full_pronunciation: l#CARi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 161.8999999999965
VocabularyItem:
    pronunciation: CAR
    label: CAR
    values: set()
    diacritic: CAR_3
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 9.500000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 24.799999999999805
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 27.400000000000034
line done
line done

---------------------

input line #492
input roots: [<__main__.Root object at 0x10fc6a0b8>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 69.70000000000022..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 161.8999999999965..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 65.80000000000037..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 65.90000000000036..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: CAR in its selectional

now working with the word 'CAR-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'CAR_1'}
     what if we combine triggers with the otherwise identical vi CAR_2 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'null_10', 'CAR_1', 'null_11', 'CAR_3'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc2d588>, '-', <__main__.AgrTerminal object at 0x10fc6a4e0>, '#', <__main__.Root object at 0x10fc2dd68>, '-', <__main__.NominalizerTerminal object at 0x10fc2d6d8>, '-', <__main__.SemanticTerminal object at 0x10fc2dbe0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CAR terminal with values set()
we picked CAR_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1', 'o_2'}
we picked null_37: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: una#CAR-a
full_pronunciation: uno#CARe
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 65.90000000000036
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 74.60000000000008
VocabularyItem:
    pronunciation: CAR
    label: CAR
    values: set()
    diacritic: CAR_1
    triggers: set()
    weight: 9.500000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1', 'o_2'}
    diacritic: null_37
    triggers: {('e', frozenset({'-atomic'})), ('e', frozenset({'+atomic'}))}
    weight: 10.0
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 17.800000000000004
line done
line done

---------------------

input line #493
input roots: [<__main__.Root object at 0x10fc6a3c8>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 161.9999999999965..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 69.80000000000021..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 48.000000000000334..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 162.0999999999965..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 74.60000000000008..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 48.100000000000335..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 162.1999999999965..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'CHILD_1', 'i_1'}
     what if we combine triggers with the otherwise identical vi CHILD_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CHILD_1', 'null_12', 'null_13', 'CHILD_4', 'i_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50d30>, '#', <__main__.Root object at 0x10fc67828>, '-', <__main__.NominalizerTerminal object at 0x10fc67320>, '-', <__main__.SemanticTerminal object at 0x10fc67e48>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked le_1: no super match (neither decl nor L1-gender)
now spelling out CHILD terminal with values set()
we picked CHILD_8: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: li#CHILD-i
full_pronunciation: le#CHILDe
vis_used:
Failure
VocabularyItem:
    pronunciation: le
    label: definite
    values: {'+definite', '-atomic'}
    diacritic: le_1
    triggers: set()
    weight: 10.900000000000002
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_8
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 12.500000000000012
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 17.100000000000005
line done
line done

---------------------

input line #494
input roots: [<__main__.Root object at 0x10fc43438>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 69.9000000000002..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 162.2999999999965..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 65.90000000000036..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 66.00000000000036..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: FROG in its selectional

now working with the word 'FROG-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi FROG_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_2', 'a_1', 'FROG_1', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc864a8>, '-', <__main__.AgrTerminal object at 0x10fc05e48>, '#', <__main__.Root object at 0x10fc86b70>, '-', <__main__.NominalizerTerminal object at 0x10fc866d8>, '-', <__main__.SemanticTerminal object at 0x10fc861d0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FROG terminal with values set()
we picked FROG_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o_2'}
we picked null_9: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: una#FROG-a
full_pronunciation: uno#FROGo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 66.00000000000036
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 74.60000000000008
VocabularyItem:
    pronunciation: FROG
    label: FROG
    values: set()
    diacritic: FROG_1
    triggers: set()
    weight: 10.600000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_9
    triggers: {('o', frozenset({'+atomic'}))}
    weight: 11.3
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 34.100000000000044
line done
line done

---------------------

input line #495
input roots: [<__main__.Root object at 0x10fc868d0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 74.60000000000008..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 162.39999999999648..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 66.00000000000036..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 66.10000000000035..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FLOWER in its selectional

now working with the word 'FLOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19', 'FLOWER_1'}
     what if we combine triggers with the otherwise identical vi FLOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FLOWER_3', 'e_3', 'null_19', 'FLOWER_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc582e8>, '-', <__main__.AgrTerminal object at 0x10fc453c8>, '#', <__main__.Root object at 0x10fc96780>, '-', <__main__.NominalizerTerminal object at 0x10fc96710>, '-', <__main__.SemanticTerminal object at 0x10fc96198>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FLOWER terminal with values set()
we picked FLOWER_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: uno#FLOWER-e
full_pronunciation: uno#FLOWERa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 66.10000000000035
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 74.60000000000008
VocabularyItem:
    pronunciation: FLOWER
    label: FLOWER
    values: set()
    diacritic: FLOWER_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.300000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 24.699999999999804
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 35.00000000000004
line done
line done

---------------------

input line #496
input roots: [<__main__.Root object at 0x10fc2dc50>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 162.49999999999648..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 70.0000000000002..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 48.70000000000036..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 162.59999999999647..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 74.60000000000008..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 48.80000000000036..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 162.69999999999646..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: MILKCOW in its selectional

now working with the word 'MILKCOW-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'null_17'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'MILKCOW_1', 'null_17'}
     what if we combine triggers with the otherwise identical vi MILKCOW_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'MILKCOW_3', 'MILKCOW_1', 'null_17'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc969e8>, '#', <__main__.Root object at 0x10fc58f28>, '-', <__main__.NominalizerTerminal object at 0x10fc58be0>, '-', <__main__.SemanticTerminal object at 0x10fc96dd8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out MILKCOW terminal with values set()
we picked MILKCOW_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o_2'}
we picked null_19: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: le#MILKCOW-e
full_pronunciation: l#MILKCOWi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 162.69999999999646
VocabularyItem:
    pronunciation: MILKCOW
    label: MILKCOW
    values: set()
    diacritic: MILKCOW_1
    triggers: set()
    weight: 11.000000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_19
    triggers: {('e', frozenset({'+atomic'}))}
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 27.400000000000034
line done
line done

---------------------

input line #497
input roots: [<__main__.Root object at 0x10fc58470>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 162.69999999999646..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 70.1000000000002..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 48.20000000000034..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 162.79999999999646..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 74.70000000000007..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 48.30000000000034..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 162.89999999999645..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'CHILD_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi CHILD_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CHILD_1', 'null_15', 'CHILD_4', 'i_1', 'null_14'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc86438>, '#', <__main__.Root object at 0x10fc86240>, '-', <__main__.NominalizerTerminal object at 0x10fc86390>, '-', <__main__.SemanticTerminal object at 0x10fc86be0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out CHILD terminal with values set()
we picked CHILD_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: li#CHILD-i
full_pronunciation: l#CHILDi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 162.89999999999645
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_2
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 10.900000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 12.400000000000013
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 27.400000000000034
line done
line done

---------------------

input line #498
input roots: [<__main__.Root object at 0x10fc86978>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 162.89999999999645..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 48.90000000000036..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 74.80000000000007..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 162.99999999999645..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 74.90000000000006..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 66.10000000000035..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 163.09999999999644..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 163.19999999999644..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 48.40000000000034..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 75.00000000000006..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FLOWER in its selectional

now working with the word 'FLOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19', 'FLOWER_1'}
     what if we combine triggers with the otherwise identical vi FLOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FLOWER_3', 'e_3', 'null_19', 'FLOWER_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc43438>, '-', <__main__.AgrTerminal object at 0x10fc580b8>, '#', <__main__.Root object at 0x10fc43f60>, '-', <__main__.NominalizerTerminal object at 0x10fc43860>, '-', <__main__.SemanticTerminal object at 0x10fc43ba8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FLOWER terminal with values set()
we picked FLOWER_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o_2'}
we picked null_8: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: lo#FLOWER-e
full_pronunciation: lo#FLOWERe
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: FLOWER to the selectional of the nominalizer whose values are {'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'o_2'}
    selectional: {'MOUSE', 'CHILD', 'BOOK', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 81.19999999999968
    linear: (<__main__.NominalizerTerminal object at 0x10fc08908>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_20, triggers = set(), weight = 12.599999999999998..already existed

create_vi: tried nominalizer: null_30, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.499999999999998..already existed

create_vi: tried nominalizer: null_31, triggers = {('e', frozenset({'-atomic'}))}, weight = 10.699999999999998..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_12, triggers = set(), weight = 12.299999999999997..already existed

create_vi: tried nominalizer: null_13, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.599999999999998..already existed
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 163.19999999999644
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 75.00000000000006
VocabularyItem:
    pronunciation: FLOWER
    label: FLOWER
    values: set()
    diacritic: FLOWER_1
    triggers: set()
    weight: 9.900000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 14.000000000000012
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 17.900000000000006
line done
line done

---------------------

input line #499
input roots: [<__main__.Root object at 0x10fc67ba8>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 70.20000000000019..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 163.79999999999643..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 66.20000000000034..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 66.30000000000034..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'OFFSPRING_1', 'null_11', 'null_10', 'OFFSPRING_5'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50748>, '-', <__main__.AgrTerminal object at 0x10fc42208>, '#', <__main__.Root object at 0x10fc50b38>, '-', <__main__.NominalizerTerminal object at 0x10fc50358>, '-', <__main__.SemanticTerminal object at 0x10fc50550>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i_2', 'o_2'}
we picked null_19: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: una#OFFSPRING-a
full_pronunciation: uno#OFFSPRINGe
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 66.30000000000034
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 75.50000000000006
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_1
    triggers: set()
    weight: 11.000000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_19
    triggers: {('e', frozenset({'+atomic'}))}
    weight: 9.600000000000001
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 18.400000000000006
line done
line done

---------------------

input line #500
input roots: [<__main__.Root object at 0x10fc3c748>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 163.89999999999642..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 70.30000000000018..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 49.00000000000036..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 163.99999999999642..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 75.50000000000006..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 49.100000000000364..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 164.0999999999964..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: CAR in its selectional

now working with the word 'CAR-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'null_17'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'CAR_1', 'null_17'}
     what if we combine triggers with the otherwise identical vi CAR_3 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'CAR_2', 'null_16', 'null_17', 'CAR_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a9e8>, '-', <__main__.AgrTerminal object at 0x10fc509e8>, '#', <__main__.Root object at 0x10fc6a080>, '-', <__main__.NominalizerTerminal object at 0x10fc6a2e8>, '-', <__main__.SemanticTerminal object at 0x10fc6ada0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic', 'a_2'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CAR terminal with values set()
we picked CAR_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e', 'e_1', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: le#CAR-e
full_pronunciation: le#CARe
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CAR to the selectional of the nominalizer whose values are {'e_1', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1', 'a_2'}
    selectional: {'FROG', 'BALL', 'CHILD', 'TOWER', 'PIBLING', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 30.300000000000093
    linear: (<__main__.NominalizerTerminal object at 0x10fc2aa20>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 164.0999999999964
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 49.100000000000364
VocabularyItem:
    pronunciation: CAR
    label: CAR
    values: set()
    diacritic: CAR_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 11.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 12.300000000000013
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 17.200000000000006
line done
line done

---------------------

input line #501
input roots: [<__main__.Root object at 0x10fc50d30>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 164.6999999999964..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 49.700000000000365..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 70.40000000000018..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 164.7999999999964..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 70.50000000000017..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 66.30000000000034..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 164.8999999999964..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 164.9999999999964..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 48.50000000000034..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 70.60000000000016..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'GRANDPARENT_1'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'GRANDPARENT_1', 'null_11', 'null_10', 'GRANDPARENT_3'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc31e10>, '-', <__main__.AgrTerminal object at 0x10fc6a208>, '#', <__main__.Root object at 0x10fc185c0>, '-', <__main__.NominalizerTerminal object at 0x10fc20b38>, '-', <__main__.SemanticTerminal object at 0x10fc35fd0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_5: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: la#GRANDPARENT-a
full_pronunciation: la#GRANDPARENTo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 164.9999999999964
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 70.60000000000016
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_5
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 9.600000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 24.599999999999802
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 34.00000000000004
line done
line done

---------------------

input line #502
input roots: [<__main__.Root object at 0x10fc58898>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 70.60000000000016..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 164.9999999999964..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 66.40000000000033..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 66.50000000000033..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1', 'i_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'a_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_24', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_25', 'null_24', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_25', 'null_24', 'a_1', 'CHILD_1'}
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CHILD_1', 'a_1', 'null_25', 'CHILD_2', 'null_24'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b048>, '-', <__main__.AgrTerminal object at 0x10fc41be0>, '#', <__main__.Root object at 0x10fc361d0>, '-', <__main__.NominalizerTerminal object at 0x10fc4be10>, '-', <__main__.SemanticTerminal object at 0x10fc4bb00>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a', 'i_2', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: una#CHILD-a
full_pronunciation: una#CHILDa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CHILD to the selectional of the nominalizer whose values are {'i_2', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'a_2'}
    selectional: {'BOOK', 'CHILD', 'BALL', 'FROG', 'PIBLING', 'FLOWER', 'GRANDPARENT', 'TOWER', 'CASTLE', 'CAR', 'KEY', 'CLOWN', 'FOOT', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 24.10000000000003
    linear: (<__main__.NominalizerTerminal object at 0x10fc36a90>,)
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 66.50000000000033
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 70.60000000000016
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_2
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 10.800000000000002
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 12.800000000000013
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 35.200000000000045
line done
line done

---------------------

input line #503
input roots: [<__main__.Root object at 0x10fc4bf28>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 165.09999999999638..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 71.20000000000016..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 48.60000000000034..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 165.19999999999638..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 75.60000000000005..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 48.700000000000344..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 165.29999999999637..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'CHILD_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi CHILD_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CHILD_1', 'null_15', 'CHILD_4', 'i_1', 'null_14'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc96908>, '#', <__main__.Root object at 0x10fca90b8>, '-', <__main__.NominalizerTerminal object at 0x10fca9048>, '-', <__main__.SemanticTerminal object at 0x10fc96f28>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out CHILD terminal with values set()
we picked CHILD_7: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: li#CHILD-i
full_pronunciation: l#CHILDe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 165.29999999999637
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_7
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 9.600000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 24.4999999999998
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 17.700000000000006
line done
line done

---------------------

input line #504
input roots: [<__main__.Root object at 0x10fc96eb8>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 165.29999999999637..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 71.30000000000015..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 48.800000000000345..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 165.39999999999637..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 75.70000000000005..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 48.90000000000035..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 165.49999999999636..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'PIBLING_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi PIBLING_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_5 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_7', 'null_15', 'PIBLING_1', 'i_1', 'null_14'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc504e0>, '#', <__main__.Root object at 0x10fc505c0>, '-', <__main__.NominalizerTerminal object at 0x10fc502e8>, '-', <__main__.SemanticTerminal object at 0x10fc50160>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out PIBLING terminal with values set()
we picked PIBLING_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: li#PIBLING-i
full_pronunciation: l#PIBLINGe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 165.49999999999636
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 9.900000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 24.3999999999998
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 17.600000000000005
line done
line done

---------------------

input line #505
input roots: [<__main__.Root object at 0x10fc50390>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 165.49999999999636..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 71.40000000000015..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 49.80000000000037..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 165.59999999999636..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 75.80000000000004..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 49.90000000000037..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 165.69999999999635..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: BALL in its selectional

now working with the word 'BALL-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'null_17'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'BALL_1', 'null_17'}
     what if we combine triggers with the otherwise identical vi BALL_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'BALL_1', 'BALL_3', 'null_17'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc500b8>, '#', <__main__.Root object at 0x10fc2dd68>, '-', <__main__.NominalizerTerminal object at 0x10fc2db70>, '-', <__main__.SemanticTerminal object at 0x10fc2d3c8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out BALL terminal with values set()
we picked BALL_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: le#BALL-e
full_pronunciation: l#BALLe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 165.69999999999635
VocabularyItem:
    pronunciation: BALL
    label: BALL
    values: set()
    diacritic: BALL_3
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 10.600000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 14.500000000000012
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 17.600000000000005
line done
line done

---------------------

input line #506
input roots: [<__main__.Root object at 0x10fc2d748>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 165.69999999999635..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 71.50000000000014..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 50.00000000000037..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 165.79999999999634..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 75.90000000000003..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 50.10000000000037..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 165.89999999999634..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: KEY in its selectional

now working with the word 'KEY-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_6', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_6', 'null_7', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'KEY_1', 'null_6', 'null_7', 'i_1'}
     what if we combine triggers with the otherwise identical vi KEY_3 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'KEY_1', 'null_7', 'i_1', 'KEY_2', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc96198>, '#', <__main__.Root object at 0x10fc96518>, '-', <__main__.NominalizerTerminal object at 0x10fc96ba8>, '-', <__main__.SemanticTerminal object at 0x10fc96a58>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out KEY terminal with values set()
we picked KEY_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: le#KEY-i
full_pronunciation: l#KEYi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 165.89999999999634
VocabularyItem:
    pronunciation: KEY
    label: KEY
    values: set()
    diacritic: KEY_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.000000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 24.299999999999798
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 27.600000000000037
line done
line done

---------------------

input line #507
input roots: [<__main__.Root object at 0x10fc96b38>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 165.89999999999634..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 50.20000000000037..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 71.60000000000014..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 165.99999999999633..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 71.70000000000013..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 67.10000000000032..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 166.09999999999633..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 166.19999999999632..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 49.00000000000035..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 71.80000000000013..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_2', 'a_1', 'PIBLING_1', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc580b8>, '-', <__main__.AgrTerminal object at 0x10fc96358>, '#', <__main__.Root object at 0x10fc585c0>, '-', <__main__.NominalizerTerminal object at 0x10fc58860>, '-', <__main__.SemanticTerminal object at 0x10fc58d30>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'a_2'}
we picked null_29: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: la#PIBLING-a
full_pronunciation: la#PIBLINGe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 166.19999999999632
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 71.80000000000013
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_1
    triggers: set()
    weight: 11.500000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_29
    triggers: {('e', frozenset({'+atomic'}))}
    weight: 9.8
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 18.300000000000004
line done
line done

---------------------

input line #508
input roots: [<__main__.Root object at 0x10fc96128>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 166.19999999999632..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 71.80000000000013..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 50.300000000000374..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 166.29999999999632..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 76.00000000000003..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 50.400000000000375..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 166.3999999999963..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'PIBLING_1', 'null_6'}
     what if we combine triggers with the otherwise identical vi PIBLING_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_5 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'PIBLING_3', 'PIBLING_1', 'null_26', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc58748>, '#', <__main__.Root object at 0x10fc43208>, '-', <__main__.NominalizerTerminal object at 0x10fc433c8>, '-', <__main__.SemanticTerminal object at 0x10fc58438>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked le_1: no super match (neither decl nor L1-gender)
now spelling out PIBLING terminal with values set()
we picked PIBLING_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: le#PIBLING-e
full_pronunciation: le#PIBLINGe
vis_used:
Successful derivation!
VocabularyItem:
    pronunciation: le
    label: definite
    values: {'+definite', '-atomic'}
    diacritic: le_1
    triggers: set()
    weight: 10.800000000000002
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_2
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 10.700000000000001
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 13.300000000000013
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 17.600000000000005
line done
line done

---------------------

input line #509
input roots: [<__main__.Root object at 0x10fc58048>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 166.4999999999963..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 50.50000000000038..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 71.90000000000012..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 166.5999999999963..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 72.00000000000011..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 67.20000000000032..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 166.6999999999963..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 166.7999999999963..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 49.10000000000035..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 72.10000000000011..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: TOWER in its selectional

now working with the word 'TOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'TOWER_1', 'e_3', 'null_10'}
     what if we combine triggers with the otherwise identical vi TOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'TOWER_1', 'TOWER_3', 'e_3', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc47e10>, '-', <__main__.AgrTerminal object at 0x10fc43630>, '#', <__main__.Root object at 0x10fc4b4a8>, '-', <__main__.NominalizerTerminal object at 0x10fc28128>, '-', <__main__.SemanticTerminal object at 0x10fc47588>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'i_2', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out TOWER terminal with values set()
we picked TOWER_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i_2', 'o_2'}
we picked null_8: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: la#TOWER-e
full_pronunciation: lo#TOWERa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 166.7999999999963
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 76.00000000000003
VocabularyItem:
    pronunciation: TOWER
    label: TOWER
    values: set()
    diacritic: TOWER_1
    triggers: set()
    weight: 9.500000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 14.400000000000013
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 35.80000000000005
line done
line done

---------------------

input line #510
input roots: [<__main__.Root object at 0x10fc47400>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 166.7999999999963..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 72.2000000000001..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 49.20000000000035..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 166.89999999999628..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 76.00000000000003..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 49.30000000000035..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 166.99999999999628..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: BOOK in its selectional

now working with the word 'BOOK-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'BOOK_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi BOOK_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_15', 'BOOK_2', 'BOOK_1', 'i_1', 'null_14'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4bcc0>, '-', <__main__.AgrTerminal object at 0x10fc4b1d0>, '#', <__main__.Root object at 0x10fc4b358>, '-', <__main__.NominalizerTerminal object at 0x10fc4b630>, '-', <__main__.SemanticTerminal object at 0x10fc4b6a0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'a_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BOOK terminal with values set()
we picked BOOK_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i_2', 'a_2'}
we picked null_29: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: li#BOOK-i
full_pronunciation: li#BOOKi
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: BOOK to the selectional of the nominalizer whose values are {'i_2', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'a_2'}
    selectional: {'BOOK', 'CHILD', 'BALL', 'FROG', 'PIBLING', 'FLOWER', 'GRANDPARENT', 'TOWER', 'CASTLE', 'CAR', 'KEY', 'CLOWN', 'FOOT', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 24.300000000000033
    linear: (<__main__.NominalizerTerminal object at 0x10fc36a90>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 166.99999999999628
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 49.30000000000035
VocabularyItem:
    pronunciation: BOOK
    label: BOOK
    values: set()
    diacritic: BOOK_1
    triggers: set()
    weight: 11.100000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_29
    triggers: {('e', frozenset({'+atomic'}))}
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 27.600000000000037
line done
line done

---------------------

input line #511
input roots: [<__main__.Root object at 0x10fc4b400>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 72.3000000000001..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 167.59999999999627..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 67.30000000000031..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 67.4000000000003..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: FROG in its selectional

now working with the word 'FROG-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi FROG_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_2', 'a_1', 'FROG_1', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b128>, '#', <__main__.Root object at 0x10fc6fcf8>, '-', <__main__.NominalizerTerminal object at 0x10fc6f7b8>, '-', <__main__.SemanticTerminal object at 0x10fc41eb8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite', '+atomic'}
we picked una_1: no super match (neither decl nor L1-gender)
now spelling out FROG terminal with values set()
we picked FROG_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values set()
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: una#FROG-a
full_pronunciation: una#FROGa
vis_used:
Successful derivation!
VocabularyItem:
    pronunciation: una
    label: definite
    values: {'-definite', '+atomic'}
    diacritic: una_1
    triggers: set()
    weight: 11.300000000000002
VocabularyItem:
    pronunciation: FROG
    label: FROG
    values: set()
    diacritic: FROG_1
    triggers: set()
    weight: 10.500000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 24.199999999999797
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 35.80000000000005
line done
line done

---------------------

input line #512
input roots: [<__main__.Root object at 0x10fc41940>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 167.69999999999627..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 72.40000000000009..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 49.900000000000354..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 167.79999999999626..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 76.10000000000002..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 50.000000000000355..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 167.89999999999625..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'CHILD_1', 'i_1'}
     what if we combine triggers with the otherwise identical vi CHILD_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CHILD_1', 'null_12', 'null_13', 'CHILD_4', 'i_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b588>, '#', <__main__.Root object at 0x10fc4b860>, '-', <__main__.NominalizerTerminal object at 0x10fc4bfd0>, '-', <__main__.SemanticTerminal object at 0x10fc4b908>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked li_1: no super match (neither decl nor L1-gender)
now spelling out CHILD terminal with values set()
we picked CHILD_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: li#CHILD-i
full_pronunciation: li#CHILDe
vis_used:
Failure
VocabularyItem:
    pronunciation: li
    label: definite
    values: {'+definite', '-atomic'}
    diacritic: li_1
    triggers: set()
    weight: 11.300000000000002
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_3
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 10.400000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 24.699999999999797
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 18.100000000000005
line done
line done

---------------------

input line #513
input roots: [<__main__.Root object at 0x10fc4b898>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 167.99999999999625..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 50.60000000000038..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 72.50000000000009..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 168.09999999999624..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 72.60000000000008..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 67.5000000000003..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 168.19999999999624..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 168.29999999999623..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 50.10000000000036..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 72.70000000000007..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'CHILD_1', 'a_1'}
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CHILD_1', 'a_1', 'CHILD_2', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc47c18>, '-', <__main__.AgrTerminal object at 0x10fc4b4a8>, '#', <__main__.Root object at 0x10fc20b38>, '-', <__main__.NominalizerTerminal object at 0x10fc1b710>, '-', <__main__.SemanticTerminal object at 0x10fc471d0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: la#CHILD-a
full_pronunciation: lo#CHILDe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 168.29999999999623
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 76.10000000000002
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_4
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 14.300000000000013
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 18.300000000000004
line done
line done

---------------------

input line #514
input roots: [<__main__.Root object at 0x10fc47780>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 76.10000000000002..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 168.29999999999623..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 67.60000000000029..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 67.70000000000029..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FOOT in its selectional

now working with the word 'FOOT-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FOOT_1', 'null_8', 'e_3', 'null_19'}
     what if we combine triggers with the otherwise identical vi FOOT_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FOOT_1', 'e_3', 'FOOT_2', 'null_19'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc08358>, '#', <__main__.Root object at 0x10fc58e80>, '-', <__main__.NominalizerTerminal object at 0x10fc584e0>, '-', <__main__.SemanticTerminal object at 0x10fc584a8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite', 'i_2', '+atomic'}
we picked uno_1: no super match (neither decl nor L1-gender)
now spelling out FOOT terminal with values set()
we picked FOOT_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'i_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: uno#FOOT-e
full_pronunciation: uno#FOOTe
vis_used:
Successful derivation!
VocabularyItem:
    pronunciation: uno
    label: definite
    values: {'-definite', '+atomic'}
    diacritic: uno_1
    triggers: set()
    weight: 9.300000000000002
VocabularyItem:
    pronunciation: FOOT
    label: FOOT
    values: set()
    diacritic: FOOT_2
    triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))}
    weight: 10.8
     what if we combine triggers with the otherwise identical vi FOOT_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 24.599999999999795
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 18.300000000000004
line done
line done

---------------------

input line #515
input roots: [<__main__.Root object at 0x10fc47160>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 72.80000000000007..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 168.39999999999623..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 67.80000000000028..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 67.90000000000028..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_2', 'a_1', 'PIBLING_1', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc18588>, '-', <__main__.AgrTerminal object at 0x10fc58358>, '#', <__main__.Root object at 0x10fc363c8>, '-', <__main__.NominalizerTerminal object at 0x10fc18828>, '-', <__main__.SemanticTerminal object at 0x10fc185c0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_5: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: una#PIBLING-a
full_pronunciation: uno#PIBLINGo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 67.90000000000028
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 76.10000000000002
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_5
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 10.400000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 14.200000000000014
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 33.90000000000004
line done
line done

---------------------

input line #516
input roots: [<__main__.Root object at 0x10fc18748>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 168.49999999999622..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 72.90000000000006..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 50.70000000000038..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 168.59999999999621..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 76.10000000000002..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 50.80000000000038..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 168.6999999999962..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: MILKCOW in its selectional

now working with the word 'MILKCOW-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'MILKCOW_1', 'null_6'}
     what if we combine triggers with the otherwise identical vi MILKCOW_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'MILKCOW_3', 'MILKCOW_1', 'null_26', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc58e10>, '#', <__main__.Root object at 0x10fc05320>, '-', <__main__.NominalizerTerminal object at 0x10fc05470>, '-', <__main__.SemanticTerminal object at 0x10fc2d588>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out MILKCOW terminal with values set()
we picked MILKCOW_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: le#MILKCOW-e
full_pronunciation: l#MILKCOWe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 168.6999999999962
VocabularyItem:
    pronunciation: MILKCOW
    label: MILKCOW
    values: set()
    diacritic: MILKCOW_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 11.4
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 25.099999999999795
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 18.100000000000005
line done
line done

---------------------

input line #517
input roots: [<__main__.Root object at 0x10fc2d518>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 168.6999999999962..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 50.90000000000038..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 73.00000000000006..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 168.7999999999962..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 73.10000000000005..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 67.90000000000028..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 168.8999999999962..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 168.9999999999962..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 50.20000000000036..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 73.20000000000005..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: KEY in its selectional

now working with the word 'KEY-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'KEY_1', 'null_10'}
     what if we combine triggers with the otherwise identical vi KEY_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'KEY_3', 'KEY_1', 'e_3', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc96940>, '-', <__main__.AgrTerminal object at 0x10fc36160>, '#', <__main__.Root object at 0x10fc96f60>, '-', <__main__.NominalizerTerminal object at 0x10fc96e80>, '-', <__main__.SemanticTerminal object at 0x10fc967b8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'i_2', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out KEY terminal with values set()
we picked KEY_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'i_2', 'o_2'}
we picked null_12 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: la#KEY-e
full_pronunciation: lo#KEYe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 168.9999999999962
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 76.10000000000002
VocabularyItem:
    pronunciation: KEY
    label: KEY
    values: set()
    diacritic: KEY_3
    triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))}
    weight: 9.400000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2', 'o_2'}
    diacritic: null_12
    triggers: set()
    weight: 12.299999999999997
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 18.900000000000006
line done
line done

---------------------

input line #518
input roots: [<__main__.Root object at 0x10fc96e10>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 168.9999999999962..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 51.000000000000384..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 73.30000000000004..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 169.0999999999962..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 73.40000000000003..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 68.00000000000027..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 169.19999999999618..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 169.29999999999617..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 50.30000000000036..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 73.50000000000003..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: FROG in its selectional

now working with the word 'FROG-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi FROG_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_2', 'a_1', 'FROG_1', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50d30>, '-', <__main__.AgrTerminal object at 0x10fc96dd8>, '#', <__main__.Root object at 0x10fc355c0>, '-', <__main__.NominalizerTerminal object at 0x10fc35a90>, '-', <__main__.SemanticTerminal object at 0x10fc50ba8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'i_2', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FROG terminal with values set()
we picked FROG_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'o_2'}
we picked null_14 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: la#FROG-a
full_pronunciation: lo#FROGe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 169.29999999999617
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 76.00000000000003
VocabularyItem:
    pronunciation: FROG
    label: FROG
    values: set()
    diacritic: FROG_3
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 9.400000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 13.8
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 18.800000000000004
line done
line done

---------------------

input line #519
input roots: [<__main__.Root object at 0x10fc504a8>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 73.60000000000002..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 169.29999999999617..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 68.10000000000026..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 68.20000000000026..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_2', 'a_1', 'PIBLING_1', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc505c0>, '-', <__main__.AgrTerminal object at 0x10fc35be0>, '#', <__main__.Root object at 0x10fc50d30>, '-', <__main__.NominalizerTerminal object at 0x10fc50ba8>, '-', <__main__.SemanticTerminal object at 0x10fc509e8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_6: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'i_2', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: una#PIBLING-a
full_pronunciation: uno#PIBLINGo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 68.20000000000026
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 75.90000000000003
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_6
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 10.4
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 24.999999999999794
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 33.80000000000004
line done
line done

---------------------

input line #520
input roots: [<__main__.Root object at 0x10fc502b0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 169.39999999999617..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 73.70000000000002..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 50.40000000000036..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 169.49999999999616..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 75.90000000000003..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 50.50000000000036..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 169.59999999999616..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: MOUSE in its selectional

now working with the word 'MOUSE-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'MOUSE_1', 'null_12', 'null_13', 'i_1'}
     what if we combine triggers with the otherwise identical vi MOUSE_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'MOUSE_3', 'null_12', 'null_13', 'i_1', 'MOUSE_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc96cf8>, '-', <__main__.AgrTerminal object at 0x10fc3bf98>, '#', <__main__.Root object at 0x10fc96ba8>, '-', <__main__.NominalizerTerminal object at 0x10fc96198>, '-', <__main__.SemanticTerminal object at 0x10fc96b70>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MOUSE terminal with values set()
we picked MOUSE_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: li#MOUSE-i
full_pronunciation: li#MOUSEi
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: MOUSE to the selectional of the nominalizer whose values are {'i_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2'}
    selectional: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 14.699999999999983
    linear: (<__main__.NominalizerTerminal object at 0x10fc0ecc0>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'a_2'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'a_2'}

create_vi: tried nominalizer: null_10, triggers = set(), weight = 13.900000000000013..already existed

create_vi: tried nominalizer: null_11, triggers = {('a', frozenset({'+atomic'}))}, weight = 11.4..already existed

create_vi: tried nominalizer: null_29, triggers = {('e', frozenset({'+atomic'}))}, weight = 10.3..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'o_2'} as values: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'o_2'}

create_vi: tried nominalizer: null_8, triggers = set(), weight = 14.200000000000014..already existed

create_vi: tried nominalizer: null_9, triggers = {('o', frozenset({'+atomic'}))}, weight = 11.3..already existed

create_vi: tried nominalizer: null_19, triggers = {('e', frozenset({'+atomic'}))}, weight = 9.600000000000001..already existed
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 169.59999999999616
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 50.50000000000036
VocabularyItem:
    pronunciation: MOUSE
    label: MOUSE
    values: set()
    diacritic: MOUSE_2
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 10.500000000000002
     what if we combine triggers with the otherwise identical vi MOUSE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 24.899999999999793
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 28.30000000000004
line done
line done

---------------------

input line #521
input roots: [<__main__.Root object at 0x10fc96cc0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 170.19999999999615..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 73.80000000000001..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 51.100000000000385..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 170.29999999999615..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 76.00000000000003..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 51.20000000000039..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 170.39999999999614..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: CHILD in its selectional

now working with the word 'CHILD-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6', 'CHILD_1'}
     what if we combine triggers with the otherwise identical vi CHILD_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'CHILD_1', 'CHILD_7', 'null_26', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc2deb8>, '-', <__main__.AgrTerminal object at 0x10fc2f128>, '#', <__main__.Root object at 0x10fc362b0>, '-', <__main__.NominalizerTerminal object at 0x10fc36160>, '-', <__main__.SemanticTerminal object at 0x10fc2dc50>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'o_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_7: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'i_2', 'o_2'}
we picked null_12 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: le#CHILD-e
full_pronunciation: li#CHILDe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 170.39999999999614
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 51.00000000000036
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_7
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 9.500000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2', 'o_2'}
    diacritic: null_12
    triggers: set()
    weight: 12.199999999999998
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 18.100000000000005
line done
line done

---------------------

input line #522
input roots: [<__main__.Root object at 0x10fc96518>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 73.9..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 170.39999999999614..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 68.20000000000026..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 68.30000000000025..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: CAR in its selectional

now working with the word 'CAR-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'CAR_1'}
     what if we combine triggers with the otherwise identical vi CAR_2 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'null_10', 'CAR_1', 'null_11', 'CAR_3'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc58cc0>, '-', <__main__.AgrTerminal object at 0x10fc18240>, '#', <__main__.Root object at 0x10fc587b8>, '-', <__main__.NominalizerTerminal object at 0x10fc580f0>, '-', <__main__.SemanticTerminal object at 0x10fc585c0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CAR terminal with values set()
we picked CAR_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1', 'o_2'}
we picked null_20: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: una#CAR-a
full_pronunciation: uno#CARe
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 68.30000000000025
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 76.00000000000003
VocabularyItem:
    pronunciation: CAR
    label: CAR
    values: set()
    diacritic: CAR_1
    triggers: set()
    weight: 9.400000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1', 'o_2'}
    diacritic: null_20
    triggers: set()
    weight: 12.599999999999998
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 18.700000000000003
line done
line done

---------------------

input line #523
input roots: [<__main__.Root object at 0x10fc50898>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 170.49999999999613..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 74.0..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 51.00000000000036..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 170.59999999999613..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 76.00000000000003..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 51.100000000000364..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 170.69999999999612..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: CASTLE in its selectional

now working with the word 'CASTLE-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'CASTLE_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi CASTLE_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_15', 'i_1', 'null_14', 'CASTLE_1', 'CASTLE_3'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc43438>, '-', <__main__.AgrTerminal object at 0x10fc58160>, '#', <__main__.Root object at 0x10fc08400>, '-', <__main__.NominalizerTerminal object at 0x10fc080b8>, '-', <__main__.SemanticTerminal object at 0x10fc438d0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic', 'a_2'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CASTLE terminal with values set()
we picked CASTLE_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: li#CASTLE-i
full_pronunciation: le#CASTLEi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 170.69999999999612
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 51.20000000000039
VocabularyItem:
    pronunciation: CASTLE
    label: CASTLE
    values: set()
    diacritic: CASTLE_2
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 12.400000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 25.399999999999793
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 28.90000000000004
line done
line done

---------------------

input line #524
input roots: [<__main__.Root object at 0x10fc05e80>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 170.69999999999612..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 51.20000000000039..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 74.1..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 170.79999999999612..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 74.19999999999999..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 68.30000000000025..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 170.8999999999961..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 170.9999999999961..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 51.200000000000365..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 74.29999999999998..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: MILKCOW in its selectional

now working with the word 'MILKCOW-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'MILKCOW_1'}
     what if we combine triggers with the otherwise identical vi MILKCOW_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'MILKCOW_1', 'MILKCOW_2', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b828>, '-', <__main__.AgrTerminal object at 0x10fc43eb8>, '#', <__main__.Root object at 0x10fc4bba8>, '-', <__main__.NominalizerTerminal object at 0x10fc4bb00>, '-', <__main__.SemanticTerminal object at 0x10fc4b240>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MILKCOW terminal with values set()
we picked MILKCOW_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#MILKCOW-a
full_pronunciation: la#MILKCOWa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: MILKCOW to the selectional of the nominalizer whose values are {'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'a_2'}
    selectional: {'FROG', 'CHILD', 'BALL', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 78.49999999999983
    linear: (<__main__.NominalizerTerminal object at 0x10fc05f28>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'FROG', 'BALL', 'CHILD', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_6, triggers = set(), weight = 11.9..already existed

create_vi: tried nominalizer: null_7, triggers = {('i', frozenset({'-atomic'}))}, weight = 12.199999999999992..already existed

create_vi: tried nominalizer: null_26, triggers = {('e', frozenset({'-atomic'}))}, weight = 13.799999999999992..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_14, triggers = set(), weight = 13.8..already existed

create_vi: tried nominalizer: null_15, triggers = {('i', frozenset({'-atomic'}))}, weight = 12.399999999999991..already existed
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 170.9999999999961
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 74.29999999999998
VocabularyItem:
    pronunciation: MILKCOW
    label: MILKCOW
    values: set()
    diacritic: MILKCOW_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 11.3
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 25.29999999999979
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 36.900000000000055
line done
line done

---------------------

input line #525
input roots: [<__main__.Root object at 0x10fc281d0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 171.5999999999961..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 51.30000000000039..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 74.89999999999998..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 171.6999999999961..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 74.99999999999997..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 68.40000000000025..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 171.7999999999961..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 171.89999999999608..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 51.30000000000037..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 75.09999999999997..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: CAR in its selectional

now working with the word 'CAR-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'CAR_1'}
     what if we combine triggers with the otherwise identical vi CAR_2 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'null_10', 'CAR_1', 'null_11', 'CAR_3'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc22be0>, '-', <__main__.AgrTerminal object at 0x10fc4ba20>, '#', <__main__.Root object at 0x10fc41080>, '-', <__main__.NominalizerTerminal object at 0x10fc410f0>, '-', <__main__.SemanticTerminal object at 0x10fc411d0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CAR terminal with values set()
we picked CAR_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#CAR-a
full_pronunciation: lo#CARa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 171.89999999999608
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 76.00000000000003
VocabularyItem:
    pronunciation: CAR
    label: CAR
    values: set()
    diacritic: CAR_3
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 9.400000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 25.79999999999979
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 37.50000000000006
line done
line done

---------------------

input line #526
input roots: [<__main__.Root object at 0x10fc4b940>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 75.19999999999996..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 171.89999999999608..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 68.50000000000024..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 68.60000000000024..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: TOWER in its selectional

now working with the word 'TOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'TOWER_1', 'e_3', 'null_10'}
     what if we combine triggers with the otherwise identical vi TOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'TOWER_1', 'TOWER_3', 'e_3', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc412b0>, '-', <__main__.AgrTerminal object at 0x10fc6f080>, '#', <__main__.Root object at 0x10fc22b70>, '-', <__main__.NominalizerTerminal object at 0x10fc228d0>, '-', <__main__.SemanticTerminal object at 0x10fc41be0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out TOWER terminal with values set()
we picked TOWER_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'i_2', 'a_2'}
we picked null_14 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: una#TOWER-e
full_pronunciation: una#TOWERe
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: TOWER to the selectional of the nominalizer whose values are {'i_2', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'a_2'}
    selectional: {'BOOK', 'CHILD', 'BALL', 'FROG', 'PIBLING', 'FLOWER', 'GRANDPARENT', 'TOWER', 'CASTLE', 'CAR', 'KEY', 'CLOWN', 'FOOT', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 25.500000000000036
    linear: (<__main__.NominalizerTerminal object at 0x10fc36a90>,)
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 68.60000000000024
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 75.19999999999996
VocabularyItem:
    pronunciation: TOWER
    label: TOWER
    values: set()
    diacritic: TOWER_3
    triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))}
    weight: 11.600000000000001
     what if we combine triggers with the otherwise identical vi TOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 13.8
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 18.700000000000003
line done
line done

---------------------

input line #527
input roots: [<__main__.Root object at 0x10fc6f898>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 171.99999999999608..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 51.40000000000039..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 76.00000000000003..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 172.09999999999607..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 76.10000000000002..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 69.20000000000023..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 172.19999999999607..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 172.29999999999606..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 51.40000000000037..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 76.20000000000002..already existed
  we're in a functional word...
  - nominalizer's values are now {'i_2', 'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: BOOK in its selectional

now working with the word 'BOOK-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_18', 'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_18', 'o_1', 'BOOK_1', 'null_12'}
     what if we combine triggers with the otherwise identical vi BOOK_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'o_1', 'BOOK_1', 'BOOK_3', 'null_18'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b2b0>, '-', <__main__.AgrTerminal object at 0x10fc4ba20>, '#', <__main__.Root object at 0x10fc47780>, '-', <__main__.NominalizerTerminal object at 0x10fc1b710>, '-', <__main__.SemanticTerminal object at 0x10fc4ba90>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BOOK terminal with values set()
we picked BOOK_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: lo#BOOK-o
full_pronunciation: la#BOOKo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 172.29999999999606
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 75.69999999999996
VocabularyItem:
    pronunciation: BOOK
    label: BOOK
    values: set()
    diacritic: BOOK_3
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 9.900000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 13.900000000000013
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 33.80000000000004
line done
line done

---------------------

input line #528
input roots: [<__main__.Root object at 0x10fc411d0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 172.29999999999606..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 75.69999999999996..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 51.50000000000039..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 172.39999999999606..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 76.30000000000001..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 51.60000000000039..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 172.49999999999605..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: FROG in its selectional

now working with the word 'FROG-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'null_17'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_1', 'e_2', 'null_16', 'null_17'}
     what if we combine triggers with the otherwise identical vi FROG_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'FROG_1', 'FROG_3', 'null_17'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc43438>, '-', <__main__.AgrTerminal object at 0x10fc4bac8>, '#', <__main__.Root object at 0x10fc43c88>, '-', <__main__.NominalizerTerminal object at 0x10fc43780>, '-', <__main__.SemanticTerminal object at 0x10fc43940>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FROG terminal with values set()
we picked FROG_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'i_2'}
we picked null_14 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: le#FROG-e
full_pronunciation: li#FROGe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 172.49999999999605
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 51.40000000000037
VocabularyItem:
    pronunciation: FROG
    label: FROG
    values: set()
    diacritic: FROG_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.600000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 14.3
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 18.100000000000005
line done
line done

---------------------

input line #529
input roots: [<__main__.Root object at 0x10fc43ba8>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 172.49999999999605..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 51.700000000000394..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 75.79999999999995..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 172.59999999999604..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 75.89999999999995..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 69.30000000000022..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 172.69999999999604..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 172.79999999999603..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 51.40000000000037..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 75.99999999999994..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: BALL in its selectional

now working with the word 'BALL-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'BALL_1', 'a_1'}
     what if we combine triggers with the otherwise identical vi BALL_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'BALL_1', 'BALL_2', 'null_10', 'null_11'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc58be0>, '-', <__main__.AgrTerminal object at 0x10fc438d0>, '#', <__main__.Root object at 0x10fc10dd8>, '-', <__main__.NominalizerTerminal object at 0x10fc58fd0>, '-', <__main__.SemanticTerminal object at 0x10fc58ac8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BALL terminal with values set()
we picked BALL_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: la#BALL-a
full_pronunciation: lo#BALLa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 172.79999999999603
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 76.30000000000001
VocabularyItem:
    pronunciation: BALL
    label: BALL
    values: set()
    diacritic: BALL_3
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 10.500000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 25.69999999999979
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 37.50000000000006
line done
line done

---------------------

input line #530
input roots: [<__main__.Root object at 0x10fc580b8>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 172.79999999999603..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 76.09999999999994..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 51.800000000000395..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 172.89999999999603..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 76.30000000000001..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 51.9000000000004..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 172.99999999999602..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: CHILD in its selectional

now working with the word 'CHILD-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6', 'CHILD_1'}
     what if we combine triggers with the otherwise identical vi CHILD_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'CHILD_1', 'CHILD_7', 'null_26', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc2df28>, '-', <__main__.AgrTerminal object at 0x10fc58748>, '#', <__main__.Root object at 0x10fc05550>, '-', <__main__.NominalizerTerminal object at 0x10fc2dbe0>, '-', <__main__.SemanticTerminal object at 0x10fc2d3c8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'o_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: le#CHILD-e
full_pronunciation: li#CHILDi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 172.99999999999602
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 51.40000000000037
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_3
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 10.300000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 25.59999999999979
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 28.80000000000004
line done
line done

---------------------

input line #531
input roots: [<__main__.Root object at 0x10fc187b8>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 76.4..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 172.99999999999602..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 69.40000000000022..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 69.50000000000021..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FLOWER in its selectional

now working with the word 'FLOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19', 'FLOWER_1'}
     what if we combine triggers with the otherwise identical vi FLOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FLOWER_3', 'e_3', 'null_19', 'FLOWER_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc96198>, '-', <__main__.AgrTerminal object at 0x10fc2dc50>, '#', <__main__.Root object at 0x10fc96748>, '-', <__main__.NominalizerTerminal object at 0x10fc96710>, '-', <__main__.SemanticTerminal object at 0x10fc96cf8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FLOWER terminal with values set()
we picked FLOWER_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: uno#FLOWER-e
full_pronunciation: una#FLOWERa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 69.50000000000021
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 76.09999999999994
VocabularyItem:
    pronunciation: FLOWER
    label: FLOWER
    values: set()
    diacritic: FLOWER_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.200000000000003
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 13.800000000000013
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 37.400000000000055
line done
line done

---------------------

input line #532
input roots: [<__main__.Root object at 0x10fc96b70>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 76.5..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 173.09999999999602..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 69.50000000000021..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 69.60000000000021..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FLOWER in its selectional

now working with the word 'FLOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19', 'FLOWER_1'}
     what if we combine triggers with the otherwise identical vi FLOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FLOWER_3', 'e_3', 'null_19', 'FLOWER_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50390>, '-', <__main__.AgrTerminal object at 0x10fc96080>, '#', <__main__.Root object at 0x10fc356d8>, '-', <__main__.NominalizerTerminal object at 0x10fc505c0>, '-', <__main__.SemanticTerminal object at 0x10fc50ba8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FLOWER terminal with values set()
we picked FLOWER_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o_2'}
we picked null_9: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: uno#FLOWER-e
full_pronunciation: uno#FLOWERo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 69.60000000000021
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 76.5
VocabularyItem:
    pronunciation: FLOWER
    label: FLOWER
    values: set()
    diacritic: FLOWER_1
    triggers: set()
    weight: 10.400000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_9
    triggers: {('o', frozenset({'+atomic'}))}
    weight: 11.3
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 33.70000000000004
line done
line done

---------------------

input line #533
input roots: [<__main__.Root object at 0x10fc50d30>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 173.199999999996..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 76.09999999999994..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 52.0000000000004..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 173.299999999996..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 76.5..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 52.1000000000004..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 173.399999999996..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'PIBLING_1', 'null_6'}
     what if we combine triggers with the otherwise identical vi PIBLING_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_5 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'PIBLING_3', 'PIBLING_1', 'null_26', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50a58>, '-', <__main__.AgrTerminal object at 0x10fc35a90>, '#', <__main__.Root object at 0x10fc502b0>, '-', <__main__.NominalizerTerminal object at 0x10fc50860>, '-', <__main__.SemanticTerminal object at 0x10fc502e8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'o_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i_2', 'o_2'}
we picked null_19: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: le#PIBLING-e
full_pronunciation: li#PIBLINGi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 173.399999999996
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 51.30000000000037
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_1
    triggers: set()
    weight: 11.400000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_19
    triggers: {('e', frozenset({'+atomic'}))}
    weight: 9.600000000000001
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 28.70000000000004
line done
line done

---------------------

input line #534
input roots: [<__main__.Root object at 0x10fc50828>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 76.6..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 173.399999999996..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 69.60000000000021..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 69.7000000000002..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FOOT in its selectional

now working with the word 'FOOT-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FOOT_1', 'null_8', 'e_3', 'null_19'}
     what if we combine triggers with the otherwise identical vi FOOT_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FOOT_1', 'e_3', 'FOOT_2', 'null_19'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc96668>, '-', <__main__.AgrTerminal object at 0x10fc50400>, '#', <__main__.Root object at 0x10fc96128>, '-', <__main__.NominalizerTerminal object at 0x10fc96438>, '-', <__main__.SemanticTerminal object at 0x10fc96b00>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FOOT terminal with values set()
we picked FOOT_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i_2', 'a_2'}
we picked null_14: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: uno#FOOT-e
full_pronunciation: una#FOOTo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 69.7000000000002
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 76.09999999999994
VocabularyItem:
    pronunciation: FOOT
    label: FOOT
    values: set()
    diacritic: FOOT_1
    triggers: set()
    weight: 10.000000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 14.200000000000001
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 33.60000000000004
line done
line done

---------------------

input line #535
input roots: [<__main__.Root object at 0x10fc969e8>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 173.499999999996..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 76.09999999999994..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 51.30000000000037..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 173.599999999996..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 76.69999999999999..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 51.40000000000037..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 173.69999999999598..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: BOOK in its selectional

now working with the word 'BOOK-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'BOOK_1', 'null_12', 'null_13', 'i_1'}
     what if we combine triggers with the otherwise identical vi BOOK_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'BOOK_2', 'BOOK_1', 'null_13', 'i_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc2f128>, '-', <__main__.AgrTerminal object at 0x10fc96c88>, '#', <__main__.Root object at 0x10fc36390>, '-', <__main__.NominalizerTerminal object at 0x10fc36780>, '-', <__main__.SemanticTerminal object at 0x10fc363c8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic', 'o_2'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BOOK terminal with values set()
we picked BOOK_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i', 'e_1', 'o_2'}
we picked null_20 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#BOOK-i
full_pronunciation: le#BOOKi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 173.69999999999598
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 52.1000000000004
VocabularyItem:
    pronunciation: BOOK
    label: BOOK
    values: set()
    diacritic: BOOK_4
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 12.4
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1', 'o_2'}
    diacritic: null_20
    triggers: set()
    weight: 12.499999999999998
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 28.70000000000004
line done
line done

---------------------

input line #536
input roots: [<__main__.Root object at 0x10fc96d68>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 173.69999999999598..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 52.1000000000004..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 76.19999999999993..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 173.79999999999598..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 76.29999999999993..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 69.7000000000002..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 173.89999999999597..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 173.99999999999596..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 51.50000000000037..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 76.39999999999992..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'CHILD_1', 'a_1'}
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CHILD_1', 'a_1', 'CHILD_2', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc58cc0>, '-', <__main__.AgrTerminal object at 0x10fc361d0>, '#', <__main__.Root object at 0x10fc58278>, '-', <__main__.NominalizerTerminal object at 0x10fc58b70>, '-', <__main__.SemanticTerminal object at 0x10fc580f0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'i_2', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_5: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a', 'i_2', 'a_2'}
we picked null_14 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#CHILD-a
full_pronunciation: la#CHILDa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CHILD to the selectional of the nominalizer whose values are {'i_2', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'a_2'}
    selectional: {'BOOK', 'CHILD', 'BALL', 'FROG', 'PIBLING', 'FLOWER', 'GRANDPARENT', 'TOWER', 'CASTLE', 'CAR', 'KEY', 'CLOWN', 'FOOT', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 25.70000000000004
    linear: (<__main__.NominalizerTerminal object at 0x10fc36a90>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 173.99999999999596
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 76.39999999999992
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_5
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 10.9
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 14.100000000000001
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 37.400000000000055
line done
line done

---------------------

input line #537
input roots: [<__main__.Root object at 0x10fc58be0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 174.59999999999596..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 76.99999999999991..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 51.60000000000037..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 174.69999999999595..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 76.79999999999998..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 51.70000000000037..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 174.79999999999595..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: FOOT in its selectional

now working with the word 'FOOT-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'FOOT_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi FOOT_2 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_15', 'FOOT_3', 'FOOT_1', 'i_1', 'null_14'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc587b8>, '#', <__main__.Root object at 0x10fc207b8>, '-', <__main__.NominalizerTerminal object at 0x10fc43eb8>, '-', <__main__.SemanticTerminal object at 0x10fc433c8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out FOOT terminal with values set()
we picked FOOT_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#FOOT-i
full_pronunciation: l#FOOTi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 174.79999999999595
VocabularyItem:
    pronunciation: FOOT
    label: FOOT
    values: set()
    diacritic: FOOT_3
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.700000000000003
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 13.700000000000014
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 28.70000000000004
line done
line done

---------------------

input line #538
input roots: [<__main__.Root object at 0x10fc436a0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 174.79999999999595..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 52.2000000000004..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 76.89999999999998..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 174.89999999999594..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 76.99999999999997..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 69.8000000000002..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 174.99999999999594..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 175.09999999999593..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 51.800000000000374..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 77.09999999999997..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: MOUSE in its selectional

now working with the word 'MOUSE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'MOUSE_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi MOUSE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'MOUSE_2', 'MOUSE_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b908>, '-', <__main__.AgrTerminal object at 0x10fc582e8>, '#', <__main__.Root object at 0x10fc4b160>, '-', <__main__.NominalizerTerminal object at 0x10fc4beb8>, '-', <__main__.SemanticTerminal object at 0x10fc4bc50>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MOUSE terminal with values set()
we picked MOUSE_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'a_2'}
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: lo#MOUSE-o
full_pronunciation: la#MOUSEo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 175.09999999999593
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 76.99999999999991
VocabularyItem:
    pronunciation: MOUSE
    label: MOUSE
    values: set()
    diacritic: MOUSE_1
    triggers: set()
    weight: 9.300000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 25.499999999999787
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 33.60000000000004
line done
line done

---------------------

input line #539
input roots: [<__main__.Root object at 0x10fc1b9b0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 175.09999999999593..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 52.3000000000004..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 76.99999999999991..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 175.19999999999592..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 77.09999999999991..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 69.90000000000019..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 175.29999999999592..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 175.3999999999959..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 51.900000000000375..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 77.1999999999999..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'GRANDPARENT_1'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'GRANDPARENT_1', 'null_11', 'null_10', 'GRANDPARENT_3'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4be48>, '#', <__main__.Root object at 0x10fc22b70>, '-', <__main__.NominalizerTerminal object at 0x10fc22f60>, '-', <__main__.SemanticTerminal object at 0x10fc4b128>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '+atomic', 'i_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_5: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'i_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: la#GRANDPARENT-a
full_pronunciation: l#GRANDPARENTo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 175.3999999999959
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_5
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 9.500000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 25.399999999999785
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 33.500000000000036
line done
line done

---------------------

input line #540
input roots: [<__main__.Root object at 0x10fc4b4a8>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 175.3999999999959..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 52.400000000000404..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 77.19999999999996..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 175.4999999999959..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 77.29999999999995..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 70.00000000000018..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 175.5999999999959..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 175.6999999999959..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 52.00000000000038..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 77.39999999999995..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CLOWN in its selectional

now working with the word 'CLOWN-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CLOWN_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CLOWN_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'CLOWN_3', 'o_1', 'CLOWN_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6aac8>, '-', <__main__.AgrTerminal object at 0x10fc58198>, '#', <__main__.Root object at 0x10fc6a0f0>, '-', <__main__.NominalizerTerminal object at 0x10fc6a3c8>, '-', <__main__.SemanticTerminal object at 0x10fc6a4e0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CLOWN terminal with values set()
we picked CLOWN_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: lo#CLOWN-o
full_pronunciation: lo#CLOWNo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CLOWN to the selectional of the nominalizer whose values are {'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'o_2'}
    selectional: {'MOUSE', 'CHILD', 'BOOK', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 84.99999999999946
    linear: (<__main__.NominalizerTerminal object at 0x10fc08908>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_6, triggers = set(), weight = 12.0..already existed

create_vi: tried nominalizer: null_7, triggers = {('i', frozenset({'-atomic'}))}, weight = 12.299999999999992..already existed

create_vi: tried nominalizer: null_26, triggers = {('e', frozenset({'-atomic'}))}, weight = 13.899999999999991..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_14, triggers = set(), weight = 14.700000000000001..already existed

create_vi: tried nominalizer: null_15, triggers = {('i', frozenset({'-atomic'}))}, weight = 12.499999999999991..already existed
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 175.6999999999959
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 77.39999999999995
VocabularyItem:
    pronunciation: CLOWN
    label: CLOWN
    values: set()
    diacritic: CLOWN_4
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.500000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 25.299999999999784
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 33.500000000000036
line done
line done

---------------------

input line #541
input roots: [<__main__.Root object at 0x10fc6af28>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 77.2999999999999..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 176.2999999999959..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 70.10000000000018..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 70.20000000000017..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: BALL in its selectional

now working with the word 'BALL-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'BALL_1', 'a_1'}
     what if we combine triggers with the otherwise identical vi BALL_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'BALL_1', 'BALL_2', 'null_10', 'null_11'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b5c0>, '-', <__main__.AgrTerminal object at 0x10fc6add8>, '#', <__main__.Root object at 0x10fc4b8d0>, '-', <__main__.NominalizerTerminal object at 0x10fc4b7b8>, '-', <__main__.SemanticTerminal object at 0x10fc4b128>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BALL terminal with values set()
we picked BALL_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2', 'a'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: una#BALL-a
full_pronunciation: uno#BALLa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 70.20000000000017
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 77.89999999999995
VocabularyItem:
    pronunciation: BALL
    label: BALL
    values: set()
    diacritic: BALL_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.600000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 14.200000000000014
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 38.10000000000006
line done
line done

---------------------

input line #542
input roots: [<__main__.Root object at 0x10fc6a390>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 77.89999999999995..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 176.39999999999588..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 70.20000000000017..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 70.30000000000017..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: MOUSE in its selectional

now working with the word 'MOUSE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'MOUSE_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi MOUSE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'MOUSE_2', 'MOUSE_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc47400>, '-', <__main__.AgrTerminal object at 0x10fc4be10>, '#', <__main__.Root object at 0x10fc47ef0>, '-', <__main__.NominalizerTerminal object at 0x10fc47cf8>, '-', <__main__.SemanticTerminal object at 0x10fc470f0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MOUSE terminal with values set()
we picked MOUSE_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o_2'}
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: uno#MOUSE-o
full_pronunciation: uno#MOUSEo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: MOUSE to the selectional of the nominalizer whose values are {'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'o_2'}
    selectional: {'MOUSE', 'CHILD', 'BOOK', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 85.39999999999944
    linear: (<__main__.NominalizerTerminal object at 0x10fc08908>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_6, triggers = set(), weight = 12.1..already existed

create_vi: tried nominalizer: null_7, triggers = {('i', frozenset({'-atomic'}))}, weight = 12.399999999999991..already existed

create_vi: tried nominalizer: null_26, triggers = {('e', frozenset({'-atomic'}))}, weight = 13.999999999999991..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_14, triggers = set(), weight = 14.8..already existed

create_vi: tried nominalizer: null_15, triggers = {('i', frozenset({'-atomic'}))}, weight = 12.59999999999999..already existed
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 70.30000000000017
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 77.89999999999995
VocabularyItem:
    pronunciation: MOUSE
    label: MOUSE
    values: set()
    diacritic: MOUSE_1
    triggers: set()
    weight: 9.200000000000003
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 25.799999999999784
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 34.10000000000004
line done
line done

---------------------

input line #543
input roots: [<__main__.Root object at 0x10fc4b908>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 176.49999999999588..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 52.500000000000405..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 77.39999999999989..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 176.59999999999587..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 77.49999999999989..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 70.90000000000016..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 176.69999999999587..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 176.79999999999586..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 52.10000000000038..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 77.59999999999988..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: MILKCOW in its selectional

now working with the word 'MILKCOW-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'MILKCOW_1'}
     what if we combine triggers with the otherwise identical vi MILKCOW_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'MILKCOW_1', 'MILKCOW_2', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc58198>, '-', <__main__.AgrTerminal object at 0x10fc4b0f0>, '#', <__main__.Root object at 0x10fc58160>, '-', <__main__.NominalizerTerminal object at 0x10fc58e10>, '-', <__main__.SemanticTerminal object at 0x10fc58c18>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'i_2', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MILKCOW terminal with values set()
we picked MILKCOW_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'o_2', 'a'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#MILKCOW-a
full_pronunciation: lo#MILKCOWa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 176.79999999999586
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 78.39999999999995
VocabularyItem:
    pronunciation: MILKCOW
    label: MILKCOW
    values: set()
    diacritic: MILKCOW_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 11.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 14.100000000000014
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 38.10000000000006
line done
line done

---------------------

input line #544
input roots: [<__main__.Root object at 0x10fc43710>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 77.69999999999987..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 176.79999999999586..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 71.00000000000016..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 71.10000000000015..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: TOWER in its selectional

now working with the word 'TOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'TOWER_1', 'e_3', 'null_10'}
     what if we combine triggers with the otherwise identical vi TOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'TOWER_1', 'TOWER_3', 'e_3', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc185c0>, '-', <__main__.AgrTerminal object at 0x10fc280b8>, '#', <__main__.Root object at 0x10fc187b8>, '-', <__main__.NominalizerTerminal object at 0x10fc180f0>, '-', <__main__.SemanticTerminal object at 0x10fc184e0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out TOWER terminal with values set()
we picked TOWER_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: una#TOWER-e
full_pronunciation: una#TOWERe
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: TOWER to the selectional of the nominalizer whose values are {'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'a_2'}
    selectional: {'FROG', 'CHILD', 'BALL', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 81.79999999999964
    linear: (<__main__.NominalizerTerminal object at 0x10fc05f28>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'FROG', 'BALL', 'CHILD', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_6, triggers = set(), weight = 12.2..already existed

create_vi: tried nominalizer: null_7, triggers = {('i', frozenset({'-atomic'}))}, weight = 12.499999999999991..already existed

create_vi: tried nominalizer: null_26, triggers = {('e', frozenset({'-atomic'}))}, weight = 14.09999999999999..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_14, triggers = set(), weight = 14.9..already existed

create_vi: tried nominalizer: null_15, triggers = {('i', frozenset({'-atomic'}))}, weight = 12.69999999999999..already existed
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 71.10000000000015
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 77.69999999999987
VocabularyItem:
    pronunciation: TOWER
    label: TOWER
    values: set()
    diacritic: TOWER_3
    triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))}
    weight: 12.100000000000001
     what if we combine triggers with the otherwise identical vi TOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 26.299999999999784
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 19.60000000000001
line done
line done

---------------------

input line #545
input roots: [<__main__.Root object at 0x10fc581d0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 176.89999999999586..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 78.29999999999987..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 52.20000000000038..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 176.99999999999585..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 78.39999999999995..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 52.30000000000038..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 177.09999999999584..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: FOOT in its selectional

now working with the word 'FOOT-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'FOOT_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi FOOT_2 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_15', 'FOOT_3', 'FOOT_1', 'i_1', 'null_14'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a240>, '#', <__main__.Root object at 0x10fc05470>, '-', <__main__.NominalizerTerminal object at 0x10fc2d518>, '-', <__main__.SemanticTerminal object at 0x10fc2d3c8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out FOOT terminal with values set()
we picked FOOT_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'a_2'}
we picked null_29: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: li#FOOT-i
full_pronunciation: l#FOOTi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 177.09999999999584
VocabularyItem:
    pronunciation: FOOT
    label: FOOT
    values: set()
    diacritic: FOOT_1
    triggers: set()
    weight: 9.900000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_29
    triggers: {('e', frozenset({'+atomic'}))}
    weight: 10.3
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 28.70000000000004
line done
line done

---------------------

input line #546
input roots: [<__main__.Root object at 0x10fc2d438>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 78.49999999999994..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 177.09999999999584..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 71.70000000000014..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 71.80000000000014..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'GRANDPARENT_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'GRANDPARENT_1', 'GRANDPARENT_2'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc96c88>, '#', <__main__.Root object at 0x10fc96710>, '-', <__main__.NominalizerTerminal object at 0x10fc96ba8>, '-', <__main__.SemanticTerminal object at 0x10fc965c0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite', 'i_2', '+atomic'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'i_2'}
we picked null_14 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: uno#GRANDPARENT-o
full_pronunciation: un#GRANDPARENTo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 71.80000000000014
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_2
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 10.000000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 14.9
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 34.70000000000004
line done
line done

---------------------

input line #547
input roots: [<__main__.Root object at 0x10fc96a90>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 78.59999999999994..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 177.19999999999584..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 71.80000000000014..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 71.90000000000013..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: MOUSE in its selectional

now working with the word 'MOUSE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'MOUSE_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi MOUSE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'MOUSE_2', 'MOUSE_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc96d68>, '#', <__main__.Root object at 0x10fc50dd8>, '-', <__main__.NominalizerTerminal object at 0x10fc50748>, '-', <__main__.SemanticTerminal object at 0x10fc50be0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'e_1', '-definite', '+atomic'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out MOUSE terminal with values set()
we picked MOUSE_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'e_1', 'null'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: uno#MOUSE-o
full_pronunciation: un#MOUSEo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 71.90000000000013
VocabularyItem:
    pronunciation: MOUSE
    label: MOUSE
    values: set()
    diacritic: MOUSE_2
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 11.000000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 26.799999999999784
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 34.70000000000004
line done
line done

---------------------

input line #548
input roots: [<__main__.Root object at 0x10fc50898>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 177.29999999999583..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 78.39999999999986..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 52.600000000000406..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 177.39999999999583..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 78.69999999999993..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 52.70000000000041..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 177.49999999999582..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: MILKCOW in its selectional

now working with the word 'MILKCOW-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'null_17'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'MILKCOW_1', 'null_17'}
     what if we combine triggers with the otherwise identical vi MILKCOW_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'MILKCOW_3', 'MILKCOW_1', 'null_17'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc502b0>, '-', <__main__.AgrTerminal object at 0x10fc50860>, '#', <__main__.Root object at 0x10fc506a0>, '-', <__main__.NominalizerTerminal object at 0x10fc50be0>, '-', <__main__.SemanticTerminal object at 0x10fc50dd8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'o_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MILKCOW terminal with values set()
we picked MILKCOW_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'i_2', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: le#MILKCOW-e
full_pronunciation: li#MILKCOWe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 177.49999999999582
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 52.30000000000038
VocabularyItem:
    pronunciation: MILKCOW
    label: MILKCOW
    values: set()
    diacritic: MILKCOW_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 11.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 26.699999999999783
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 18.300000000000008
line done
line done

---------------------

input line #549
input roots: [<__main__.Root object at 0x10fc50940>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 177.49999999999582..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 52.80000000000041..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 78.49999999999986..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 177.59999999999582..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 78.59999999999985..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 71.90000000000013..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 177.6999999999958..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 177.7999999999958..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 52.30000000000038..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 78.69999999999985..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'OFFSPRING_1', 'null_11', 'null_10', 'OFFSPRING_5'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc968d0>, '#', <__main__.Root object at 0x10fc96ac8>, '-', <__main__.NominalizerTerminal object at 0x10fc96128>, '-', <__main__.SemanticTerminal object at 0x10fc96940>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '+atomic', 'i_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_6: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'a'}
we picked null_14 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#OFFSPRING-a
full_pronunciation: l#OFFSPRINGa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 177.7999999999958
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_6
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 9.600000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 14.8
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 38.10000000000006
line done
line done

---------------------

input line #550
input roots: [<__main__.Root object at 0x10fc96b00>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 177.7999999999958..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 78.79999999999984..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 52.90000000000041..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 177.8999999999958..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 78.79999999999993..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 53.00000000000041..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 177.9999999999958..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: FROG in its selectional

now working with the word 'FROG-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'null_17'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_1', 'e_2', 'null_16', 'null_17'}
     what if we combine triggers with the otherwise identical vi FROG_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'FROG_1', 'FROG_3', 'null_17'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc96c18>, '#', <__main__.Root object at 0x10fc2d668>, '-', <__main__.NominalizerTerminal object at 0x10fc2dc50>, '-', <__main__.SemanticTerminal object at 0x10fc2d3c8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out FROG terminal with values set()
we picked FROG_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '-atomic'}
we picked e_2 bc its pronunciation was locally triggered
input pronunciation: le#FROG-e
full_pronunciation: l#FROGe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 177.9999999999958
VocabularyItem:
    pronunciation: FROG
    label: FROG
    values: set()
    diacritic: FROG_3
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 9.300000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 14.000000000000014
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 18.300000000000008
line done
line done

---------------------

input line #551
input roots: [<__main__.Root object at 0x10fc2d518>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 177.9999999999958..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 53.10000000000041..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 78.89999999999984..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 178.0999999999958..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 78.99999999999983..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 72.00000000000013..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 178.19999999999578..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 178.29999999999578..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 52.40000000000038..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 79.09999999999982..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: BALL in its selectional

now working with the word 'BALL-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'BALL_1', 'a_1'}
     what if we combine triggers with the otherwise identical vi BALL_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'BALL_1', 'BALL_2', 'null_10', 'null_11'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc581d0>, '-', <__main__.AgrTerminal object at 0x10fc05e80>, '#', <__main__.Root object at 0x10fc583c8>, '-', <__main__.NominalizerTerminal object at 0x10fc58c88>, '-', <__main__.SemanticTerminal object at 0x10fc58f60>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BALL terminal with values set()
we picked BALL_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2', 'a'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#BALL-a
full_pronunciation: la#BALLa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: BALL to the selectional of the nominalizer whose values are {'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'a_2'}
    selectional: {'FROG', 'CHILD', 'BALL', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 83.09999999999957
    linear: (<__main__.NominalizerTerminal object at 0x10fc05f28>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'FROG', 'BALL', 'CHILD', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_16, triggers = set(), weight = 11.4..already existed

create_vi: tried nominalizer: null_32, triggers = {('i', frozenset({'-atomic'}))}, weight = 10.399999999999999..already existed

create_vi: tried nominalizer: null_17, triggers = {('e', frozenset({'-atomic'}))}, weight = 10.799999999999997..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_24, triggers = set(), weight = 13.2..already existed

create_vi: tried nominalizer: null_28, triggers = {('i', frozenset({'-atomic'}))}, weight = 11.099999999999998..already existed
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 178.29999999999578
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 79.09999999999982
VocabularyItem:
    pronunciation: BALL
    label: BALL
    values: set()
    diacritic: BALL_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.500000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 13.600000000000014
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 38.10000000000006
line done
line done

---------------------

input line #552
input roots: [<__main__.Root object at 0x10fc3bf98>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 78.89999999999992..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 178.89999999999577..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 72.10000000000012..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 72.20000000000012..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CLOWN in its selectional

now working with the word 'CLOWN-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CLOWN_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CLOWN_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'CLOWN_3', 'o_1', 'CLOWN_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc43eb8>, '-', <__main__.AgrTerminal object at 0x10fc58080>, '#', <__main__.Root object at 0x10fc08470>, '-', <__main__.NominalizerTerminal object at 0x10fc207b8>, '-', <__main__.SemanticTerminal object at 0x10fc43f60>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CLOWN terminal with values set()
we picked CLOWN_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: uno#CLOWN-o
full_pronunciation: una#CLOWNo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 72.20000000000012
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 79.59999999999982
VocabularyItem:
    pronunciation: CLOWN
    label: CLOWN
    values: set()
    diacritic: CLOWN_4
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 11.000000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 26.59999999999978
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 34.70000000000004
line done
line done

---------------------

input line #553
input roots: [<__main__.Root object at 0x10fc43ba8>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 178.99999999999577..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 79.59999999999982..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 52.500000000000384..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 179.09999999999576..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 78.99999999999991..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 52.600000000000385..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 179.19999999999575..already existed
  we're in a functional word...
  - nominalizer's values are now {'a_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'a_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_24', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_24', 'i_1', 'null_28'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_24', 'i_1', 'null_28'}
     what if we combine triggers with the otherwise identical vi PIBLING_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_5 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_28', 'PIBLING_7', 'PIBLING_1', 'null_24', 'i_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b908>, '-', <__main__.AgrTerminal object at 0x10fc584e0>, '#', <__main__.Root object at 0x10fc4b518>, '-', <__main__.NominalizerTerminal object at 0x10fc4beb8>, '-', <__main__.SemanticTerminal object at 0x10fc4ba58>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'a_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_5: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'a_2'}
we picked null_24 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: li#PIBLING-i
full_pronunciation: li#PIBLINGe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 179.19999999999575
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 52.600000000000385
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_5
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 10.300000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2', 'a_2'}
    diacritic: null_24
    triggers: set()
    weight: 13.2
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 18.200000000000006
line done
line done

---------------------

input line #554
input roots: [<__main__.Root object at 0x10fc47fd0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 179.19999999999575..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 53.200000000000415..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 79.69999999999982..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 179.29999999999575..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 79.79999999999981..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 72.20000000000012..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 179.39999999999574..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 179.49999999999574..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 52.600000000000385..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 79.8999999999998..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1', 'e_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: MILKCOW in its selectional

now working with the word 'MILKCOW-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'null_27', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'null_27', 'a_1', 'MILKCOW_1'}
     what if we combine triggers with the otherwise identical vi MILKCOW_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'null_16', 'MILKCOW_1', 'null_27', 'MILKCOW_2'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc41eb8>, '-', <__main__.AgrTerminal object at 0x10fc4b7f0>, '#', <__main__.Root object at 0x10fc6a3c8>, '-', <__main__.NominalizerTerminal object at 0x10fc6f780>, '-', <__main__.SemanticTerminal object at 0x10fc411d0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MILKCOW terminal with values set()
we picked MILKCOW_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'a_2'}
we picked null_11: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#MILKCOW-a
full_pronunciation: la#MILKCOWa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: MILKCOW to the selectional of the nominalizer whose values are {'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'a_2'}
    selectional: {'FROG', 'CHILD', 'BALL', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 83.69999999999953
    linear: (<__main__.NominalizerTerminal object at 0x10fc05f28>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'FROG', 'BALL', 'CHILD', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_27, triggers = {('a', frozenset({'+atomic'}))}, weight = 10.2..already existed

create_vi: tried nominalizer: null_40, triggers = {('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}, weight = 10.2..already existed

create_vi: tried nominalizer: null_34, triggers = {('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}, weight = 10.399999999999999..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_25, triggers = {('a', frozenset({'+atomic'}))}, weight = 10.499999999999998..already existed

create_vi: tried nominalizer: null_41, triggers = {('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}, weight = 10.2..already existed
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 179.49999999999574
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 79.8999999999998
VocabularyItem:
    pronunciation: MILKCOW
    label: MILKCOW
    values: set()
    diacritic: MILKCOW_1
    triggers: set()
    weight: 10.900000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_11
    triggers: {('a', frozenset({'+atomic'}))}
    weight: 11.4
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 38.70000000000006
line done
line done

---------------------

input line #555
input roots: [<__main__.Root object at 0x10fc4bfd0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 79.09999999999991..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 180.09999999999573..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 72.30000000000011..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 72.4000000000001..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FOOT in its selectional

now working with the word 'FOOT-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FOOT_1', 'null_8', 'e_3', 'null_19'}
     what if we combine triggers with the otherwise identical vi FOOT_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FOOT_1', 'e_3', 'FOOT_2', 'null_19'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc86f98>, '-', <__main__.AgrTerminal object at 0x10fc6a588>, '#', <__main__.Root object at 0x10fc864e0>, '-', <__main__.NominalizerTerminal object at 0x10fc86c18>, '-', <__main__.SemanticTerminal object at 0x10fc86f60>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FOOT terminal with values set()
we picked FOOT_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e', 'e_1', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: uno#FOOT-e
full_pronunciation: una#FOOTe
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 72.4000000000001
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 80.3999999999998
VocabularyItem:
    pronunciation: FOOT
    label: FOOT
    values: set()
    diacritic: FOOT_4
    triggers: {('null', frozenset()), ('e', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 11.4
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 26.49999999999978
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 20.20000000000001
line done
line done

---------------------

input line #556
input roots: [<__main__.Root object at 0x10fc08358>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 79.1999999999999..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 180.19999999999573..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 72.4000000000001..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 72.5000000000001..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'PIBLING_1', 'o_1', 'PIBLING_5'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b128>, '-', <__main__.AgrTerminal object at 0x10fc6a470>, '#', <__main__.Root object at 0x10fc4b588>, '-', <__main__.NominalizerTerminal object at 0x10fc4b860>, '-', <__main__.SemanticTerminal object at 0x10fc4b8d0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'e_1', '-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_6: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'e_1', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: uno#PIBLING-o
full_pronunciation: uno#PIBLINGo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: PIBLING to the selectional of the nominalizer whose values are {'e_1', 'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1', 'o_2'}
    selectional: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CASTLE', 'CAR', 'CLOWN', 'OFFSPRING'}
    selection_strength: True
    weight: 26.700000000000024
    linear: (<__main__.NominalizerTerminal object at 0x10fc3d400>,)
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 72.5000000000001
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 79.1999999999999
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_6
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 10.3
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 26.39999999999978
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 34.70000000000004
line done
line done

---------------------

input line #557
input roots: [<__main__.Root object at 0x10fc6a390>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 180.29999999999572..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 53.300000000000416..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 80.3999999999998..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 180.3999999999957..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 80.4999999999998..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 73.1000000000001..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 180.4999999999957..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 180.5999999999957..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 52.70000000000039..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 80.5999999999998..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'GRANDPARENT_1'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'GRANDPARENT_1', 'null_11', 'null_10', 'GRANDPARENT_3'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc471d0>, '-', <__main__.AgrTerminal object at 0x10fc4ba20>, '#', <__main__.Root object at 0x10fc080b8>, '-', <__main__.NominalizerTerminal object at 0x10fc35be0>, '-', <__main__.SemanticTerminal object at 0x10fc477f0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'i_2', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_6: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'o_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#GRANDPARENT-a
full_pronunciation: lo#GRANDPARENTa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 180.5999999999957
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 79.6999999999999
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_6
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 10.100000000000003
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 26.89999999999978
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 39.30000000000006
line done
line done

---------------------

input line #558
input roots: [<__main__.Root object at 0x10fc47080>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 180.5999999999957..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 80.69999999999979..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 52.80000000000039..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 180.6999999999957..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 79.6999999999999..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 52.90000000000039..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 180.7999999999957..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: FOOT in its selectional

now working with the word 'FOOT-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FOOT_1', 'null_12', 'null_13', 'i_1'}
     what if we combine triggers with the otherwise identical vi FOOT_2 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'FOOT_3', 'FOOT_1', 'null_13', 'i_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc43ba8>, '#', <__main__.Root object at 0x10fc582b0>, '-', <__main__.NominalizerTerminal object at 0x10fc589e8>, '-', <__main__.SemanticTerminal object at 0x10fc10dd8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out FOOT terminal with values set()
we picked FOOT_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: li#FOOT-i
full_pronunciation: l#FOOTi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 180.7999999999957
VocabularyItem:
    pronunciation: FOOT
    label: FOOT
    values: set()
    diacritic: FOOT_2
    triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))}
    weight: 11.3
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 26.799999999999777
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 28.80000000000004
line done
line done

---------------------

input line #559
input roots: [<__main__.Root object at 0x10fc43208>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 180.7999999999957..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 80.79999999999978..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 53.40000000000042..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 180.89999999999569..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 79.7999999999999..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 53.50000000000042..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 180.99999999999568..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'null_17'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'e_2', 'null_16', 'null_17'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_5 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'OFFSPRING_7', 'null_16', 'OFFSPRING_1', 'null_17'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc58198>, '#', <__main__.Root object at 0x10fc18358>, '-', <__main__.NominalizerTerminal object at 0x10fc58c50>, '-', <__main__.SemanticTerminal object at 0x10fc580b8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: le#OFFSPRING-e
full_pronunciation: l#OFFSPRINGi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 180.99999999999568
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.000000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 26.699999999999775
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 28.70000000000004
line done
line done

---------------------

input line #560
input roots: [<__main__.Root object at 0x10fc58fd0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 80.89999999999978..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 180.99999999999568..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 73.20000000000009..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 73.30000000000008..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_2', 'a_1', 'PIBLING_1', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc2dd68>, '-', <__main__.AgrTerminal object at 0x10fc36780>, '#', <__main__.Root object at 0x10fc05550>, '-', <__main__.NominalizerTerminal object at 0x10fc05630>, '-', <__main__.SemanticTerminal object at 0x10fc14668>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_7: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'a_2'}
we picked null_24 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: una#PIBLING-a
full_pronunciation: una#PIBLINGa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: PIBLING to the selectional of the nominalizer whose values are {'i_2', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'a_2'}
    selectional: {'BOOK', 'CHILD', 'BALL', 'FROG', 'PIBLING', 'FLOWER', 'GRANDPARENT', 'TOWER', 'CASTLE', 'CAR', 'KEY', 'CLOWN', 'FOOT', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 27.500000000000043
    linear: (<__main__.NominalizerTerminal object at 0x10fc36a90>,)
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 73.30000000000008
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 80.89999999999978
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_7
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.500000000000002
     what if we combine triggers with the otherwise identical vi PIBLING_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_5 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2', 'a_2'}
    diacritic: null_24
    triggers: set()
    weight: 13.1
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 39.30000000000006
line done
line done

---------------------

input line #561
input roots: [<__main__.Root object at 0x10fc2db70>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 79.89999999999989..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 181.09999999999567..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 73.90000000000008..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 74.00000000000007..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1', 'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: BOOK in its selectional

now working with the word 'BOOK-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_18', 'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_18', 'o_1', 'BOOK_1', 'null_12'}
     what if we combine triggers with the otherwise identical vi BOOK_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'o_1', 'BOOK_1', 'BOOK_3', 'null_18'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc96b70>, '-', <__main__.AgrTerminal object at 0x10fc58470>, '#', <__main__.Root object at 0x10fc96240>, '-', <__main__.NominalizerTerminal object at 0x10fc96f98>, '-', <__main__.SemanticTerminal object at 0x10fc962e8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BOOK terminal with values set()
we picked BOOK_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: uno#BOOK-o
full_pronunciation: uno#BOOKo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: BOOK to the selectional of the nominalizer whose values are {'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'o_2'}
    selectional: {'MOUSE', 'CHILD', 'BOOK', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 87.29999999999933
    linear: (<__main__.NominalizerTerminal object at 0x10fc08908>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_6, triggers = set(), weight = 12.299999999999999..already existed

create_vi: tried nominalizer: null_7, triggers = {('i', frozenset({'-atomic'}))}, weight = 12.59999999999999..already existed

create_vi: tried nominalizer: null_26, triggers = {('e', frozenset({'-atomic'}))}, weight = 14.19999999999999..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_14, triggers = set(), weight = 14.8..already existed

create_vi: tried nominalizer: null_15, triggers = {('i', frozenset({'-atomic'}))}, weight = 12.79999999999999..already existed
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 74.00000000000007
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 79.89999999999989
VocabularyItem:
    pronunciation: BOOK
    label: BOOK
    values: set()
    diacritic: BOOK_4
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 12.3
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 26.599999999999774
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 35.30000000000004
line done
line done

---------------------

input line #562
input roots: [<__main__.Root object at 0x10fc96358>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 181.19999999999567..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 53.60000000000042..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 80.49999999999989..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 181.29999999999566..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 80.59999999999988..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 74.60000000000007..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 181.39999999999566..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 181.49999999999565..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 53.00000000000039..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 80.69999999999987..already existed
  we're in a functional word...
  - nominalizer's values are now {'i_2', 'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: CLOWN in its selectional

now working with the word 'CLOWN-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_18', 'o_1', 'null_12'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_18', 'o_1', 'CLOWN_1', 'null_12'}
     what if we combine triggers with the otherwise identical vi CLOWN_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'CLOWN_3', 'o_1', 'null_18', 'CLOWN_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc86518>, '-', <__main__.AgrTerminal object at 0x10fc96978>, '#', <__main__.Root object at 0x10fc86be0>, '-', <__main__.NominalizerTerminal object at 0x10fc86da0>, '-', <__main__.SemanticTerminal object at 0x10fc86f28>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CLOWN terminal with values set()
we picked CLOWN_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: lo#CLOWN-o
full_pronunciation: la#CLOWNo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 181.49999999999565
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 81.39999999999978
VocabularyItem:
    pronunciation: CLOWN
    label: CLOWN
    values: set()
    diacritic: CLOWN_3
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 11.600000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 27.099999999999774
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 35.90000000000004
line done
line done

---------------------

input line #563
input roots: [<__main__.Root object at 0x10fc502b0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 181.49999999999565..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 81.39999999999978..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 53.10000000000039..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 181.59999999999565..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 80.79999999999987..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 53.200000000000394..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 181.69999999999564..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: FLOWER in its selectional

now working with the word 'FLOWER-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'FLOWER_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi FLOWER_3 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_15', 'FLOWER_2', 'i_1', 'null_14', 'FLOWER_1'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc50400>, '-', <__main__.AgrTerminal object at 0x10fc38908>, '#', <__main__.Root object at 0x10fc50f98>, '-', <__main__.NominalizerTerminal object at 0x10fc503c8>, '-', <__main__.SemanticTerminal object at 0x10fc50358>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FLOWER terminal with values set()
we picked FLOWER_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'i_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#FLOWER-i
full_pronunciation: li#FLOWERi
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: FLOWER to the selectional of the nominalizer whose values are {'i_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2'}
    selectional: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 15.299999999999981
    linear: (<__main__.NominalizerTerminal object at 0x10fc0ecc0>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'a_2'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'a_2'}

create_vi: tried nominalizer: null_10, triggers = set(), weight = 14.200000000000014..already existed

create_vi: tried nominalizer: null_11, triggers = {('a', frozenset({'+atomic'}))}, weight = 12.0..already existed

create_vi: tried nominalizer: null_29, triggers = {('e', frozenset({'+atomic'}))}, weight = 10.3..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'o_2'} as values: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'o_2'}

create_vi: tried nominalizer: null_8, triggers = set(), weight = 14.000000000000014..already existed

create_vi: tried nominalizer: null_9, triggers = {('o', frozenset({'+atomic'}))}, weight = 11.3..already existed

create_vi: tried nominalizer: null_19, triggers = {('e', frozenset({'+atomic'}))}, weight = 9.600000000000001..already existed
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 181.69999999999564
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 53.200000000000394
VocabularyItem:
    pronunciation: FLOWER
    label: FLOWER
    values: set()
    diacritic: FLOWER_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.100000000000003
     what if we combine triggers with the otherwise identical vi FLOWER_3 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 26.999999999999773
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 28.70000000000004
line done
line done

---------------------

input line #564
input roots: [<__main__.Root object at 0x10fc50a20>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 81.49999999999977..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 182.29999999999563..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 74.70000000000006..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 74.80000000000005..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: KEY in its selectional

now working with the word 'KEY-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'KEY_1', 'null_10'}
     what if we combine triggers with the otherwise identical vi KEY_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'KEY_3', 'KEY_1', 'e_3', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc3ce48>, '-', <__main__.AgrTerminal object at 0x10fc96f60>, '#', <__main__.Root object at 0x10fc05320>, '-', <__main__.NominalizerTerminal object at 0x10fc05470>, '-', <__main__.SemanticTerminal object at 0x10fc05e48>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out KEY terminal with values set()
we picked KEY_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'a_2'}
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: una#KEY-e
full_pronunciation: una#KEYo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 74.80000000000005
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 81.49999999999977
VocabularyItem:
    pronunciation: KEY
    label: KEY
    values: set()
    diacritic: KEY_1
    triggers: set()
    weight: 11.5
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 27.499999999999773
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 35.80000000000004
line done
line done

---------------------

input line #565
input roots: [<__main__.Root object at 0x10fc50a90>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 182.39999999999563..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 81.49999999999977..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 53.70000000000042..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 182.49999999999562..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 80.89999999999986..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 53.80000000000042..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 182.59999999999562..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: BALL in its selectional

now working with the word 'BALL-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'null_17'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'BALL_1', 'null_17'}
     what if we combine triggers with the otherwise identical vi BALL_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_16', 'BALL_1', 'BALL_3', 'null_17'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc22e48>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc18588>, '-', <__main__.AgrTerminal object at 0x10fc50780>, '#', <__main__.Root object at 0x10fc18358>, '-', <__main__.NominalizerTerminal object at 0x10fc184e0>, '-', <__main__.SemanticTerminal object at 0x10fc180f0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '-atomic', 'i_2', 'a_2'}
we picked i_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out BALL terminal with values set()
we picked BALL_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i_2', 'a_2'}
we picked null_28: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: le#BALL-e
full_pronunciation: li#BALLi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 182.59999999999562
VocabularyItem:
    pronunciation: i
    label: Agr
    values: {'-atomic'}
    diacritic: i_2
    triggers: set()
    weight: 53.700000000000394
VocabularyItem:
    pronunciation: BALL
    label: BALL
    values: set()
    diacritic: BALL_1
    triggers: set()
    weight: 10.000000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2', 'a_2'}
    diacritic: null_28
    triggers: {('i', frozenset({'-atomic'}))}
    weight: 11.099999999999998
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 29.20000000000004
line done
line done

---------------------

input line #566
input roots: [<__main__.Root object at 0x10fc2d588>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 182.59999999999562..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 53.900000000000425..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 81.59999999999977..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 182.6999999999956..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 81.69999999999976..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 74.80000000000005..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 182.7999999999956..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 182.8999999999956..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 53.700000000000394..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 81.79999999999976..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'GRANDPARENT_1'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'GRANDPARENT_1', 'null_11', 'null_10', 'GRANDPARENT_3'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc58f98>, '-', <__main__.AgrTerminal object at 0x10fc2d9e8>, '#', <__main__.Root object at 0x10fbff828>, '-', <__main__.NominalizerTerminal object at 0x10fc58e80>, '-', <__main__.SemanticTerminal object at 0x10fc58eb8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: la#GRANDPARENT-a
full_pronunciation: lo#GRANDPARENTa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 182.8999999999956
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 80.89999999999986
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_4
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.500000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 14.000000000000014
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 39.90000000000006
line done
line done

---------------------

input line #567
input roots: [<__main__.Root object at 0x10fc58320>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 182.8999999999956..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 54.000000000000426..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 80.89999999999986..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 182.9999999999956..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 80.99999999999986..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 74.90000000000005..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 183.0999999999956..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 183.19999999999558..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 53.800000000000395..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 81.09999999999985..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'CHILD_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'CHILD_1', 'null_9', 'o_1', 'CHILD_3'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc477f0>, '-', <__main__.AgrTerminal object at 0x10fc584e0>, '#', <__main__.Root object at 0x10fc47780>, '-', <__main__.NominalizerTerminal object at 0x10fc47400>, '-', <__main__.SemanticTerminal object at 0x10fc47ef0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_7: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: lo#CHILD-o
full_pronunciation: lo#CHILDa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 183.19999999999558
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 81.09999999999985
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_7
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 9.400000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 13.900000000000015
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 39.80000000000006
line done
line done

---------------------

input line #568
input roots: [<__main__.Root object at 0x10fc47cf8>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 183.19999999999558..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 81.89999999999975..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 53.9000000000004..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 183.29999999999558..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 81.09999999999985..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 54.0000000000004..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 183.39999999999557..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_12', 'null_13', 'i_1'}
     what if we combine triggers with the otherwise identical vi PIBLING_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_5 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'PIBLING_7', 'PIBLING_1', 'null_13', 'i_1'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b240>, '-', <__main__.AgrTerminal object at 0x10fc47fd0>, '#', <__main__.Root object at 0x10fc4b2b0>, '-', <__main__.NominalizerTerminal object at 0x10fc4b470>, '-', <__main__.SemanticTerminal object at 0x10fc4b668>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic', 'a_2'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_9: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i', 'e_1', 'a_2'}
we picked null_16 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#PIBLING-i
full_pronunciation: le#PIBLINGi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 183.39999999999557
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 54.000000000000426
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_9
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1', 'a_2'}
    diacritic: null_16
    triggers: set()
    weight: 11.4
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 29.20000000000004
line done
line done

---------------------

input line #569
input roots: [<__main__.Root object at 0x10fc86518>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 183.39999999999557..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 54.000000000000426..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 81.19999999999985..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 183.49999999999557..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 81.29999999999984..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 75.00000000000004..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 183.59999999999556..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 183.69999999999555..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 54.1000000000004..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 81.39999999999984..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: FLOWER in its selectional

now working with the word 'FLOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'e_3', 'null_19', 'FLOWER_1'}
     what if we combine triggers with the otherwise identical vi FLOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'FLOWER_3', 'e_3', 'null_19', 'FLOWER_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc410f0>, '-', <__main__.AgrTerminal object at 0x10fc4b0f0>, '#', <__main__.Root object at 0x10fc6a390>, '-', <__main__.NominalizerTerminal object at 0x10fc6ab38>, '-', <__main__.SemanticTerminal object at 0x10fc6f780>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FLOWER terminal with values set()
we picked FLOWER_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: lo#FLOWER-e
full_pronunciation: la#FLOWERe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 183.69999999999555
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 81.89999999999975
VocabularyItem:
    pronunciation: FLOWER
    label: FLOWER
    values: set()
    diacritic: FLOWER_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.600000000000003
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 27.39999999999977
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 20.30000000000001
line done
line done

---------------------

input line #570
input roots: [<__main__.Root object at 0x10fc439e8>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 81.49999999999983..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 183.69999999999555..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 75.10000000000004..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 75.20000000000003..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: MOUSE in its selectional

now working with the word 'MOUSE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'MOUSE_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi MOUSE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'MOUSE_2', 'MOUSE_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a4e0>, '-', <__main__.AgrTerminal object at 0x10fc6a390>, '#', <__main__.Root object at 0x10fc228d0>, '-', <__main__.NominalizerTerminal object at 0x10fc41b00>, '-', <__main__.SemanticTerminal object at 0x10fc41080>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MOUSE terminal with values set()
we picked MOUSE_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: uno#MOUSE-o
full_pronunciation: uno#MOUSEo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: MOUSE to the selectional of the nominalizer whose values are {'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'o_2'}
    selectional: {'MOUSE', 'CHILD', 'BOOK', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 89.09999999999923
    linear: (<__main__.NominalizerTerminal object at 0x10fc08908>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_6, triggers = set(), weight = 12.399999999999999..already existed

create_vi: tried nominalizer: null_7, triggers = {('i', frozenset({'-atomic'}))}, weight = 12.69999999999999..already existed

create_vi: tried nominalizer: null_26, triggers = {('e', frozenset({'-atomic'}))}, weight = 14.29999999999999..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'CASTLE', 'GRANDPARENT', 'CLOWN', 'FOOT', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_14, triggers = set(), weight = 14.9..already existed

create_vi: tried nominalizer: null_15, triggers = {('i', frozenset({'-atomic'}))}, weight = 12.89999999999999..already existed
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 75.20000000000003
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 81.49999999999983
VocabularyItem:
    pronunciation: MOUSE
    label: MOUSE
    values: set()
    diacritic: MOUSE_3
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 10.700000000000001
     what if we combine triggers with the otherwise identical vi MOUSE_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 27.29999999999977
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 35.90000000000004
line done
line done

---------------------

input line #571
input roots: [<__main__.Root object at 0x10fc6a588>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 82.09999999999982..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 183.79999999999555..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 75.80000000000003..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 75.90000000000002..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: MOUSE in its selectional

now working with the word 'MOUSE-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'MOUSE_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi MOUSE_3 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'MOUSE_2', 'MOUSE_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc86278>, '-', <__main__.AgrTerminal object at 0x10fc4b898>, '#', <__main__.Root object at 0x10fc86b70>, '-', <__main__.NominalizerTerminal object at 0x10fc864e0>, '-', <__main__.SemanticTerminal object at 0x10fc86a20>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out MOUSE terminal with values set()
we picked MOUSE_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: uno#MOUSE-o
full_pronunciation: una#MOUSEo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 75.90000000000002
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 81.79999999999976
VocabularyItem:
    pronunciation: MOUSE
    label: MOUSE
    values: set()
    diacritic: MOUSE_4
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 11.3
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 14.200000000000014
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 36.50000000000004
line done
line done

---------------------

input line #572
input roots: [<__main__.Root object at 0x10fc4b470>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 183.89999999999554..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 81.79999999999976..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 54.10000000000043..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 183.99999999999554..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 82.19999999999982..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 54.20000000000043..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 184.09999999999553..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: KEY in its selectional

now working with the word 'KEY-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_6', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_6', 'null_7', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'KEY_1', 'null_6', 'null_7', 'i_1'}
     what if we combine triggers with the otherwise identical vi KEY_3 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'KEY_1', 'null_7', 'i_1', 'KEY_2', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b668>, '#', <__main__.Root object at 0x10fc47e48>, '-', <__main__.NominalizerTerminal object at 0x10fc47320>, '-', <__main__.SemanticTerminal object at 0x10fc470f0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out KEY terminal with values set()
we picked KEY_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: le#KEY-i
full_pronunciation: l#KEYi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 184.09999999999553
VocabularyItem:
    pronunciation: KEY
    label: KEY
    values: set()
    diacritic: KEY_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.900000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 27.79999999999977
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 29.20000000000004
line done
line done

---------------------

input line #573
input roots: [<__main__.Root object at 0x10fc47da0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 184.09999999999553..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 81.89999999999975..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 54.2000000000004..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 184.19999999999553..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 82.29999999999981..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 54.3000000000004..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 184.29999999999552..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'CHILD_1', 'i_1'}
     what if we combine triggers with the otherwise identical vi CHILD_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CHILD_1', 'null_12', 'null_13', 'CHILD_4', 'i_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc86e10>, '#', <__main__.Root object at 0x10fc583c8>, '-', <__main__.NominalizerTerminal object at 0x10fc58080>, '-', <__main__.SemanticTerminal object at 0x10fc43208>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out CHILD terminal with values set()
we picked CHILD_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#CHILD-i
full_pronunciation: l#CHILDi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 184.29999999999552
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_4
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.600000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 13.800000000000015
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 29.20000000000004
line done
line done

---------------------

input line #574
input roots: [<__main__.Root object at 0x10fc43710>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 184.29999999999552..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 54.30000000000043..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 81.99999999999974..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 184.39999999999552..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 82.09999999999974..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 75.90000000000002..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 184.4999999999955..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 184.5999999999955..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 54.400000000000404..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 82.19999999999973..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1', 'e_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: CAR in its selectional

now working with the word 'CAR-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'null_27', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'null_27', 'a_1', 'CAR_1'}
     what if we combine triggers with the otherwise identical vi CAR_2 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'null_16', 'CAR_1', 'null_27', 'CAR_3'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc58cf8>, '-', <__main__.AgrTerminal object at 0x10fc58630>, '#', <__main__.Root object at 0x10fc18748>, '-', <__main__.NominalizerTerminal object at 0x10fc182b0>, '-', <__main__.SemanticTerminal object at 0x10fc18320>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CAR terminal with values set()
we picked CAR_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o_2'}
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: la#CAR-a
full_pronunciation: lo#CARa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 184.5999999999955
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 82.29999999999981
VocabularyItem:
    pronunciation: CAR
    label: CAR
    values: set()
    diacritic: CAR_1
    triggers: set()
    weight: 9.300000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 27.69999999999977
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 39.80000000000006
line done
line done

---------------------

input line #575
input roots: [<__main__.Root object at 0x10fc58c18>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 82.29999999999973..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 184.5999999999955..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 76.00000000000001..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 76.10000000000001..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'GRANDPARENT_1'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'GRANDPARENT_1', 'null_11', 'null_10', 'GRANDPARENT_3'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc052b0>, '-', <__main__.AgrTerminal object at 0x10fc361d0>, '#', <__main__.Root object at 0x10fc3c748>, '-', <__main__.NominalizerTerminal object at 0x10fc3cf28>, '-', <__main__.SemanticTerminal object at 0x10fc05470>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'o_2', 'a'}
we picked null_14 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: una#GRANDPARENT-a
full_pronunciation: uno#GRANDPARENTa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 76.10000000000001
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 82.19999999999982
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_3
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 9.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'i_2'}
    diacritic: null_14
    triggers: set()
    weight: 14.9
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 39.80000000000006
line done
line done

---------------------

input line #576
input roots: [<__main__.Root object at 0x10fc185c0>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 184.6999999999955..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 54.40000000000043..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 82.39999999999972..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 184.7999999999955..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 82.49999999999972..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 76.10000000000001..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 184.8999999999955..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 184.99999999999548..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 54.500000000000405..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 82.59999999999971..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: CHILD in its selectional

now working with the word 'CHILD-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'CHILD_1', 'a_1'}
     what if we combine triggers with the otherwise identical vi CHILD_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CHILD_1', 'a_1', 'CHILD_2', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc96c88>, '-', <__main__.AgrTerminal object at 0x10fc2d3c8>, '#', <__main__.Root object at 0x10fc50780>, '-', <__main__.NominalizerTerminal object at 0x10fc38908>, '-', <__main__.SemanticTerminal object at 0x10fc96748>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: la#CHILD-a
full_pronunciation: la#CHILDo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 184.99999999999548
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 82.59999999999971
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_4
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.500000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 14.100000000000014
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 36.40000000000004
line done
line done

---------------------

input line #577
input roots: [<__main__.Root object at 0x10fc96080>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 184.99999999999548..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 54.50000000000043..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 82.19999999999982..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 185.09999999999548..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 82.29999999999981..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 76.2..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 185.19999999999547..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 185.29999999999546..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 54.600000000000406..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 82.3999999999998..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'GRANDPARENT_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'GRANDPARENT_1', 'GRANDPARENT_2'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67cc0>, '-', <__main__.AgrTerminal object at 0x10fc96dd8>, '#', <__main__.Root object at 0x10fc3dda0>, '-', <__main__.NominalizerTerminal object at 0x10fc3d898>, '-', <__main__.SemanticTerminal object at 0x10fc67ef0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'i_2', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i_2', 'o_2'}
we picked null_8: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: lo#GRANDPARENT-o
full_pronunciation: lo#GRANDPARENTo
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: GRANDPARENT to the selectional of the nominalizer whose values are {'i_2', 'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'o_2'}
    selectional: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'FLOWER', 'GRANDPARENT', 'CASTLE', 'CLOWN', 'FOOT', 'OFFSPRING'}
    selection_strength: True
    weight: 36.80000000000011
    linear: (<__main__.NominalizerTerminal object at 0x10fc22eb8>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 185.29999999999546
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 82.3999999999998
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_1
    triggers: set()
    weight: 9.900000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 13.700000000000015
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 36.40000000000004
line done
line done

---------------------

input line #578
input roots: [<__main__.Root object at 0x10fc677b8>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 185.89999999999546..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 54.600000000000435..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 82.59999999999971..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 185.99999999999545..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 82.6999999999997..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 76.3..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 186.09999999999545..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 186.19999999999544..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 54.70000000000041..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 82.7999999999997..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: OFFSPRING in its selectional

now working with the word 'OFFSPRING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'OFFSPRING_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi OFFSPRING_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi OFFSPRING_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'OFFSPRING_1', 'null_11', 'null_10', 'OFFSPRING_5'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc966a0>, '-', <__main__.AgrTerminal object at 0x10fc3d198>, '#', <__main__.Root object at 0x10fc96978>, '-', <__main__.NominalizerTerminal object at 0x10fc96c88>, '-', <__main__.SemanticTerminal object at 0x10fc96fd0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'i_2', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out OFFSPRING terminal with values set()
we picked OFFSPRING_7: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'i_2', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: la#OFFSPRING-a
full_pronunciation: lo#OFFSPRINGo
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 186.19999999999544
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 82.8999999999998
VocabularyItem:
    pronunciation: OFFSPRING
    label: OFFSPRING
    values: set()
    diacritic: OFFSPRING_7
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 9.600000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 27.599999999999767
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 36.90000000000004
line done
line done

---------------------

input line #579
input roots: [<__main__.Root object at 0x10fc50a90>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 82.8999999999997..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 186.19999999999544..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 76.39999999999999..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 76.49999999999999..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: TOWER in its selectional

now working with the word 'TOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'TOWER_1', 'e_3', 'null_10'}
     what if we combine triggers with the otherwise identical vi TOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'TOWER_1', 'TOWER_3', 'e_3', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc2dc88>, '-', <__main__.AgrTerminal object at 0x10fc05e80>, '#', <__main__.Root object at 0x10fc2dc50>, '-', <__main__.NominalizerTerminal object at 0x10fc2dd68>, '-', <__main__.SemanticTerminal object at 0x10fc2d6d8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', 'i_2', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out TOWER terminal with values set()
we picked TOWER_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'i_2', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: una#TOWER-e
full_pronunciation: uno#TOWERe
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 76.49999999999999
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 82.79999999999981
VocabularyItem:
    pronunciation: TOWER
    label: TOWER
    values: set()
    diacritic: TOWER_3
    triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))}
    weight: 12.600000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 14.200000000000015
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 20.30000000000001
line done
line done

---------------------

input line #580
input roots: [<__main__.Root object at 0x10fc3dba8>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 82.99999999999969..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 186.29999999999544..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 76.49999999999999..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 76.59999999999998..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'GRANDPARENT_1'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'GRANDPARENT_1', 'null_11', 'null_10', 'GRANDPARENT_3'}
done processing input, time to test
we selected the nominalizer with values: {'i_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc2deb8>, '#', <__main__.Root object at 0x10fc3e2b0>, '-', <__main__.NominalizerTerminal object at 0x10fc18320>, '-', <__main__.SemanticTerminal object at 0x10fc18748>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite', 'i_2', '+atomic'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_8: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'i_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: una#GRANDPARENT-a
full_pronunciation: un#GRANDPARENTo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 76.59999999999998
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_8
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 27.499999999999766
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 36.80000000000004
line done
line done

---------------------

input line #581
input roots: [<__main__.Root object at 0x10fc187b8>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 186.39999999999543..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 54.700000000000436..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 83.09999999999968..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 186.49999999999542..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 83.19999999999968..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 76.59999999999998..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 186.59999999999542..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 186.6999999999954..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 54.80000000000041..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 83.29999999999967..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: CAR in its selectional

now working with the word 'CAR-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1', 'CAR_1'}
     what if we combine triggers with the otherwise identical vi CAR_2 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'null_10', 'CAR_1', 'null_11', 'CAR_3'}
done processing input, time to test
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc58320>, '-', <__main__.AgrTerminal object at 0x10fc36630>, '#', <__main__.Root object at 0x10fc43c88>, '-', <__main__.NominalizerTerminal object at 0x10fc43198>, '-', <__main__.SemanticTerminal object at 0x10fc58080>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'i_2', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CAR terminal with values set()
we picked CAR_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a', 'i_2', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#CAR-a
full_pronunciation: la#CARa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CAR to the selectional of the nominalizer whose values are {'i_2', 'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'i_2', 'a_2'}
    selectional: {'BOOK', 'CHILD', 'BALL', 'FROG', 'PIBLING', 'FLOWER', 'GRANDPARENT', 'TOWER', 'CASTLE', 'CAR', 'KEY', 'CLOWN', 'FOOT', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 28.200000000000045
    linear: (<__main__.NominalizerTerminal object at 0x10fc36a90>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 186.6999999999954
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 83.29999999999967
VocabularyItem:
    pronunciation: CAR
    label: CAR
    values: set()
    diacritic: CAR_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 12.200000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 27.399999999999764
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 40.100000000000065
line done
line done

---------------------

input line #582
input roots: [<__main__.Root object at 0x10fc58f98>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2', 'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 187.2999999999954..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 83.89999999999966..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 54.80000000000044..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 187.3999999999954..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 82.79999999999981..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 54.90000000000044..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 187.4999999999954..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: CHILD in its selectional

now working with the word 'CHILD-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6', 'CHILD_1'}
     what if we combine triggers with the otherwise identical vi CHILD_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'CHILD_1', 'CHILD_7', 'null_26', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc47e10>, '-', <__main__.AgrTerminal object at 0x10fc084e0>, '#', <__main__.Root object at 0x10fc86f98>, '-', <__main__.NominalizerTerminal object at 0x10fc28128>, '-', <__main__.SemanticTerminal object at 0x10fc1b9b0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic', 'a_2'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CHILD terminal with values set()
we picked CHILD_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1', 'a_2'}
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: le#CHILD-e
full_pronunciation: le#CHILDi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 187.4999999999954
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 54.90000000000044
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_1
    triggers: set()
    weight: 9.200000000000003
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 27.899999999999764
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 29.100000000000037
line done
line done

---------------------

input line #583
input roots: [<__main__.Root object at 0x10fc433c8>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 187.4999999999954..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 54.90000000000044..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 83.99999999999966..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 187.5999999999954..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 84.09999999999965..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 76.69999999999997..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 187.69999999999538..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 187.79999999999538..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 54.90000000000041..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 84.19999999999965..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: TOWER in its selectional

now working with the word 'TOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'TOWER_1', 'e_3', 'null_10'}
     what if we combine triggers with the otherwise identical vi TOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'TOWER_1', 'TOWER_3', 'e_3', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc861d0>, '#', <__main__.Root object at 0x10fc4be10>, '-', <__main__.NominalizerTerminal object at 0x10fc4b160>, '-', <__main__.SemanticTerminal object at 0x10fc4b7f0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '+atomic'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out TOWER terminal with values set()
we picked TOWER_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values set()
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked e_3: no super match (neither decl nor L1-gender)
input pronunciation: la#TOWER-e
full_pronunciation: l#TOWERe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 187.79999999999538
VocabularyItem:
    pronunciation: TOWER
    label: TOWER
    values: set()
    diacritic: TOWER_1
    triggers: set()
    weight: 9.400000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 27.799999999999763
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 20.30000000000001
line done
line done

---------------------

input line #584
input roots: [<__main__.Root object at 0x10fc4b7b8>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 84.29999999999964..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 187.79999999999538..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 76.79999999999997..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 76.89999999999996..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: KEY in its selectional

now working with the word 'KEY-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'KEY_1', 'null_10'}
     what if we combine triggers with the otherwise identical vi KEY_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'KEY_3', 'KEY_1', 'e_3', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc0e5f8>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc41be0>, '-', <__main__.AgrTerminal object at 0x10fc4ba20>, '#', <__main__.Root object at 0x10fc6a2e8>, '-', <__main__.NominalizerTerminal object at 0x10fc6aa20>, '-', <__main__.SemanticTerminal object at 0x10fc6f780>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out KEY terminal with values set()
we picked KEY_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: una#KEY-e
full_pronunciation: uno#KEYo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 76.89999999999996
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 82.79999999999981
VocabularyItem:
    pronunciation: KEY
    label: KEY
    values: set()
    diacritic: KEY_2
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))}
    weight: 9.800000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 14.100000000000016
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 36.70000000000004
line done
line done

---------------------

input line #585
input roots: [<__main__.Root object at 0x10fc280b8>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 187.89999999999537..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 55.00000000000044..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 84.39999999999964..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 187.99999999999537..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 84.49999999999963..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 76.89999999999996..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 188.09999999999536..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 188.19999999999536..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 55.00000000000041..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 84.59999999999962..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: FROG in its selectional

now working with the word 'FROG-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi FROG_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_2', 'a_1', 'FROG_1', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6f0b8>, '-', <__main__.AgrTerminal object at 0x10fc452b0>, '#', <__main__.Root object at 0x10fc4beb8>, '-', <__main__.NominalizerTerminal object at 0x10fc22b70>, '-', <__main__.SemanticTerminal object at 0x10fc41eb8>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out FROG terminal with values set()
we picked FROG_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2', 'a'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#FROG-a
full_pronunciation: lo#FROGa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 188.19999999999536
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 82.69999999999982
VocabularyItem:
    pronunciation: FROG
    label: FROG
    values: set()
    diacritic: FROG_4
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 10.500000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 14.000000000000016
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 40.70000000000007
line done
line done

---------------------

input line #586
input roots: [<__main__.Root object at 0x10fc45b70>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 188.19999999999536..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 55.10000000000044..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 82.69999999999982..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 188.29999999999535..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 82.79999999999981..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 76.99999999999996..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 188.39999999999534..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 188.49999999999534..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 55.10000000000041..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 82.8999999999998..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'GRANDPARENT_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'GRANDPARENT_1', 'GRANDPARENT_2'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff438>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc4b668>, '-', <__main__.AgrTerminal object at 0x10fc4bc50>, '#', <__main__.Root object at 0x10fc86278>, '-', <__main__.NominalizerTerminal object at 0x10fc861d0>, '-', <__main__.SemanticTerminal object at 0x10fc86978>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_9: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'e_1', 'a_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: lo#GRANDPARENT-o
full_pronunciation: la#GRANDPARENTa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 188.49999999999534
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 84.59999999999962
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_9
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'})), ('e', frozenset({'-atomic'}))}
    weight: 11.200000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 27.69999999999976
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 40.600000000000065
line done
line done

---------------------

input line #587
input roots: [<__main__.Root object at 0x10fc4ba58>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'la', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc1e6a0>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 188.49999999999534..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 55.20000000000044..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 84.59999999999962..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 188.59999999999533..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 84.69999999999962..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 77.09999999999995..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 188.69999999999533..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 188.79999999999532..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 55.200000000000415..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 84.79999999999961..already existed
  we're in a functional word...
  - nominalizer's values are now {'la_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: FROG in its selectional

now working with the word 'FROG-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi FROG_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'FROG_2', 'a_1', 'FROG_1', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'e_1'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc281d0>, '#', <__main__.Root object at 0x10fc47e48>, '-', <__main__.NominalizerTerminal object at 0x10fc470f0>, '-', <__main__.SemanticTerminal object at 0x10fc47438>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', 'e_1', '+atomic'}
we picked lo_1: no super match (neither decl nor L1-gender)
now spelling out FROG terminal with values set()
we picked FROG_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1', 'null', 'a'}
we picked null_6 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: la#FROG-a
full_pronunciation: lo#FROGa
vis_used:
Failure
VocabularyItem:
    pronunciation: lo
    label: definite
    values: {'+definite', '+atomic'}
    diacritic: lo_1
    triggers: set()
    weight: 10.500000000000002
VocabularyItem:
    pronunciation: FROG
    label: FROG
    values: set()
    diacritic: FROG_2
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 11.3
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'e_1'}
    diacritic: null_6
    triggers: set()
    weight: 12.399999999999999
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 40.600000000000065
line done
line done

---------------------

input line #588
input roots: [<__main__.Root object at 0x10fc864e0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 188.89999999999532..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 84.89999999999961..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 55.300000000000416..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 188.9999999999953..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 82.9999999999998..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 55.40000000000042..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 189.0999999999953..already existed
  we're in a functional word...
  - nominalizer's values are now {'a_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'a_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_24', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_24', 'i_1', 'null_28'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'GRANDPARENT_1', 'null_24', 'i_1', 'null_28'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_2 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_3 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_28', 'null_24', 'i_1', 'GRANDPARENT_4', 'GRANDPARENT_1'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc084e0>, '#', <__main__.Root object at 0x10fc58160>, '-', <__main__.NominalizerTerminal object at 0x10fc58b70>, '-', <__main__.SemanticTerminal object at 0x10fc43198>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_5: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: li#GRANDPARENT-i
full_pronunciation: l#GRANDPARENTi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 189.0999999999953
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_5
    triggers: {('null', frozenset()), ('o', frozenset({'+atomic'})), ('i', frozenset({'-atomic'}))}
    weight: 9.400000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 13.900000000000016
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 29.100000000000037
line done
line done

---------------------

input line #589
input roots: [<__main__.Root object at 0x10fc86eb8>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 189.0999999999953..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 84.9999999999996..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 55.300000000000445..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 189.1999999999953..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 83.0999999999998..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 55.400000000000446..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 189.2999999999953..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: KEY in its selectional

now working with the word 'KEY-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_6', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_6', 'null_7', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'KEY_1', 'null_6', 'null_7', 'i_1'}
     what if we combine triggers with the otherwise identical vi KEY_3 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'KEY_1', 'null_7', 'i_1', 'KEY_2', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc58470>, '#', <__main__.Root object at 0x10fc10dd8>, '-', <__main__.NominalizerTerminal object at 0x10fc585c0>, '-', <__main__.SemanticTerminal object at 0x10fc58c50>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out KEY terminal with values set()
we picked KEY_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'i', 'null', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'i', '-atomic'}
we picked i_1 bc its pronunciation was locally triggered
input pronunciation: le#KEY-i
full_pronunciation: l#KEYi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 189.2999999999953
VocabularyItem:
    pronunciation: KEY
    label: KEY
    values: set()
    diacritic: KEY_4
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'})), ('e', frozenset({'+atomic'}))}
    weight: 11.100000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 14.000000000000014
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 29.100000000000037
line done
line done

---------------------

input line #590
input roots: [<__main__.Root object at 0x10fc58748>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'uno', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: o_2, triggers = set(), weight = 83.19999999999979..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 189.2999999999953..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 77.19999999999995..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 77.29999999999994..already existed
  we're in a functional word...
  - nominalizer's values are now {'uno_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: GRANDPARENT in its selectional

now working with the word 'GRANDPARENT-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'GRANDPARENT_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi GRANDPARENT_4 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi GRANDPARENT_7 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'o_1', 'GRANDPARENT_1', 'GRANDPARENT_2'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc2d518>, '-', <__main__.AgrTerminal object at 0x10fc58860>, '#', <__main__.Root object at 0x10fc05668>, '-', <__main__.NominalizerTerminal object at 0x10fc05e80>, '-', <__main__.SemanticTerminal object at 0x10fc2dbe0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out GRANDPARENT terminal with values set()
we picked GRANDPARENT_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: uno#GRANDPARENT-o
full_pronunciation: una#GRANDPARENTa
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 77.29999999999994
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 84.9999999999996
VocabularyItem:
    pronunciation: GRANDPARENT
    label: GRANDPARENT
    values: set()
    diacritic: GRANDPARENT_3
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 9.700000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 27.59999999999976
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 40.500000000000064
line done
line done

---------------------

input line #591
input roots: [<__main__.Root object at 0x10fc2d6d8>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1', 'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 84.9999999999996..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 189.3999999999953..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 77.29999999999994..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 77.39999999999993..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_11', 'null_10', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_11', 'null_10', 'a_1'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_2', 'a_1', 'PIBLING_1', 'null_11', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc968d0>, '-', <__main__.AgrTerminal object at 0x10fc2dc50>, '#', <__main__.Root object at 0x10fc96390>, '-', <__main__.NominalizerTerminal object at 0x10fc96a20>, '-', <__main__.SemanticTerminal object at 0x10fc964e0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_6: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'o', 'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'o', '+atomic'}
we picked o_1 bc its pronunciation was locally triggered
input pronunciation: una#PIBLING-a
full_pronunciation: una#PIBLINGo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 77.39999999999993
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 84.9999999999996
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_6
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 10.8
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 27.49999999999976
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 36.80000000000004
line done
line done

---------------------

input line #592
input roots: [<__main__.Root object at 0x10fc96710>]
input values: [{'+definite'}, {'+atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'lo', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fc085c0>, <__main__.VocabularyItem object at 0x10fc086d8>, <__main__.VocabularyItem object at 0x10fc0e518>, <__main__.VocabularyItem object at 0x10fc22dd8>]

create_vi: tried definite: l_1, triggers = set(), weight = 189.49999999999528..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 55.50000000000045..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 83.29999999999978..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 189.59999999999528..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 83.39999999999978..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 77.39999999999993..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 189.69999999999527..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 189.79999999999526..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 55.50000000000042..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 83.49999999999977..already existed
  we're in a functional word...
  - nominalizer's values are now {'lo_1'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'o_2'} has root Root: PIBLING in its selectional

now working with the word 'PIBLING-o', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'o_1', 'null_9'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'PIBLING_1', 'null_8', 'o_1', 'null_9'}
     what if we combine triggers with the otherwise identical vi PIBLING_3 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
     what if we combine triggers with the otherwise identical vi PIBLING_7 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_8', 'null_9', 'PIBLING_1', 'o_1', 'PIBLING_5'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc08828>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc3db38>, '-', <__main__.AgrTerminal object at 0x10fc966d8>, '#', <__main__.Root object at 0x10fc42b00>, '-', <__main__.NominalizerTerminal object at 0x10fc42198>, '-', <__main__.SemanticTerminal object at 0x10fc42710>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', '+atomic', 'o_2'}
we picked o_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out PIBLING terminal with values set()
we picked PIBLING_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2'}
we picked null_8 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic'}
we picked a_1: no super match (neither decl nor L1-gender)
input pronunciation: lo#PIBLING-o
full_pronunciation: lo#PIBLINGa
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 189.79999999999526
VocabularyItem:
    pronunciation: o
    label: Agr
    values: {'+atomic'}
    diacritic: o_2
    triggers: set()
    weight: 83.49999999999977
VocabularyItem:
    pronunciation: PIBLING
    label: PIBLING
    values: set()
    diacritic: PIBLING_3
    triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))}
    weight: 10.100000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_8
    triggers: set()
    weight: 13.800000000000017
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 40.500000000000064
line done
line done

---------------------

input line #593
input roots: [<__main__.Root object at 0x10fc676d8>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2', 'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 189.79999999999526..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 84.9999999999996..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 55.60000000000042..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 189.89999999999526..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 83.49999999999977..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 55.70000000000042..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 189.99999999999525..already existed
  we're in a functional word...
  - nominalizer's values are now {'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2'} has root Root: FOOT in its selectional

now working with the word 'FOOT-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'i_1', 'null_15'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_14', 'FOOT_1', 'i_1', 'null_15'}
     what if we combine triggers with the otherwise identical vi FOOT_2 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_15', 'FOOT_3', 'FOOT_1', 'i_1', 'null_14'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc052b0>, '#', <__main__.Root object at 0x10fc18160>, '-', <__main__.NominalizerTerminal object at 0x10fc18240>, '-', <__main__.SemanticTerminal object at 0x10fc2d438>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out FOOT terminal with values set()
we picked FOOT_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked e_2: no super match (neither decl nor L1-gender)
input pronunciation: li#FOOT-i
full_pronunciation: l#FOOTe
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 189.99999999999525
VocabularyItem:
    pronunciation: FOOT
    label: FOOT
    values: set()
    diacritic: FOOT_2
    triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))}
    weight: 11.200000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 27.399999999999757
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'-atomic'}
    diacritic: e_2
    triggers: set()
    weight: 18.40000000000001
line done
line done

---------------------

input line #594
input roots: [<__main__.Root object at 0x10fc42128>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'o_2'}
we broke out

now working with the word 'li', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 189.99999999999525..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 85.0999999999996..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 55.80000000000042..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 190.09999999999525..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 83.59999999999977..already existed

create_vi: tried Agr: i_2, triggers = set(), weight = 55.900000000000425..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 190.19999999999524..already existed
  we're in a functional word...
  - nominalizer's values are now {'o_2', 'li_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'i_2', 'o_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: i_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'i_2', 'o_2'} has root Root: CLOWN in its selectional

now working with the word 'CLOWN-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_12', 'null_13', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CLOWN_1', 'null_12', 'null_13', 'i_1'}
     what if we combine triggers with the otherwise identical vi CLOWN_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'CLOWN_2', 'null_12', 'null_13', 'i_1', 'CLOWN_1'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc42710>, '#', <__main__.Root object at 0x10fc45f60>, '-', <__main__.NominalizerTerminal object at 0x10fc455f8>, '-', <__main__.SemanticTerminal object at 0x10fc45588>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'a_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out CLOWN terminal with values set()
we picked CLOWN_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2'}
we picked null_10 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: li#CLOWN-i
full_pronunciation: l#CLOWNi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 190.19999999999524
VocabularyItem:
    pronunciation: CLOWN
    label: CLOWN
    values: set()
    diacritic: CLOWN_3
    triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())}
    weight: 11.500000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'a_2'}
    diacritic: null_10
    triggers: set()
    weight: 13.900000000000015
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 29.20000000000004
line done
line done

---------------------

input line #595
input roots: [<__main__.Root object at 0x10fc45080>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 85.19999999999959..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 190.19999999999524..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 77.49999999999993..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 77.59999999999992..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1', 'e_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: TOWER in its selectional

now working with the word 'TOWER-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'e_3', 'null_22'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'TOWER_1', 'null_16', 'e_3', 'null_22'}
     what if we combine triggers with the otherwise identical vi TOWER_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'TOWER_1', 'TOWER_3', 'null_16', 'null_22', 'e_3'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67278>, '-', <__main__.AgrTerminal object at 0x10fc3db38>, '#', <__main__.Root object at 0x10fc43c88>, '-', <__main__.NominalizerTerminal object at 0x10fc67fd0>, '-', <__main__.SemanticTerminal object at 0x10fc67320>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out TOWER terminal with values set()
we picked TOWER_4: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e', 'null', 'a_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'e', '+atomic'}
we picked e_3 bc its pronunciation was locally triggered
input pronunciation: una#TOWER-e
full_pronunciation: una#TOWERe
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: TOWER to the selectional of the nominalizer whose values are {'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'a_2'}
    selectional: {'FROG', 'CHILD', 'BALL', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 90.09999999999917
    linear: (<__main__.NominalizerTerminal object at 0x10fc05f28>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'FROG', 'BALL', 'CHILD', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_6, triggers = set(), weight = 12.399999999999999..already existed

create_vi: tried nominalizer: null_7, triggers = {('i', frozenset({'-atomic'}))}, weight = 12.79999999999999..already existed

create_vi: tried nominalizer: null_26, triggers = {('e', frozenset({'-atomic'}))}, weight = 14.39999999999999..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_14, triggers = set(), weight = 14.9..already existed

create_vi: tried nominalizer: null_15, triggers = {('i', frozenset({'-atomic'}))}, weight = 12.99999999999999..already existed
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 77.59999999999992
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 85.19999999999959
VocabularyItem:
    pronunciation: TOWER
    label: TOWER
    values: set()
    diacritic: TOWER_4
    triggers: {('null', frozenset()), ('i', frozenset({'-atomic'})), ('e', frozenset({'+atomic'}))}
    weight: 11.200000000000001
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 27.299999999999756
VocabularyItem:
    pronunciation: e
    label: atomic
    values: {'+atomic'}
    diacritic: e_3
    triggers: set()
    weight: 20.400000000000013
line done
line done

---------------------

input line #596
input roots: [<__main__.Root object at 0x10fc67240>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 85.79999999999959..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 190.29999999999524..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 78.19999999999992..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 78.29999999999991..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'a_2'} has root Root: KEY in its selectional

now working with the word 'KEY-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'null_10'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'e_3', 'KEY_1', 'null_10'}
     what if we combine triggers with the otherwise identical vi KEY_2 (triggers: {('null', frozenset()), ('i', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_29', 'KEY_3', 'KEY_1', 'e_3', 'null_10'}
done processing input, time to test
we selected the nominalizer with values: set()
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc67da0>, '#', <__main__.Root object at 0x10fc47e48>, '-', <__main__.NominalizerTerminal object at 0x10fc47320>, '-', <__main__.SemanticTerminal object at 0x10fc47da0>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite', '+atomic'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out KEY terminal with values set()
we picked KEY_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values set()
we picked null_1: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'+atomic'}
we picked o_1: no super match (neither decl nor L1-gender)
input pronunciation: una#KEY-e
full_pronunciation: un#KEYo
vis_used:
Failure
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 78.29999999999991
VocabularyItem:
    pronunciation: KEY
    label: KEY
    values: set()
    diacritic: KEY_1
    triggers: set()
    weight: 11.4
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 27.799999999999756
VocabularyItem:
    pronunciation: o
    label: atomic
    values: {'+atomic'}
    diacritic: o_1
    triggers: set()
    weight: 36.80000000000004
line done
line done

---------------------

input line #597
input roots: [<__main__.Root object at 0x10fc47588>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'i_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 190.39999999999523..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 85.89999999999958..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 55.60000000000045..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 190.49999999999523..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 83.69999999999976..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 55.70000000000045..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 190.59999999999522..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1'} has root Root: CHILD in its selectional

now working with the word 'CHILD-e', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_26', 'e_2', 'null_6', 'CHILD_1'}
     what if we combine triggers with the otherwise identical vi CHILD_2 (triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))})?
     what if we combine triggers with the otherwise identical vi CHILD_3 (triggers: {('o', frozenset({'+atomic'})), ('null', frozenset())})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'e_2', 'CHILD_1', 'CHILD_7', 'null_26', 'null_6'}
done processing input, time to test
we selected the nominalizer with values: {'o_2'}
we broke out
we used sprouting_rules: []
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc43630>, '#', <__main__.Root object at 0x10fc86f60>, '-', <__main__.NominalizerTerminal object at 0x10fc86b70>, '-', <__main__.SemanticTerminal object at 0x10fc86d30>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite', '-atomic', 'o_2'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out CHILD terminal with values set()
we picked CHILD_2: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'o_2'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: le#CHILD-e
full_pronunciation: l#CHILDi
vis_used:
Failure
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 190.59999999999522
VocabularyItem:
    pronunciation: CHILD
    label: CHILD
    values: set()
    diacritic: CHILD_2
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 11.300000000000002
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 27.699999999999754
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 29.100000000000037
line done
line done

---------------------

input line #598
input roots: [<__main__.Root object at 0x10fc86fd0>]
input values: [{'-definite'}, {'+atomic'}]
we selected the nominalizer with values: {'e_1'}
we broke out

now working with the word 'una', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc0e630>]

create_vi: tried Agr: a_2, triggers = set(), weight = 85.99999999999957..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 190.59999999999522..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 78.29999999999991..already existed

create_vi: tried definite: un_1, triggers = set(), weight = 78.3999999999999..already existed
  we're in a functional word...
  - nominalizer's values are now {'una_1', 'e_1'}
  - but that newvi helped us find a new Agr node vi: a_2
     and (2) we make sure an Agr sprouting rule exists, splitting {'-definite', '+atomic'} to host {'+atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: CAR in its selectional

now working with the word 'CAR-a', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'null_27', 'a_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'null_27', 'a_1', 'CAR_1'}
     what if we combine triggers with the otherwise identical vi CAR_2 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'a_1', 'null_16', 'CAR_1', 'null_27', 'CAR_3'}
done processing input, time to test
we selected the nominalizer with values: {'a_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fc1e7f0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc58a58>, '-', <__main__.AgrTerminal object at 0x10fc86978>, '#', <__main__.Root object at 0x10fc58c50>, '-', <__main__.NominalizerTerminal object at 0x10fc585c0>, '-', <__main__.SemanticTerminal object at 0x10fc58898>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'-definite'}
we picked un_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'-definite', '+atomic', 'a_2'}
we picked a_2 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out CAR terminal with values set()
we picked CAR_3: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'null', 'a_2', 'a'}
we picked null_1 bc its pronunciation was locally triggered
now spelling out atomic terminal with values {'+atomic', 'a'}
we picked a_1 bc its pronunciation was locally triggered
input pronunciation: una#CAR-a
full_pronunciation: una#CARa
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: CAR to the selectional of the nominalizer whose values are {'a_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'a_2'}
    selectional: {'FROG', 'CHILD', 'BALL', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
    selection_strength: True
    weight: 90.69999999999914
    linear: (<__main__.NominalizerTerminal object at 0x10fc05f28>,)
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'e_1'} as values: {'FROG', 'BALL', 'CHILD', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CAR', 'KEY', 'OFFSPRING', 'MILKCOW'}
..so we'll also combine the vis that spell out {'e_1'}

create_vi: tried nominalizer: null_6, triggers = set(), weight = 12.499999999999998..already existed

create_vi: tried nominalizer: null_7, triggers = {('i', frozenset({'-atomic'}))}, weight = 12.89999999999999..already existed

create_vi: tried nominalizer: null_26, triggers = {('e', frozenset({'-atomic'}))}, weight = 14.49999999999999..already existed
..plus that nominalizer selected (some of) the same Roots as the nominalizer with {'i_2'} as values: {'PIBLING', 'GRANDPARENT', 'CHILD', 'OFFSPRING'}
..so we'll also combine the vis that spell out {'i_2'}

create_vi: tried nominalizer: null_14, triggers = set(), weight = 15.0..already existed

create_vi: tried nominalizer: null_15, triggers = {('i', frozenset({'-atomic'}))}, weight = 13.099999999999989..already existed
VocabularyItem:
    pronunciation: un
    label: definite
    values: {'-definite'}
    diacritic: un_1
    triggers: set()
    weight: 78.3999999999999
VocabularyItem:
    pronunciation: a
    label: Agr
    values: {'+atomic'}
    diacritic: a_2
    triggers: set()
    weight: 85.99999999999957
VocabularyItem:
    pronunciation: CAR
    label: CAR
    values: set()
    diacritic: CAR_3
    triggers: {('null', frozenset()), ('a', frozenset({'+atomic'}))}
    weight: 9.300000000000002
     what if we combine triggers with the otherwise identical vi CAR_2 (triggers: {('null', frozenset()), ('e', frozenset({'-atomic'}))})?
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: set()
    diacritic: null_1
    triggers: set()
    weight: 27.599999999999753
VocabularyItem:
    pronunciation: a
    label: atomic
    values: {'+atomic'}
    diacritic: a_1
    triggers: set()
    weight: 40.500000000000064
line done
line done

---------------------

input line #599
input roots: [<__main__.Root object at 0x10fc86ef0>]
input values: [{'+definite'}, {'-atomic'}]
we selected the nominalizer with values: {'a_2'}
we broke out

now working with the word 'le', mapping to 1 terminals:
generalize_vi: here's what is in match_list: [<__main__.VocabularyItem object at 0x10fbff080>, <__main__.VocabularyItem object at 0x10fc057b8>, <__main__.VocabularyItem object at 0x10fc086d8>]

create_vi: tried definite: l_1, triggers = set(), weight = 190.6999999999952..already existed

create_vi: tried Agr: a_2, triggers = set(), weight = 86.59999999999957..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 55.80000000000045..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 190.7999999999952..already existed

create_vi: tried Agr: o_2, triggers = set(), weight = 83.79999999999976..already existed

create_vi: tried Agr: e_1, triggers = set(), weight = 55.90000000000045..already existed

create_vi: tried definite: l_1, triggers = set(), weight = 190.8999999999952..already existed
  we're in a functional word...
  - nominalizer's values are now {'le_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: a_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'la_1'}) gets set to 0
    > and we make sure a nominalizer with a_2 instead of la_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
     and (3) if the Agr was split out of the newvi in THIS input observation, we change the nominalizer we're currently using to have the split out value(s): {'e_1', 'a_2'}
  - but that newvi helped us find a new Agr node vi: o_2
     so (1) we clean up our nominalizer inventory: 
    > the nominalizer with these values ({'lo_1'}) gets set to 0
    > and we make sure a nominalizer with o_2 instead of lo_1 exists
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '+atomic'} to host {'+atomic'}
  - but that newvi helped us find a new Agr node vi: e_1
     and (2) we make sure an Agr sprouting rule exists, splitting {'+definite', '-atomic'} to host {'-atomic'}
  - finally, make (sure) the nominalizer with current (non-empty!) values: {'e_1', 'a_2'} has root Root: KEY in its selectional

now working with the word 'KEY-i', mapping to 3 terminals:
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'null_32', 'i_1'}
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'null_16', 'KEY_1', 'null_32', 'i_1'}
     what if we combine triggers with the otherwise identical vi KEY_3 (triggers: {('null', frozenset()), ('e', frozenset({'+atomic'}))})?
generalize_vi: here's what is in match_list: []
  we're in a lexical word...
  - we add the newvi's diacritic: diacritics_in_this_word now contains {'KEY_1', 'null_16', 'null_32', 'i_1', 'KEY_2'}
done processing input, time to test
we selected the nominalizer with values: {'e_1', 'o_2'}
we broke out
we used sprouting_rules: [<__main__.SproutingRule object at 0x10fbff8d0>]
now we have this TerminalChain: (<__main__.SemanticTerminal object at 0x10fc6a4e0>, '-', <__main__.AgrTerminal object at 0x10fc58470>, '#', <__main__.Root object at 0x10fc6a470>, '-', <__main__.NominalizerTerminal object at 0x10fc6a668>, '-', <__main__.SemanticTerminal object at 0x10fc6ab38>)
------------------------------
 spellout time 
------------------------------
now spelling out definite terminal with values {'+definite'}
we picked l_1: no super match (neither decl nor L1-gender)
now spelling out Agr terminal with values {'+definite', 'e_1', '-atomic', 'o_2'}
we picked e_1 bc its pronunciation was triggered at a distance by a n-borne gender feature
now spelling out KEY terminal with values set()
we picked KEY_1: no super match (neither decl nor L1-gender)
now spelling out nominalizer terminal with values {'e_1', 'o_2'}
we picked null_9: no super match (neither decl nor L1-gender)
now spelling out atomic terminal with values {'-atomic'}
we picked i_1: no super match (neither decl nor L1-gender)
input pronunciation: le#KEY-i
full_pronunciation: le#KEYi
vis_used:
Successful derivation!
Since it worked, and the nominalizer's value(s) contributed to spellout (was a diacritic in vis_used), let's add Root: KEY to the selectional of the nominalizer whose values are {'e_1', 'o_2'}
Before changes, that nominalizer was NominalizerTerminal:
    label: nominalizer
    values: {'e_1', 'o_2'}
    selectional: {'MOUSE', 'BOOK', 'CHILD', 'PIBLING', 'TOWER', 'GRANDPARENT', 'CASTLE', 'CAR', 'CLOWN', 'OFFSPRING'}
    selection_strength: True
    weight: 27.900000000000027
    linear: (<__main__.NominalizerTerminal object at 0x10fc3d400>,)
VocabularyItem:
    pronunciation: l
    label: definite
    values: {'+definite'}
    diacritic: l_1
    triggers: set()
    weight: 190.8999999999952
VocabularyItem:
    pronunciation: e
    label: Agr
    values: {'-atomic'}
    diacritic: e_1
    triggers: set()
    weight: 55.90000000000045
VocabularyItem:
    pronunciation: KEY
    label: KEY
    values: set()
    diacritic: KEY_1
    triggers: set()
    weight: 11.3
VocabularyItem:
    pronunciation: null
    label: nominalizer
    values: {'o_2'}
    diacritic: null_9
    triggers: {('o', frozenset({'+atomic'}))}
    weight: 11.3
VocabularyItem:
    pronunciation: i
    label: atomic
    values: {'-atomic'}
    diacritic: i_1
    triggers: set()
    weight: 29.100000000000037
line done
line done
